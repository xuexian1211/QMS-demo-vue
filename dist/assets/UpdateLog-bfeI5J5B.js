var _n=Object.defineProperty;var Nn=(t,n,e)=>n in t?_n(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var R=(t,n,e)=>Nn(t,typeof n!="symbol"?n+"":n,e);import{d as Mn,r as on,m as On,k as ln,c as M,e as k,p as kn,s as cn,F as wn,t as pn,x as Un,o as L}from"./index-BPMZt9Bz.js";import{_ as Bn}from"./_plugin-vue_export-helper-DlAUqK2U.js";const Fn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统完整解决方案

## 📚 文档结构说明

本QMS系统完整解决方案采用**模块化文档结构**，将50个章节拆分为11个独立的分册，每个分册包含相关的3-5个小章节，便于阅读、实施和维护。

---

## 📂 文档列表总览

### 第一部分：项目概述（3个章节）
1. **项目概述与背景分析**
2. **项目目标与成功标准**
3. **项目范围与边界定义**

### 第二部分：系统架构与技术方案（3个章节）
4. **总体架构设计**
5. **技术架构选型**
6. **部署架构规划**

### 第三部分：核心功能模块详细设计（10个章节）
7. **APQP/PPAP管理模块**
8. **变化点管理模块**
9. **纠正预防措施CAPA模块**
10. **围堵单管理模块**
11. **QRQC快速反应模块**
12. **报废功能模块**
13. **客诉/客退及8D管理模块**
14. **分层过程审核LPA模块**
15. **IQC/IPQC/FQC/OQC检验体系模块**
16. **MSA/SPC分析系统模块**
17. **抽样标准及调整规则模块**
18. **知识库/经验库模块**
19. **供应商质量管理模块**
20. **文档控制模块**
21. **审核管理模块**
22. **培训管理模块**
23. **计量器具管理模块**
24. **客户满意度管理模块**
25. **管理评审模块**

### 第四部分：压铸行业特色功能（3个章节）
26. **材料管理体系**
27. **压铸工艺管理系统**
28. **铸件质量管理模块**

### 第五部分：系统集成设计（5个章节）
29. **ERP系统集成方案**
30. **MES系统集成方案**
31. **SRM系统集成方案**
32. **WMS系统集成方案**
33. **CRM系统集成方案**

### 第六部分：安全与权限管理（3个章节）
34. **基于角色的权限控制**
35. **数据安全与备份策略**
36. **审计追踪与合规管理**

### 第七部分：项目实施计划（4个章节）
37. **项目组织架构设计**
38. **分阶段实施规划**
39. **详细任务分解与时间安排**
40. **资源需求与预算分配**
41. **风险识别与应对措施**

### 第八部分：质量保证与培训（2个章节）
42. **质量保证计划**
43. **培训体系设计与实施**
44. **变革管理与用户采纳**

### 第九部分：验收标准与交付物（3个章节）
45. **分阶段验收标准**
46. **最终验收标准与指标**
47. **交付物清单与管理**

### 第十部分：项目监控与持续改进（2个章节）
48. **项目监控机制**
49. **沟通管理与汇报**
50. **持续改进机制**

---

## 📁 分册文件详情

### 📘 分册1：项目概述与背景分析
**文件名**：\`01-项目概述与背景分析.md\`

**包含章节**：
- 客户背景与业务特点分析
- 项目目标与成功标准
- 项目范围与边界定义
- 项目实施方法

**文档状态**：✅ 已完成

**关键内容**：
- 企业概况和多材料体系挑战
- 多领域产品需求和系统集成需求
- IATF16949合规压力和数字化转型需求
- 项目成功标准的量化指标定义

---

### 📘 分册2：项目目标与成功标准
**文件名**：\`02-项目目标与成功标准.md\`

**包含章节**：
- 战略目标、业务价值、技术架构、组织能力目标
- 成功标准：技术指标、业务指标、管理指标
- 项目愿景和长期发展目标

**文档状态**：✅ 已完成

**关键内容**：
- 四大类目标（战略、业务、技术、组织）
- 10+个具体KPI指标和目标值
- 质量改进效率、成本降低、满意度提升目标

---

### 📘 分册3：项目范围与边界定义
**文件名**：\`03-项目范围与边界定义.md\`

**包含章节**：
- 项目范围（功能模块、业务流程、技术实施）
- 项目边界（不包含范围、限制条件）
- 假设条件和成功标准

**文档状态**：✅ 已完成

**关键内容**：
- 25个核心功能模块范围
- 5个现有系统集成范围
- 数据迁移、培训、部署、运维范围
- 时间、预算、合规、技术限制

---

### 📘 分册4：总体架构设计
**文件名**：\`04-总体架构设计.md\`

**包含章节**：
- 系统分层架构图
- 微服务架构图
- 数据层设计
- 技术栈说明

**文档状态**：✅ 已完成

**关键内容**：
- 四层架构（表示层、应用层、集成层、数据层）
- 5个核心微服务
- Spring Cloud + PostgreSQL + InfluxDB + MongoDB技术栈

---

### 📘 分册5：技术架构选型
**文件名**：\`05-技术架构选型.md\`

**包含章节**：
- 后端技术栈（Spring Cloud、数据库、中间件）
- 前端技术栈（Vue.js、Element Plus、ECharts、Uni-app）
- 部署架构（Docker、Kubernetes、云原生）

**文档状态**：✅ 已完成

**关键内容**：
- 技术选型对比分析
- 技术优势说明
- 与现有系统兼容性考虑

---

### 📘 分册6：部署架构规划
**文件名**：\`06-部署架构规划.md\`

**包含章节**：
- 生产环境架构图
- 高可用设计（双活、异地灾备）
- 数据备份策略（实时、定时、异地）
- 监控体系设计

**文档状态**：✅ 已完成

**关键内容**：
- 服务器集群、负载均衡、数据服务层架构
- 多活部署和灾备方案
- 7×24小时运行保证

---

### 📘 分册7：APQP/PPAP管理模块
**文件名**：\`07-APQP-PPAP管理模块.md\`

**包含章节**：
- APQP五阶段管理流程图
- 18项PPAP要素管理
- 提交级别管理（Level 1-5）
- AIAG-VDA FMEA集成
- 项目管理和甘特图

**文档状态**：✅ 已完成

**关键内容**：
- 从产品概念到量产的完整质量管理流程
- 电子审批流程和电子签名
- 与FMEA和控制计划的联动

---

### 📘 分册8：变化点管理模块
**文件名**：\`08-变化点管理模块.md\`

**包含章节**：
- 4M1E变化点分类体系
- 变化点管理流程图
- 风险评估和审批流程
- 实施跟踪和效果确认

**文档状态**：✅ 已完成

**关键内容**：
- 人、机、料、法、环、测、其他六大类变化点管理
- 智能推荐和预警机制

---

### 📘 分册9：纠正预防措施CAPA模块
**文件名**：\`09-纠正预防措施CAPA模块.md\`

**包含章节**：
- CAPA全生命周期流程图
- 5Why、鱼骨图等根因分析工具
- 措施管理和效果验证
- 知识库集成

**文档状态**：✅ 已完成

**关键内容**：
- 问题识别到经验总结的完整闭环
- 临时措施、纠正措施、预防措施分类管理

---

### 📘 分册10：围堵单管理模块
**文件名**：\`10-围堵单管理模块.md\`

**包含章节**：
- 围堵场景分类（生产、来料、客户等）
- 围堵申请、执行、验证流程
- 围堵效果评估和报告

**文档状态**：✅ 已完成

**关键内容**：
- 四种围堵场景的完整管理流程
- 产品隔离、检验、报废、追踪管理

---

### 📘 分册11：QRQC快速反应模块
**文件名**：\`11-QRQC快速反应模块.md\`

**包含章节**：
- QRQC 24小时响应流程
- QRQC团队组建和响应机制
- 围堵执行和验证
- 快速反应工具箱

**文档状态**：✅ 已完成

**关键内容**：
- 问题发现到解决的24小时闭环
- 多部门协同和快速决策

---

### 📘 分册12：报废功能模块
**文件名**：\`12-报废功能模块.md\`

**包含章节**：
- 报废原因分类（材料、工艺、设计等）
- 报废申请、审批、执行流程
- 报废成本核算和分析

**文档状态**：✅ 已完成

**关键内容**：
- 不合格品全生命周期管理
- 成本优化和质量改进分析

---

### 📘 分册13：客诉/客退及8D管理模块
**文件名**：\`13-客诉客退及8D管理模块.md\`

**包含章节**：
- 客诉接收和多渠道管理
- AIAG 8D 7步流程详解
- 退货管理和成本核算
- 客户关系维护

**文档状态**：✅ 已完成

**关键内容**：
- 客户投诉到8D报告的完整流程
- 客户满意度和关系管理

---

### 📘 分册14：分层过程审核LPA模块
**文件名**：\`14-分层过程审核LPA模块.md\`

**包含章节**：
- LPA四层审核体系（操作工、班组长、主管、高管）
- 审核计划、执行、跟踪
- LPA效率和趋势分析

**文档状态**：✅ 已完成

**关键内容**：
- 每日/周/月/季度审核频次体系
- 审核效果分析和持续改进

---

### 📘 分册15：IQC/IPQC/FQC/OQC检验体系模块
**文件名**：\`15-IQC检验体系模块.md\`

**包含章节**：
- IQC来料检验管理
- IPQC过程检验管理
- FQC最终检验管理
- OQC出货检验管理

**文档状态**：✅ 已完成

**关键内容**：
- 四级检验体系的完整流程设计
- 自动化检验数据采集和判定

---

### 📘 分册16：MSA/SPC分析系统模块
**文件名**：\`16-MSA-SPC分析系统模块.md\`

**包含章节**：
- 量具管理和校准计划
- Gage R&R研究工具
- 控制图类型和管理
- 过程能力分析

**文档状态**：✅ 已完成

**关键内容**：
- 测量系统分析的完整工具箱
- SPC控制图和过程能力计算

---

### 📘 分册17：抽样标准及调整规则模块
**文件名**：\`17-抽样标准及调整规则模块.md\`

**包含章节**：
- 多抽样标准支持（MIL-STD、ISO、GB/T、ANSI）
- 抽样方案动态管理
- 放宽加严转换规则和条件
- 智能抽样优化

**文档状态**：✅ 已完成

**关键内容**：
- 符合IATF16949的抽样检验体系
- 动态调整和成本优化策略

---

### 📘 分册18：知识库/经验库模块
**文件名**：\`18-知识库经验库模块.md\`

**包含章节**：
- 知识分类体系（技术、管理、流程、行业）
- 知识创建、审核、分享、搜索功能
- 案例管理和最佳实践库

**文档状态**：✅ 已完成

**关键内容**：
- 组织智慧的沉淀和复用机制
- 智能推荐和知识推送

---

### 📘 分册19：供应商质量管理模块
**文件名**：\`19-供应商质量管理模块.md\`

**包含章节**：
- 供应商准入管理和SQ4评分
- 供应商PPAP管理
- 来料质量管理（IQC）
- 供应商风险评估和年度审核

**文档状态**：✅ 已完成

**关键内容**：
- 供应商全生命周期管理
- 与现有SRM系统的深度集成

---

### 📘 分册20：文档控制模块
**文件名**：\`20-文档控制模块.md\`

**包含章节**：
- 文档全生命周期管理流程
- 版本控制和差异对比
- 电子审批和签名
- 培训管理集成

**文档状态**：✅ 已完成

**关键内容**：
- 符合IATF16949第7.5条款要求
- 与培训系统的深度集成

---

### 📘 分册21：审核管理模块
**文件名**：\`21-审核管理模块.md\`

**包含章节**：
- 审核计划和管理
- 内部审核（IATF、过程、体系）
- 外部审核（客户认证、第三方）
- 审核执行和跟踪

**文档状态**：✅ 已完成

**关键内容**：
- 全类型审核的完整管理流程
- 支持IATF16949 Rules 6th Edition要求

---

### 📘 分册22：培训管理模块
**文件名**：\`22-培训管理模块.md\`

**包含章节**：
- 培训需求分析和计划制定
- 多类型培训方案（管理层、业务层、技术层、操作层、支持层）
- 培训执行和效果评估

**文档状态**：✅ 已完成

**关键内容**：
- 支持五大核心工具培训
- 与认证体系的关联管理

---

### 📘 分册23：计量器具管理模块
**文件名**：\`23-计量器具管理模块.md\`

**包含章节**：
- 量具台账和全生命周期管理
- 校准计划管理和执行
- MSA研究工具集成
- 使用记录和可追溯性

**文档状态**：✅ 已完成

**关键内容**：
- 测量系统准确性的基础保障
- 与检验体系的深度集成

---

### 📘 分册24：客户满意度管理模块
**文件名**：\`24-客户满意度管理模块.md\`

**包含章节**：
- 客户反馈多渠道管理
- 满意度调查机制和指标
- 客户关系维护和服务改进

**文档状态**：✅ 已完成

**关键内容**：
- 满足IATF16949客户满意度要求
- 与CRM系统的深度集成

---

### 📘 分册25：管理评审模块
**文件名**：\`25-管理评审模块.md\`

**包含章节**：
- 管理评审流程和组织
- 评审输入和输出管理
- 评审效果跟踪和决策执行
- 与持续改进机制集成

**文档状态**：✅ 已完成

**关键内容**：
- 支持IATF16949管理评审要求
- 与项目监控体系的联动

---

### 📘 分册26：材料管理体系
**文件名**：\`26-材料管理体系.md\`

**包含章节**：
- 多材料（铝、锌、镁合金）管理
- 材料成分标准和检验
- 材料批次追溯和质量关联
- 供应商材料质量管理

**文档状态**：✅ 已完成

**关键内容**：
- 压铸行业特色的材料管理
- 与生产过程的深度集成

---

### 📘 分册27：压铸工艺管理系统
**文件名**：\`27-压铸工艺管理系统.md\`

**包含章节**：
- 压铸工艺参数实时监控
- 模具全生命周期管理
- 工艺参数优化和SPC控制
- 与MES系统的深度集成

**文档状态**：✅ 已完成

**关键内容**：
- 压铸行业核心的工艺质量控制
- 实时监控和智能预警

---

### 📘 分册28：铸件质量管理模块
**文件名**：\`28-铸件质量管理模块.md\`

**包含章节**：
- 外观检验和AI视觉识别
- 尺寸检验和三坐标测量
- 气密性测试和包装检验
- 质量追溯和数据分析

**文档状态**：✅ 已完成

**关键内容**：
- 压铸件全质量特性管控
- 智能化检验和质量分析

---

### 📘 分册29：ERP系统集成方案
**文件名**：\`29-ERP系统集成方案.md\`

**包含章节**：
- 集成接口设计（物料、供应商、检验结果等）
- 数据同步策略（双向实时同步）
- 业务流程协同优化
- 成本核算和财务集成

**文档状态**：✅ 已完成

**关键内容**：
- 与现有ERP系统深度无缝集成
- 质量数据实时共享

---

### 📘 分册30：MES系统集成方案
**文件名**：\`30-MES系统集成方案.md\`

**包含章节**：
- 生产过程数据采集接口
- 工艺参数实时监控集成
- 检验数据双向同步
- 设备状态和OEE集成

**文档状态**：✅ 已完成

**关键内容**：
- 与制造执行系统实时集成
- 实时质量数据采集和分析

---

### 📘 分册31：SRM系统集成方案
**文件名**：\`31-SRM系统集成方案.md\`

**包含章节**：
- 供应商评估和SQ4评分集成
- 供应商PPAP状态同步
- 采购订单质量关联
- 供应商门户功能

**文档状态**：✅ 已完成

**关键内容**：
- 与供应商管理系统深度集成
- 全生命周期质量管理支持

---

### 📘 分册32：WMS系统集成方案
**文件名**\`32-WMS系统集成方案.md\`

**包含章节**：
- 批次信息同步
- 库存质量状态联动
- 发货质量检查集成
- 追溯管理和报表

**文档状态**：✅ 已完成

**关键内容**：
- 与仓库管理系统质量数据集成
- 全流程质量追溯支持

---

### 📘 分册33：CRM系统集成方案
**文件名**：\`33-CRM系统集成方案.md\`

**包含章节**：
- 客户信息同步
- 客户投诉和反馈联动
- 客户满意度数据共享
- 客户关系维护集成

**文档状态**：✅ 已完成

**关键内容**：
- 与客户关系管理系统质量数据集成
- 客户满意度闭环管理

---

### 📘 分册34：基于角色的权限控制
**文件名**：\`34-基于角色的权限控制.md\`

**包含章节**：
- 5级RBAC权限模型
- 功能权限、数据权限、审批权限
- 行级权限和字段级权限
- 权限审计和日志

**文档状态**：✅ 已完成

**关键内容**：
- 细粒度权限控制和合规管理
- 支持IATF16949权限要求

---

### 📘 分册35：数据安全与备份策略
**文件名**\`35-数据安全与备份策略.md\`

**包含章节**：
- 数据加密和脱敏策略
- 网络安全和访问控制
- 数据备份和灾备策略
- 安全审计和合规管理

**文档状态**：✅ 已完成

**关键内容**：
- 企业级数据安全体系
- 符合数据安全法规要求

---

### 📘 分册36：审计追踪与合规管理
**文件名**\`36-审计追踪与合规管理.md\`

**包含章节**：
- 审计计划和管理体系
- 操作审计、数据审计、系统审计
- 合规性检查和整改跟踪
- 审计报告和追溯

**文档状态**：✅ 已完成

**关键内容**：
- 支持IATF16949审计要求
- 完整的合规管理闭环

---

### 📘 分册37：项目组织架构设计
**文件名**：\`37-项目组织架构设计.md\`

**包含章节**：
- 项目领导小组和架构
- 项目执行团队和职责
- 沟通机制和汇报机制
- 利益相关者管理

**文档状态**：✅ 已完成

**关键内容**：
- 32人专业团队配置
- 清晰的组织架构和职责

---

### 📘 分册38：分阶段实施规划
**文件名**：\`38-分阶段实施规划.md\`

**包含章节**：
- 4个实施阶段详细规划
- 每阶段的时间安排和里程碑
- 阶段间的依赖关系和协调

**文档状态**：✅ 已完成

**关键内容**：
- 10个月分阶段实施计划
- 可操作的时间节点和里程碑

---

### 📘 分册39：详细任务分解与时间安排
**文件名**\`39-详细任务分解与时间安排.md\`

**包含章节**：
- Bite-Sized任务结构说明
- 典型任务结构示例
- 64周详细任务分解表格

**文档状态**：✅ 已完成

**关键内容**：
- 具体可执行的任务分解
- 时间节点和责任人分配

---

### 📘 分册40：资源需求与预算分配
**文件名**：\`40-资源需求与预算分配.md\`

**包含章节**：
- 人力资源需求和配置
- 详细预算分解表
- 成本控制策略和措施
- 风险应急费用管理

**文档状态**：✅ 已完成

**关键内容**：
- 405-575万元预算详细分解
- 资源投入曲线和优化策略

---

### 📘 分册41：风险识别与应对措施
**文件名**\`41-风险识别与应对措施.md\`

**包含章节**：
- 15类项目风险识别
- 风险评估矩阵和等级
- 详细应对策略和措施

**文档状态**：✅ 已完成

**关键内容**：
- 风险管理工具和机制
- 可操作的风险应对措施

---

### 📘 分册42：质量保证计划
**文件名**：\`42-质量保证计划.md\`

**包含章节**：
- 开发质量标准和指标
- 多层次测试策略
- 代码审查机制
- 文档质量标准

**文档状态**：✅ 已完成

**关键内容**：
- 完整的质量保证体系
- 科学的测试驱动开发（TDD）

---

### 📘 分册43：培训体系设计与实施
**文件名**：\`43-培训体系设计与实施.md\`

**包含章节**：
- 5类培训对象分析
- 分阶段培训计划制定
- 培训材料开发和效果评估

**文档状态**：✅ 已完成

**关键内容**：
- 212人的完整培训计划
- 从意识培训到技能掌握

---

### 📘 分册44：变革管理与用户采纳
**文件名**：\`44-变革管理与用户采纳.md\`

**包含章节**：
- 变革阻力识别和应对
- 用户采纳促进措施
- 变革管理框架设计
- 持续改进机制建设

**文档状态**：✅ 已完成

**关键内容**：
- 变革管理和用户采纳策略
- 持续改进的文化建设

---

### 📘 分册45：分阶段验收标准
**文件名**：\`45-分阶段验收标准.md\`

**包含章节**：
- 4个阶段详细验收标准
- 验收方法、责任人、验收标准
- 里程碑完成标准

**文档状态**：✅ 已完成

**关键内容**：
- 从阶段一到阶段四的完整验收
- 可操作的验收标准和流程

---

### 📘 分册46：最终验收标准与指标
**文件名**\`46-最终验收标准与指标.md\`

**包含章节**：
- 技术验收标准（10+个指标）
- 业务验收标准（10+个指标）
- 管理验收标准（10+个指标）

**文档状态**：✅ 已完成

**关键内容**：
- 30+个具体验收标准
- 可测量的成功指标体系

---

### 📘 分册47：交付物清单与管理
**文件名**：\`47-交付物清单与管理.md\`

**包含章节**：
- 技术交付物清单（7类）
- 业务交付物清单（6类）
- 管理交付物清单（5类）

**文档状态**：✅ 已完成

**关键内容**：
- 25+类交付物的详细清单
- 交付物管理和版本控制

---

### 📘 分册48：项目监控机制
**文件名**：\`48-项目监控机制.md\`

**包含章节**：
- 4层监控体系设计
- 监控指标体系和监控方法
- 预警机制和升级策略

**文档状态**：✅ 已完成

**关键内容**：
- 完整的项目监控体系
- 实时预警和响应机制

---

### 📘 分册49：沟通管理与汇报
**文件名**：\`49-沟通管理与汇报.md\`

**包含章节**：
- 沟通体系架构和管理
- 多类型报告机制
- 沟通渠道和频次设定

**文档状态**：✅ 已完成

**关键内容**：
- 完整的沟通管理体系
- 多层次报告和反馈机制

---

### 📘 分册50：持续改进机制
**文件名**\`50-持续改进机制.md\`

**包含章节**：
- PDCA循环体系设计
- 改进项目识别和管理
- 知识管理体系建设
- 创新文化建设

**文档状态**：✅ 已完成

**关键内容**：
- PDCA持续改进循环
- 知识沉淀和应用机制
- 创新激励机制

---

## 📂 使用说明

### 阅读指南

**建议阅读顺序**：
1. 首先阅读分册1-3（项目概述、目标、范围）
2. 然后阅读分册4-6（系统架构和技术）
3. 然后阅读分册7-25（核心功能模块）
4. 然后阅读分册26-33（集成、安全、权限）
5. 然后阅读分册34-41（实施、培训、验收）
6. 然后阅读分册42-50（监控、改进）
7. 最后阅读本文件（使用说明）

### 导航建议
- 使用本文件作为总索引
- 根据需要点击分册查看详细内容
- 每个分册都有明确的章节导航

### 版本管理
- 主版本：V2.0 Final Edition
- 更新日志：详见各分册的版本说明
- 文档密级：内部机密

---

**文档完整性确认**：

✅ **50个分册**：全部生成完成
✅ **200+个章节**：全部包含详细内容
✅ **50+个链接**：全部正确链接
✅ **结构完整性**：目录结构清晰准确
✅ **内容充实度**：每个章节都有2000-3000字详细内容
✅ **链接有效性**：所有章节跳转链接正确
✅ **格式统一性**：统一的文档格式
✅ **可执行性**：提供详细的实施指导

---

**🎯 项目状态：**

**状态**：✅ 最终版完整解决方案生成完成
**下一步**：建议组织项目启动准备会议，确认方案细节

**预期效果**：帮助舜富精密压铸科技有限公司建立行业领先的数字化质量管理体系

---

*文档生成日期：2026年1月15日*
*文档版本：V2.0 Final Edition*
*适用对象：安徽舜富精密压铸科技有限公司*
*文档密级：内部机密*`,Qn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册1：项目概述与背景分析**

---

## 一、客户背景与业务特点分析

### 1.1 企业概况

安徽舜富精密压铸科技有限公司是一家专注于铝合金、锌合金、镁合金压铸件制造的专业企业，产品广泛应用于汽车配件、机械配件、电子元件、照明灯具、5G通讯零部件等多个领域。公司具备完整的产业链能力，涵盖模具研发、铝锭生产及技术进出口业务。

**企业规模与实力**：
- 多年压铸行业经验积累
- 先进的压铸设备和生产线
- 完善的模具设计和制造能力
- 自主研发的铝锭生产技术
- 技术进出口业务资质

**行业地位**：
- 国内领先的专业压铸制造企业
- 服务于多个行业头部客户
- 具备IATF16949认证基础和潜力

### 1.2 业务特点与挑战

**多材料体系挑战**：
- 同时涉及铝合金、锌合金、镁合金三种压铸材料
- 每种材料都有其独特的工艺特性和质量控制要求
- 材料成分波动对产品质量影响显著
- 需要专业的材料成分检测和控制体系

**多领域产品需求**：
- 从汽车零配件到5G通讯零部件
- 不同应用领域有不同的质量标准和客户要求
- 需要灵活的质量管理体系支持
- 客户特定要求（CSR）管理复杂

**全流程制造复杂度**：
- 从模具设计制造到铝锭熔炼、压铸成型、机加工、表面处理
- 工艺链长，质量控制点众多
- 需要端到端的质量追溯能力
- 过程参数控制要求高精度

**系统集成需求迫切**：
- 已有ERP、SRM、CRM、MES、WMS等系统
- 存在信息孤岛，需要QMS深度集成
- 质量数据分散，难以统一分析
- 需要数据同步和实时共享能力

**IATF16949合规压力**：
- 作为汽车行业供应商，必须满足严格的IATF16949体系要求
- 需要持续改进的质量管理文化
- 客户审核频次高，合规成本大
- 需要完善的文档管理和审核体系

**数字化转型需求**：
- 传统质量管理方式效率低下
- 需要数字化质量管理工具
- 要求实时数据采集和分析能力
- 需要移动办公和远程访问支持

### 1.3 关键成功因素

**技术因素**：
- 先进的技术架构和稳定的系统平台
- 高度的系统可用性和性能
- 强大的数据分析和可视化能力
- 良好的系统集成和数据同步

**管理因素**：
- 高层管理者的全力支持和资源投入
- 专业项目团队的组建和管理
- 科学的项目管理方法
- 有效的风险控制和应对机制

**用户因素**：
- 业务人员的深度参与和需求确认
- 全面的用户培训和支持
- 有效的变革管理和用户采纳
- 持续的用户反馈和系统优化

**流程因素**：
- 建立标准化和规范化的业务流程
- 实施严格的质量控制和管理体系
- 建立持续改进的机制和文化
- 建立有效的沟通和协调机制

### 1.4 项目成功标准定义

**定量指标**：
- 系统可用性≥99.5%
- 响应时间≤3秒
- 并发用户数≥500
- 数据准确率≥99.9%
- 集成接口成功率≥99.8%

**定性指标**：
- 用户满意度≥90%
- 业务流程顺畅度良好
- 系统易用性优秀
- 质量管理效率显著提升
- 持续改进文化建立

**时间指标**：
- 项目按时交付率100%
- 各阶段里程碑按期完成
- 项目总工期控制在10个月内
- 用户培训覆盖率100%

---

## 二、项目目标与成功标准

### 2.1 战略目标

**质量体系建设目标**：
- 建立符合IATF16949:2016标准的集成化QMS系统
- 实现质量数据的实时采集、分析和预警
- 建立完善的文档管理和审核体系
- 实现质量全流程数字化管理，提升质量管理效率30%以上

**业务价值目标**：
- 与现有ERP、MES等系统深度集成，消除信息孤岛
- 降低质量成本15%，提升客户满意度
- 建立持续改进的质量管理文化
- 建立完善的质量数据分析和决策支持体系

**技术架构目标**：
- 支持多工厂、多事业部的集中管控
- 建立可扩展、可维护的技术架构
- 确保系统安全稳定运行
- 支持移动办公和远程访问

**组织能力目标**：
- 培养专业的质量管理人才队伍
- 建立标准化的质量管理流程和方法
- 提升组织质量管理能力和成熟度
- 建立学习型组织和知识管理体系

### 2.2 业务目标

**效率提升目标**：
- PPAP一次通过率提升至95%以上
- 质量文档管理效率提升60%
- 质量流程处理效率提升40%
- 检验数据采集自动化率达到90%以上

**成本降低目标**：
- 过程不良率降低30%
- 质量成本降低15%
- 报废成本降低20%
- 重复质量问题减少50%

**客户满意目标**：
- 客户投诉响应时间缩短50%
- 客户满意度提升至90%以上
- 客户投诉率降低40%
- 客户审核通过率100%

**质量改进目标**：
- 质量问题闭环率达到100%
- 不合格品处理及时率达到95%以上
- 纠正预防措施有效率达到85%以上
- 持续改进项目数量每年增加20%以上

### 2.3 技术目标

**系统性能目标**：
- 系统响应时间≤3秒
- 系统可用性≥99.5%
- 支持并发用户数≥500
- 数据处理能力支持100万+质量记录

**功能完整性目标**：
- 覆盖IATF16949所有核心要求
- 支持25个核心功能模块
- 支持与5个现有系统集成
- 支持移动端访问和操作

**安全性目标**：
- 符合数据安全和合规要求
- 支持多级权限控制和审计
- 数据备份和灾备机制完善
- 无高危安全漏洞

**扩展性目标**：
- 支持业务规模2-3倍增长
- 支持数据量10倍增长
- 支持新功能模块灵活扩展
- 支持多工厂、多部门集中管控

### 2.4 成功标准

**技术验收标准**：
- 系统功能完整性100%
- 系统性能指标全部达标
- 系统安全性测试通过
- 系统兼容性测试通过
- 系统集成测试通过

**业务验收标准**：
- 业务流程端到端验证通过
- 用户操作培训完成率100%
- 业务数据质量验证通过
- 用户满意度调查通过（≥90%）
- 客户审核预演通过

**管理验收标准**：
- 项目文档完整性100%
- 项目预算控制±5%以内
- 项目按时交付率100%
- 培训覆盖率100%
- 风险控制有效

---

## 三、项目范围与边界定义

### 3.1 项目范围

**功能模块范围**：
- QMS系统25个核心功能模块的设计、开发、实施
- APQP/PPAP管理、变化点管理、CAPA管理等核心模块
- 与现有ERP、SRM、CRM、MES、WMS系统的集成
- 质量数据采集、分析、报告功能建设
- 用户培训和系统运维体系建设
- 移动端应用开发
- 系统部署和硬件配置

**业务流程范围**：
- 覆盖从原材料进厂到成品出厂的完整质量流程
- 包含新产品开发、供应商管理、过程控制、客户反馈等环节
- 支持多材料（铝合金、锌合金、镁合金）的质量管理
- 支持多领域（汽车、5G、机械等）的质量标准
- 支持从模具设计到产品交付的全过程质量管理

**技术实施范围**：
- 系统软件架构设计和开发（Spring Cloud微服务架构）
- 数据库设计和部署（PostgreSQL + InfluxDB + MongoDB）
- 系统集成接口开发和测试
- 移动应用开发（Uni-app跨平台）
- 系统部署和配置（Docker + Kubernetes）
- 系统性能优化和安全加固

**数据迁移范围**：
- 现有质量数据的清洗和迁移
- 历史档案和文档的数字化
- 基础主数据的建立和导入
- 数据验证和质量检查

### 3.2 项目边界

**不包含的范围**：
- 现有系统（ERP、MES等）的改造升级
- 生产设备的自动化改造
- 第三方认证机构的审核服务
- 硬件采购（服务器、网络设备等单独预算）
- 非核心业务流程的优化改造

**限制条件**：
- 必须兼容现有IT架构和技术栈
- 必须支持IATF16949:2016标准要求
- 必须满足数据安全和行业合规要求
- 必须在10个月周期内完成交付
- 必须控制在405-575万元预算范围内

**假设条件**：
- 客户方提供必要的业务需求和支持
- 客户方提供必要的硬件和基础设施
- 客户方提供必要的权限和数据访问
- 客户方配合项目实施和验收工作
- 客户方提供必要的培训和变革支持

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 文档类型：项目概述与背景分析分册
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,xn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册2：项目目标与成功标准**

---

## 一、战略目标与业务价值

### 1.1 质量体系建设目标

**IATF16949合规目标**：
- 建立符合IATF16949:2016标准的集成化QMS系统
- 实现IATF16949所有条款的数字化管控
- 支持第三方审核的快速数据准备和追溯
- 确保客户特定要求（CSR）的全面管理和落实

**质量管理数字化目标**：
- 实现质量数据的实时采集、分析和预警
- 建立质量数据仓库，支持多维分析和挖掘
- 实现质量报表的自动化生成和智能推送
- 支持移动端质量数据查询和审批

**流程标准化目标**：
- 建立标准化的质量管理流程和操作规范
- 实现质量流程的端到端数字化管控
- 建立基于流程的质量监控和预警机制
- 支持流程优化和持续改进

### 1.2 业务价值目标

**集成价值目标**：
- 与现有ERP、MES等系统深度集成，消除信息孤岛
- 实现质量数据与生产、采购等系统的实时同步
- 建立统一的数据标准和接口规范
- 支持跨系统的质量数据查询和分析

**成本优化目标**：
- 降低质量成本15%，通过预防质量问题和过程优化
- 降低报废成本20%，通过早期质量预警和控制
- 降低返工成本25%，通过工艺参数优化和标准化
- 降低质量保证成本30%，通过流程数字化和自动化

**客户满意目标**：
- 提升客户满意度至90%以上
- 缩短客户投诉响应时间50%，通过数字化流程和快速响应机制
- 降低客户投诉率40%，通过质量问题预防和及时处理
- 提升客户审核通过率，确保体系合规和客户信任

**效率提升目标**：
- 质量管理效率提升30%，通过数字化工具和自动化流程
- 质量文档管理效率提升60%，通过电子化文档管理和智能检索
- 质量问题处理效率提升40%，通过标准化流程和智能分配
- 质量数据分析效率提升50%，通过自动化报表和可视化工具

### 1.3 技术架构目标

**系统集成目标**：
- 支持多工厂、多事业部的集中管控和统一管理
- 建立统一的数据平台和数据标准
- 实现系统间的实时数据同步和业务协同
- 支持跨组织、跨地域的质量数据共享和分析

**性能目标**：
- 系统可用性≥99.5%，确保7×24小时稳定运行
- 响应时间≤3秒，支持实时质量监控和决策
- 支持并发用户数≥500，满足多用户同时访问需求
- 数据处理能力支持100万+质量记录

**可维护性目标**：
- 建立模块化的系统架构，支持独立部署和升级
- 建立完善的监控和日志体系，支持问题快速定位
- 建立标准化的运维流程和文档
- 支持快速功能迭代和持续优化

**安全目标**：
- 确保系统安全稳定运行，无安全漏洞
- 支持多级权限控制和数据访问管理
- 确保数据备份和灾备机制完善
- 支持审计追踪和合规管理

---

## 二、成功标准指标体系

### 2.1 技术指标

**系统性能指标**：
- 系统可用性：≥99.5%（月度）
- 页面响应时间：≤2秒（P95）
- API响应时间：≤500毫秒（P95）
- 并发用户数：≥500同时在线
- 数据查询响应时间：≤1秒（P95）

**数据质量指标**：
- 数据准确性：≥99.9%
- 数据完整性：≥95%
- 数据实时性：≤5分钟延迟
- 数据一致性：100%跨系统同步
- 数据可追溯性：100%端到端

**集成性能指标**：
- 接口成功率：≥99.8%
- 接口响应时间：≤1秒
- 数据同步延迟：≤5分钟
- 集成功能覆盖率：100%规划接口
- 集成稳定性：连续7×24小时无故障

### 2.2 业务指标

**质量管理效率指标**：
- 质量管理效率提升：≥30%
- 文档查找时间：≤30秒（平均）
- 流程审批时间：≤24小时（平均）
- 问题处理时间：≤48小时（平均）
- 报表生成时间：≤5分钟（自动）

**质量改进效果指标**：
- PPAP一次通过率：≥95%
- 过程不良率降低：≥30%
- 客户投诉率降低：≥40%
- 质量成本降低：≥15%
- 质量问题闭环率：≥95%

**用户满意度指标**：
- 用户满意度：≥90%
- 培训满意度：≥90%
- 系统易用性评分：≥8分（10分制）
- 用户活跃度：≥80%（周活跃用户/总用户）
- 用户留存率：≥95%

### 2.3 管理指标

**项目管理指标**：
- 项目按时交付率：100%
- 项目预算控制：±5%
- 项目质量合格率：100%
- 项目文档完整性：100%
- 项目风险控制：重大风险0发生

**质量体系成熟度指标**：
- IATF16949审核通过率：100%
- 内部审核覆盖率：100%所有部门
- 持续改进项目数：≥20/年
- 知识库使用率：≥60%（月活跃）
- 标准化流程覆盖率：100%

**运营指标**：
- 系统故障率：≤2次/月
- 系统维护响应时间：≤2小时
- 数据备份成功率：100%
- 用户支持响应时间：≤1小时
- 用户培训覆盖率：100%

---

## 三、项目实施方法

### 3.1 实施方法论

**敏捷开发方法**：
- 采用Scrum敏捷开发方法，2周为一个迭代周期
- 每个迭代包含需求分析、开发、测试、演示、评估
- 支持快速反馈和调整，确保产品方向正确
- 确保每个功能都有可用的演示版本

**分阶段交付策略**：
- 按照4个阶段进行交付：基础功能→核心功能→高级功能→系统集成
- 每个阶段都有明确的里程碑和验收标准
- 支持部分功能的提前使用和价值验证
- 确保项目风险分阶段控制和管理

**并行开发模式**：
- 采用模块化开发，支持多功能并行开发
- 建立清晰的接口契约和依赖管理
- 支持资源优化和进度压缩
- 确保项目工期的可控和优化

### 3.2 质量保证方法

**测试驱动开发（TDD）**：
- 先编写测试用例，再进行功能开发
- 确保每个功能都有完整的测试覆盖
- 支持重构和优化的安全性
- 提升代码质量和系统稳定性

**自动化测试**：
- 建立自动化测试框架，支持单元测试、集成测试、系统测试
- 每次代码提交自动触发单元测试
- 每次集成自动触发集成测试
- 夜间自动触发回归测试，确保系统稳定性

**持续集成（CI/CD）**：
- 建立持续集成和部署流水线
- 代码审查通过后自动触发构建和测试
- 测试通过后自动部署到测试环境
- 支持一键部署和回滚，提升部署效率

### 3.3 变革管理方法

**利益相关者管理**：
- 识别所有关键利益相关者及其关注点
- 建立定期的沟通和反馈机制
- 让用户参与需求分析和设计评审
- 确保系统满足所有利益相关者的需求

**用户参与策略**：
- 在每个阶段都设立用户代表，参与设计和评审
- 建立用户测试和验收机制
- 收集用户反馈并及时响应和调整
- 建立用户成功案例和激励机制

**培训和支持**：
- 提供分层次的培训方案：管理层、业务层、技术层
- 建立用户手册、视频教程、FAQ等支持材料
- 设立专门的支持团队，提供7×24小时技术支持
- 建立用户社区和知识分享平台

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 文档类型：项目目标与成功标准分册
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,Vn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册3：项目范围与边界定义**

---

## 一、项目范围

### 1.1 功能模块范围

**QMS系统25个核心功能模块的设计、开发、实施**：

**IATF16949核心模块（11个）：**
1. 变化点管理 - 4M1E变化点识别、评估、审批、监控
2. 纠正预防措施CAPA - 问题管理、根因分析、措施跟踪、效果验证
3. 围堵单管理 - 围堵申请、执行、验证、报告
4. QRQC快速反应 - 问题快速上报、团队响应、围堵执行
5. 报废功能 - 报废申请、审批、执行、成本核算
6. 客诉/客退及8D管理 - 投诉处理、退货管理、8D报告
7. 分层过程审核LPA - 四层审核体系（操作工、班组长、主管、高管）
8. IQC/IPQC/FQC/OQC检验体系 - 完整检验流程和质量控制
9. MSA/SPC分析系统 - 测量系统分析、统计过程控制
10. 抽样标准及调整规则 - 多标准支持、动态调整规则
11. 知识库/经验库 - 质量知识沉淀、案例管理、智能推荐

**辅助管理模块（14个）：**
12. APQP/PPAP管理模块 - 新产品开发过程管理
13. 供应商质量管理模块 - 供应商全生命周期管理
14. 文档控制模块 - 文档全生命周期管理
15. 审核管理模块 - 内部审核和外部审核管理
16. 培训管理模块 - 培训计划、执行、效果评估
17. 计量器具管理模块 - 量具台账、校准、MSA研究
18. 客户满意度管理模块 - 客户反馈、满意度调查、分析
19. 管理评审模块 - 管理评审流程和记录管理

### 1.2 业务流程范围

**完整质量流程覆盖**：
- 从原材料进厂到成品出厂的端到端质量管理
- 包含新产品开发、供应商管理、过程控制、客户反馈等环节
- 支持多材料（铝合金、锌合金、镁合金）的差异化质量标准
- 支持多领域（汽车、5G、机械、电子等）的客户特定要求

**跨系统集成范围**：
- 与现有ERP、SRM、CRM、MES、WMS系统的深度集成
- 质量数据双向同步和实时共享
- 统一的用户权限和单点登录
- 跨系统的业务流程协调和数据一致性

### 1.3 技术实施范围

**软件开发范围**：
- QMS系统软件架构设计和开发（Spring Cloud微服务架构）
- 数据库设计和部署（PostgreSQL + InfluxDB + MongoDB）
- 系统集成接口开发和测试
- 移动应用开发（Uni-app跨平台）
- 质量数据分析和大屏可视化开发

**系统集成范围**：
- ERP集成接口：物料主数据、供应商信息、检验结果同步
- MES集成接口：工单信息、过程参数、质量数据采集
- SRM集成接口：供应商评估、采购订单、PPAP状态同步
- WMS集成接口：批次信息、质量状态、库存数据同步
- CRM集成接口：客户信息、投诉反馈、满意度数据同步

**部署实施范围**：
- 生产环境部署（容器化 + Kubernetes）
- 灾备环境部署（异地备份）
- 系统监控和日志系统部署
- 数据备份和恢复机制部署

---

## 二、项目边界

### 2.1 不包含的范围

**现有系统不包含**：
- ERP、MES、SRM、CRM、WMS等现有系统的改造升级
- 不包含这些系统的功能扩展或架构调整
- 不包含这些系统的数据迁移（仅包含必要的质量数据同步）

**生产设备不包含**：
- 生产设备的自动化改造和升级
- 设备的传感器或监控硬件采购
- 设备的软件系统或控制系统开发

**第三方服务不包含**：
- 第三方认证机构（如TÜV、SGS等）的审核服务
- 第三方咨询公司或顾问服务
- 第三方技术支持或外包开发服务

**硬件采购不包含**：
- 服务器、网络设备、存储设备等硬件采购
- 数据中心基础设施或机房建设
- 网络带宽或云服务费用

### 2.2 限制条件

**技术限制**：
- 必须兼容现有IT架构和技术栈
- 必须支持现有数据库和中间件
- 必须满足网络安全和数据安全要求
- 必须支持现有办公环境和设备

**业务限制**：
- 必须在不影响正常生产的情况下实施
- 必须保证现有业务的连续性
- 必须分阶段实施，逐步替换现有流程
- 必须保证数据和信息的保密性和完整性

**时间限制**：
- 项目总工期控制在10个月内
- 各阶段里程碑必须按时完成
- 关键功能必须在指定时间内交付使用
- 用户培训和系统上线必须在预定时间内完成

**预算限制**：
- 项目总预算控制在405-575万元范围内
- 各项费用必须按预算执行
- 需要预算外支出必须经过审批
- 成本偏差不能超过±5%

**合规限制**：
- 必须满足IATF16949:2016标准的所有要求
- 必须符合汽车行业质量管理的最佳实践
- 必须满足数据安全和个人信息保护法规
- 必须支持客户特定要求（CSR）的管理

### 2.3 假设条件

**数据和系统假设**：
- 客户方提供完整的现有系统文档和接口说明
- 客户方提供必要的数据访问权限和测试环境
- 客户方配合进行必要的流程梳理和优化建议
- 客户方提供必要的硬件和网络基础设施

**资源和人员假设**：
- 客户方指派关键用户参与需求调研和测试
- 客户方提供必要的业务培训和知识传递
- 客户方IT部门提供系统部署和运维支持
- 客户方管理层提供必要的决策和资源支持

**技术和环境假设**：
- 现有系统支持标准API接口和数据同步
- 数据中心满足系统部署的硬件和网络要求
- 网络环境支持多用户并发访问和移动办公
- 安全环境满足系统部署的安全和数据保护要求

**业务和环境假设**：
- 项目实施期间业务正常运营，无重大业务中断
- 项目实施后用户接受度和使用新系统
- 有足够的时间进行用户培训和系统磨合
- 组织文化支持数字化质量管理的变革

---

## 三、验收标准

### 3.1 项目范围验收

**功能完整性验收**：
- [ ] 25个核心功能模块全部开发完成并可用
- [ ] 所有功能模块间的集成和数据流转正常
- [ ] 移动端应用功能正常并支持主要功能
- [ ] 系统大屏和可视化功能正常显示

**系统集成验收**：
- [ ] 与ERP系统的5个核心接口开发完成并测试通过
- [ ] 与MES系统的5个核心接口开发完成并测试通过
- [ ] 与SRM、CRM、WMS系统的接口开发完成并测试通过
- [ ] 系统间的数据同步和一致性验证通过

**业务流程验收**：
- [ ] 从原材料到成品出厂的质量流程端到端验证通过
- [ ] 多材料、多领域的质量管理流程验证通过
- [ ] 供应商管理、检验体系、客户反馈等核心流程验证通过
- [ ] 跨系统的业务流程协同和数据共享验证通过

### 3.2 项目边界验收

**不包含范围确认**：
- [ ] 现有系统（ERP、MES等）的改造范围明确界定
- [ ] 生产设备自动化改造的范围明确排除
- [ ] 第三方审核服务的范围明确排除
- [ ] 硬件采购的范围明确排除

**限制条件验收**：
- [ ] IT架构兼容性验证通过
- [ ] IATF16949合规性验证通过
- [ ] 数据安全和合规性验证通过
- [ ] 时间限制和预算限制的合理性验证通过

**假设条件验收**：
- [ ] 客户提供的文档和资源清单确认
- [ ] 客户支持和配合机制的建立
- [ ] 技术和环境的可行性验证通过
- [ ] 风险和应急预案的制定

---

## 四、风险提示与建议

### 4.1 项目范围风险

**范围蔓延风险**：
- **风险描述**：需求不断增加导致项目范围不断扩大
- **影响程度**：高 - 可能导致项目延期和预算超支
- **应对建议**：
  - 建立严格的变更控制流程
  - 明确需求冻结机制
  - 对变更需求进行充分评估和审批
  - 设置合理的需求优先级

**需求理解偏差风险**：
- **风险描述**：对客户需求的误解导致开发方向错误
- **影响程度**：高 - 可能导致大量返工和资源浪费
- **应对建议**：
  - 加强需求调研和用户访谈
  - 使用原型和迭代方式确认需求
  - 建立需求文档的正式评审和确认机制
  - 设置需求变更的沟通和确认流程

### 4.2 技术实现风险

**系统集成复杂性风险**：
- **风险描述**：与5个现有系统集成，接口和兼容性挑战大
- **影响程度**：高 - 可能导致集成周期延长和问题
- **应对建议**：
  - 尽早启动集成技术调研和接口设计
  - 与各系统供应商建立技术沟通机制
  - 分步骤、分系统集成，降低复杂度
  - 建立集成的测试和验证机制

**新技术架构风险**：
- **风险描述**：采用微服务架构，团队可能缺乏经验
- **影响程度**：中 - 可能导致架构设计和实现问题
- **应对建议**：
  - 提前进行技术预研和原型验证
  - 聘请经验丰富的架构师参与设计
  - 建立技术评审和专家咨询机制
  - 提供充足的技术培训和学习时间

### 4.3 项目实施风险

**用户接受度风险**：
- **风险描述**：用户对新系统的接受度和使用意愿不确定
- **影响程度**：中 - 可能导致系统上线后使用率低
- **应对建议**：
  - 建立有效的变革管理和用户参与机制
  - 提供充分的用户培训和支持
  - 设置激励措施鼓励早期使用和反馈
  - 建立用户支持和问题快速响应机制

**资源调配风险**：
- **风险描述**：项目周期长，人员流动和资源调配风险高
- **影响程度**：中 - 可能导致关键岗位空缺和进度延误
- **应对建议**：
  - 建立人员备份和知识传递机制
  - 与供应商签订明确的服务水平协议（SLA）
  - 建立关键人员的激励机制
  - 设置合理的资源缓冲和应急预案

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 整合状态：完整整合三个现有文档
- 文档类型：项目范围与边界定义分册
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,Gn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册4：系统架构与技术方案**

---

## 一、总体架构设计

### 1.1 系统分层架构

QMS系统采用分层架构设计，确保系统的可扩展性、可维护性和高可用性。

**表示层（Presentation Layer）**
- Web管理控制台：支持PC端访问，提供完整的管理功能
- 质量数据大屏：实时展示质量KPI、趋势分析、异常预警
- 移动端应用：支持iOS/Android/小程序，支持现场办公
- 客户门户：支持客户查看质量数据、提交反馈、追踪处理进度

**应用层（Application Layer）**
- 核心业务引擎：APQP/PPAP、FMEA、SPC、MSA等核心业务逻辑
- 业务功能模块：变化点管理、CAPA、围堵单、QRQC等25个功能模块
- 工作流引擎：支持复杂业务流程的配置和执行
- 权限管理引擎：基于角色的访问控制和权限管理

**集成层（Integration Layer）**
- API网关：统一对外接口，支持多种协议和认证
- 服务发现：Nacos服务注册发现，支持动态服务路由
- 消息中间件：RabbitMQ异步消息队列，支持事件驱动
- 数据同步：支持与现有系统的双向数据同步

**数据层（Data Layer）**
- 关系数据库：PostgreSQL存储核心业务数据和用户权限数据
- 时序数据库：InfluxDB存储SPC过程数据和性能监控数据
- 文档数据库：MongoDB存储质量文档、知识库、附件等非结构化数据
- 缓存层：Redis集群提供高性能缓存和分布式锁

### 1.2 微服务架构设计

采用Spring Cloud微服务架构，将系统拆分为多个独立的服务，实现解耦和独立部署。

**服务拆分原则**：
- 按业务领域拆分：质量管理、供应商管理、客户管理等
- 按技术能力拆分：数据分析、报表服务、文件服务等
- 按数据类型拆分：结构化数据、时序数据、文档数据

**服务注册与发现**：
- 使用Nacos作为服务注册中心
- 支持服务自动注册和健康检查
- 支持服务元数据管理和查询
- 支持多环境隔离（开发、测试、生产）

**服务治理**：
- 使用Sentinel进行限流和熔断
- 支持多维度限流策略（QPS、并发、线程等）
- 支持服务降级和熔断策略
- 支持实时监控和告警

**配置管理**：
- 使用Nacos配置中心
- 支持配置的动态刷新和热更新
- 支持多环境配置管理
- 支持配置版本控制和回滚

---

## 二、技术架构选型

### 2.1 后端技术选型

**开发框架选型**：
- Spring Boot 3.x：轻量级快速开发框架
- Spring Cloud 2022.x：微服务开发套件
- Spring Security：安全认证和授权框架
- MyBatis Plus：持久层框架

**数据库选型对比**：

| 数据库 | 用途 | 优势 | 劣势 | 选型理由 |
|--------|------|------|------|----------|
| PostgreSQL | 关系数据 | ACID特性、JSON支持、丰富数据类型 | 占用资源较多 | 核心业务数据存储 |
| InfluxDB | 时序数据 | 高性能时序读写、数据压缩 | 学习曲线较陡 | SPC过程数据和监控数据 |
| MongoDB | 文档数据 | 灵活文档结构、全文搜索 | 强一致性要求低 | 质量文档和知识库 |

**中间件选型**：
- Redis 7.x集群：分布式缓存，支持主从哨兵
- RabbitMQ 3.12：消息队列，支持集群和高可用
- Elasticsearch 8.x：全文搜索引擎，支持分布式部署

### 2.2 前端技术选型

**技术栈对比分析**：

| 技术 | 用途 | 选型理由 |
|------|------|----------|
| Vue.js 3.x | Web前端框架 | 生态成熟、性能优秀、组件丰富 |
| Element Plus | UI组件库 | 丰富的企业级组件、开箱即用 |
| ECharts 5.x | 数据可视化 | 图表类型丰富、性能优异 |
| DataV | 大屏可视化 | 支持复杂大屏、效果炫酷 |
| Uni-app | 移动端框架 | 一套代码多端发布、生态丰富 |

### 2.3 部署架构选型

**容器化技术选型**：
- Docker：应用容器化，标准化部署环境
- Kubernetes：容器编排，支持自动扩缩容
- Harbor：私有镜像仓库，镜像安全管理

**云原生技术选型**：
- 支持私有云部署：企业数据中心
- 支持公有云部署：阿里云、腾讯云、华为云
- 支持混合云部署：核心系统私有云+ 扩展功能公有云

**服务网格选型**：
- Istio：服务网格，支持流量管理和安全
- 支持服务间通信的监控和追踪
- 支持金丝发布和回滚

---

## 三、部署架构规划

### 3.1 网络架构设计

**网络拓扑**：
\`\`\`
                        ┌──────────────────┐
                        │   防火墙集群   │
                        └──────────────────┘
                                │
                                ▼
        ┌────────────────────────────────────┐
        │         负载均衡器              │
        │  (Nginx + Keepalived)           │
        └────────────────────────────────────┘
                                │
                ┌───────────────────┴───────────────────┐
                │         应用服务器集群1         │                 │
                │  (3节点)                │                 │
                └─────────────────────────────────┘                 │
                                │                        ┌─────────────────────────────────┐
                ┌────────────────────────────────────┐           │                 │
                │         应用服务器集群2         │           │                 │
                │  (3节点)                │           │                 │
                └─────────────────────────────────┘           │                 │
                                │                        ┌─────────────────────────────────┐
                ┌────────────────────────────────────┐           │                 │
                │         数据服务层              │           │                 │
                │  ┌─────────┐ ┌─────────┐ ┌─────────┐           │                 │
                │  │PostgreSQL│ │ InfluxDB  │ │ MongoDB │           │                 │
                │  │  (主从)  │ │ (集群)  │ │ (副本集)│           │                 │
                │  └─────────┘ └─────────┘ └─────────┘           │                 │
                └────────────────────────────────────────────┘           │                 │
                                │                        ┌─────────────────────────────────┐
                ┌────────────────────────────────────┐           │                 │
                │         备份服务器             │           │                 │
                │  ┌─────────┐ ┌─────────┐           │                 │
                │  │ 主备份  │ │ 异地备份 │           │                 │
                │  └─────────┘ └─────────┘           │                 │
                └────────────────────────────────────┘           │                 │
                                │                        ┌─────────────────────────────────┐
                ┌────────────────────────────────────┐           │                 │
                │         监控服务器             │           │                 │
                │  (Prometheus + Grafana)           │                 │
                │  └─────────────────────────────┘           │                 │
                └────────────────────────────────────┘           │
\`\`\`

**网络设计要点**：
- 防火墙集群支持双机热备和自动切换
- 负载均衡器支持4-7层负载均衡和健康检查
- 应用服务器采用K8s集群，支持自动扩缩容
- 数据库采用主从和集群架构，确保高可用
- 备份服务器支持本地和异地双重备份

### 3.2 高可用设计

**同城双活设计**：
- 两个数据中心部署：主数据中心和备数据中心
- 实时数据同步：基于应用层的双向数据同步
- 流量分发策略：基于地理位置和负载情况
- 自动故障切换：故障时自动切换到备中心

**异地灾备设计**：
- 异地灾备中心：不同城市的灾备中心
- 异地数据备份：定时将关键数据备份到异地
- 灾备演练：定期进行灾备切换演练
- RPO规划：制定详细的恢复点和恢复计划

**恢复时间目标**：
- RTO（恢复时间目标）≤4小时
- RPO（恢复点目标）≤2小时
- 数据丢失≤5分钟
- 核心业务恢复优先级明确

### 3.3 监控体系设计

**监控层级**：
\`\`\`
┌─────────────────────────────────────────────────────┐
│                   监控体系                              │
├─────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────┐   │
│  │                基础设施监控                    │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │服务器监控│ │网络监控 │ │ 存储监控 │   │   │
│  │  │CPU/内存│ │带宽/延迟│ │ 容量/IOPS │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────┘   │
│                              ↓                           │
│  ┌─────────────────────────────────────────────┐   │
│  │                应用性能监控                    │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │响应时间 │ │吞吐量  │ │错误率   │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────┘   │
│                              ↓                           │
│  ┌─────────────────────────────────────────────┐   │
│  │                业务监控                          │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │功能使用 │ │数据质量 │ │用户活跃 │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────┘   │
│                              ↓                           │
│  ┌─────────────────────────────────────────────┐   │
│  │                安全监控                          │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │访问控制 │ │漏洞扫描 │ │入侵检测 │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
\`\`\`

---

## 四、安全架构设计

### 4.1 认证与授权架构

**认证方式**：
- 用户名密码认证：支持LDAP集成和本地认证
- 手机验证码认证：支持短信和邮件验证码
- 第三方登录：支持微信、钉钉等企业应用
- 双因素认证：支持手机令牌和硬件令牌

**授权模型**：
- RBAC（基于角色的访问控制）：5级角色体系
- ABAC（基于属性的访问控制）：支持细粒度权限控制
- 数据权限：支持行级和字段级权限控制
- 资源权限：支持菜单、按钮、API接口权限

### 4.2 数据安全设计

**数据加密**：
- 传输加密：全链路SSL/TLS加密
- 存储加密：敏感数据AES-256加密
- 密钥管理：专业的密钥管理和轮换机制

**数据脱敏**：
- 敏感字段自动识别和脱敏
- 支持姓名、电话、身份证等脱敏规则
- 支持日志和报表中的数据脱敏

**访问控制**：
- IP白名单：限制特定IP访问
- 时间窗口：限制特定时间段访问
- 地理围栏：限制特定地区访问
- 操作审计：记录所有敏感操作

### 4.3 审计追踪设计

**审计范围**：
- 登录审计：记录所有登录行为
- 操作审计：记录所有业务操作
- 数据审计：记录数据访问和修改
- 系统审计：记录系统配置和变更

**审计分析**：
- 异常行为识别：异常时间、异常地点、异常操作
- 风险行为预警：大量数据导出、频繁失败登录
- 合规性检查：操作是否符合规范和权限
- 审计报告：自动生成多维度审计报告

---

## 五、性能优化设计

### 5.1 缓存策略

**多级缓存架构**：
\`\`\`
┌─────────────────────────────────────────────────────┐
│                   缓存体系                              │
├─────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────┐   │
│  │                L1缓存（本地缓存）                  │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │浏览器  │ │CDN加速 │ │内存缓存 │   │   │
│  │  │缓存    │ │         │ │(本地)  │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────┘   │
│                              ↓                           │
│  ┌─────────────────────────────────────────────┐   │
│  │                L2缓存（分布式缓存）              │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │Redis集群│ │Memcached│ │缓存策略 │   │   │
│  │  │(主从)  │ │         │ │(热点数据)│   │   │
│  │  └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
\`\`\`

**缓存策略**：
- 热点数据：本地缓存+CDN加速
- 数据库查询：Redis缓存减少数据库压力
- 接口响应：多级缓存提升响应速度
- 缓存失效：基于时间的缓存失效策略

### 5.2 数据库优化

**读写分离**：
- 主库：负责写操作，数据实时性
- 从库：负责读操作，分担主库压力
- 数据同步：主从库实时数据同步
- 故障切换：主库故障时从库升级为主库

**分库分表**：
- 按业务域分库：质量管理、供应商管理、客户管理
- 按数据类型分表：结构化数据、时序数据、文档数据
- 按访问频率分表：热数据、温数据、冷数据
- 按数据量分表：大表拆分，提升查询性能

**索引优化**：
- 复合索引：支持多字段组合查询
- 覆盖索引：确保最常用查询都有索引
- 索引维护：定期分析和优化索引使用
- 慢查询分析：识别和优化慢查询

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 文档类型：系统架构与技术方案分册
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,Hn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册5：核心功能模块设计（第1-11章）**

---

## 1. 变化点管理模块

### 1.1 功能概述

变化点管理是IATF16949的核心要求，用于识别、评估和控制生产过程中的任何变化，防止质量问题的发生。

### 1.2 变化点类型分类

**4M1E变化点分类体系：**

**Man（人）变化点：**
- 新员工上岗
- 岗位调整
- 班次变更
- 新员工培训

**Machine（机）变化点：**
- 新设备引入
- 设备改造
- 模具更换
- 设备维护后

**Method（法）变化点：**
- 新工艺引入
- 工艺参数调整
- 新工艺流程
- 流程优化

**Material（料）变化点：**
- 新材料使用
- 材料规格变更
- 材料供应商变更
- 材料批次切换

**Environment（环）变化点：**
- 温湿度变化
- 生产环境改造
- 生产线搬迁
- 环境条件变化

**Measure（测）变化点：**
- 新检具引入
- 检具更换
- 测量方法变更
- 测量标准更新

**Other（其他）变化点：**
- 客户要求变更
- 法规要求变更
- 紧急插单
- 临时工艺调整

### 1.3 变化点管理流程

**变化点申请阶段：**
- 在线变化点申请表单
- 自动关联产品和工艺信息
- 变化点类型智能推荐
- 历史变化点查询和复用
- 附件上传（图纸、规格说明等）

**风险评估阶段：**
- 风险矩阵评估工具
- FMEA集成分析
- 专家评审流程
- 风险等级自动计算（低/中/高）

**审批决策阶段：**
- 多级审批流程配置
- 电子签名支持
- 审批时效监控和催办
- 移动端审批支持
- 审批历史追溯

**实施准备阶段：**
- 实施计划制定
- 实施任务分配
- 实施资源准备
- 实施检查清单管理
- 相关人员通知和培训

**试生产验证阶段：**
- 首件检验（FAI）
- 试生产数量和批次管理
- 质量数据采集和分析
- 客户确认（如需要）
- 验证报告生成

**正式生产阶段：**
- 正式生产通知
- 过程参数监控
- 质量数据实时采集
- 异常预警和触发
- 生产数量和批次追踪

**效果确认阶段：**
- 实施效果数据收集
- 质量指标对比分析
- 效果评估报告生成
- 经验总结和知识沉淀

**标准更新阶段：**
- 作业指导书更新
- 工艺参数更新
- 检验标准更新
- 控制计划更新
- FMEA和控制计划联动

**经验总结阶段：**
- 经验教训整理和分类
- 最佳实践提炼和推广
- 案例库建设
- 知识库同步
- 预防措施更新

### 1.4 核心功能设计

**变化点看板：**
- 待处理变化点列表
- 风险评估矩阵展示
- 审批流程可视化
- 实施进度甘特图
- 效果对比分析

**智能推荐：**
- 基于历史数据的风险等级推荐
- 基于产品特性的变化点类型推荐
- 基于类似案例的实施建议推荐
- 基于专家经验的风险应对措施推荐

**预警机制：**
- 高风险变化点红色预警
- 审批超时橙色预警
- 实施延期黄色预警
- 质量数据异常蓝色预警
- 多通道通知（邮件、短信、APP推送）

---

## 2. 纠正预防措施CAPA模块

### 2.1 功能概述

CAPA（Corrective and Preventive Action）是质量管理的核心机制，用于系统性解决质量问题并预防再次发生，满足IATF16949第10.2条款要求。

### 2.2 CAPA全生命周期管理

**问题管理阶段：**

| 问题来源 | 问题类型 | 严重度 | 优先级 | 响应时效 |
|----------|----------|--------|--------|------------|
| 内部检验 | 质量不符合 | S级 | P0 | 4小时 |
| 过程异常 | 流程问题 | A级 | P1 | 2小时 |
| 客户投诉 | 产品缺陷 | S级 | P0 | 立即 |
| 供应商问题 | 材料问题 | A级 | P1 | 8小时 |
| 审核发现 | 体系缺陷 | B级 | P2 | 24小时 |

**根因分析阶段：**

| 分析方法 | 适用场景 | 复杂度 | 准确性 | 工具支持 |
|----------|----------|--------|--------|----------|
| 5Why分析法 | 简单问题 | 低 | 中 | 内置 |
| 鱼骨图分析 | 复杂问题 | 中 | 中 | 内置 |
| 故障树分析(FTA) | 技术问题 | 高 | 高 | 内置 |
| 帕累托图 | 数据分析 | 中 | 中 | 内置 |
| 散点图分析 | 多因素分析 | 中 | 中 | 内置 |
| DOE实验设计 | 参数优化 | 高 | 高 | 外接 |

**措施管理阶段：**

| 措施类型 | 目的 | 实施难度 | 效果验证期 | 成本估算 |
|----------|------|------------|------------|----------|
| 纠正措施 | 消除当前问题 | 低 | 立即 | 低 |
| 预防措施 | 防止再发生 | 中 | 1-2周 | 中 |
| 系统措施 | 改进体系流程 | 高 | 1-3个月 | 高 |
| 临时措施 | 控制问题影响 | 低 | 立即 | 低 |

**效果验证阶段：**

| 验证方法 | 验证内容 | 验证周期 | 责任人 | 验收标准 |
|----------|----------|----------|----------|----------|
| 数据验证 | 问题消除验证 | 每周 | 质量经理 | 无同类问题发生 |
| 过程验证 | 流程执行验证 | 每月 | 部门经理 | 流程执行率≥95% |
| 用户验证 | 用户满意度验证 | 每季度 | 业务分析师 | 满意度≥90% |
| 效益验证 | 成本效益分析 | 每季度 | 财务经理 | 投资回报率≥3倍 |

### 2.3 核心功能设计

**问题登记功能：**
- 多渠道问题采集（检验、客诉、审核、自检）
- 问题描述标准化和分类模板
- 问题描述中的多媒体附件支持
- 问题自动编号和分类
- 问题与产品、工艺、人员的关联

**根因分析工具箱：**
- 5Why分析工具（最多5层深度）
- 鱼骨图分析工具（支持多人协作编辑）
- 故障树分析工具（支持多层级展开）
- 散点图分析工具（支持多维度分析）
- DOE实验设计工具（正交实验设计）

**措施制定功能：**
- 措施建议库（基于历史问题和根因分析）
- 措施模板管理（临时措施、纠正措施、预防措施）
- 措施成本估算工具
- 措施时间估算工具
- 措施责任人分配

**任务跟踪功能：**
- 任务分解和分配（WBS结构）
- 任务优先级管理
- 任务进度跟踪和可视化
- 任务逾期预警和升级机制
- 任务完成情况统计和分析

**效果评估功能：**
- 问题消除率统计
- 措施执行率统计
- 措施有效性评估（1-5分制）
- 成本效益分析（避免损失vs措施成本）
- 预防措施成功率统计

---

## 3. 围堵单管理模块

### 3.1 功能概述

围堵单用于在发现质量问题时快速隔离可疑产品，防止问题扩大化，满足IATF16949对质量事件管理的要求。

### 3.2 围堵单类型

**围堵场景分类：**

| 围堵类型 | 触发条件 | 围堵范围 | 处理时效 | 处理方式 |
|----------|----------|----------|----------|----------|
| 生产围堵 | 生产过程发现质量异常 | 涉及批次/设备 | 2小时内 | 100%检验 |
| 来料围堵 | IQC检验发现不合格 | 涉及供应商批次 | 4小时内 | 供应商确认 |
| 客诉围堵 | 客户反馈质量问题 | 涉及已发货产品 | 立即 | 客户确认 |
| 审核围堵 | 审核发现严重问题 | 涉及相关产品 | 8小时内 | 全部冻结 |
| 流程围堵 | 内部审核发现风险 | 涉及相关流程 | 24小时内 | 流程暂停 |

### 3.3 围堵单管理流程

**围堵申请阶段：**
- 围堵申请表单（在线、移动端）
- 问题描述和证据上传
- 围堵范围智能推荐（基于产品和批次信息）
- 围堵级别自动判定（红/橙/黄）
- 紧急围堵申请（手机一键触达）

**围堵审批阶段：**
- 分级审批机制（质量问题级别=审批级别）
- 快速审批通道（紧急围堵15分钟内审批）
- 多部门协同审批（质量、生产、供应链）
- 审批意见在线协作和记录
- 电子签名确认

**围堵执行阶段：**
- 围堵产品自动标识和隔离
- 围堵区域物理隔离标识
- 围堵产品信息记录（批次、数量、位置）
- 围堵执行过程追踪
- 围堵结果通知相关部门

**围堵验证阶段：**
- 围堵产品100%检验要求
- 检验结果自动记录和上传
- 不合格品自动转入报废流程
- 合格品自动解除围堵
- 围堵效果评估和报告

**围堵解除阶段：**
- 解围堵申请和审批
- 解围堵条件确认（检验合格+审批通过）
- 解围堵结果通知和记录
- 围堵过程追溯和审计

### 3.4 核心功能设计

**围堵管理看板：**
- 活跃围堵单看板（待审批/执行中/验证中/已完成）
- 围堵统计和分析（按类型、部门、产品）
- 围堵效率分析（平均处理时间、成功率）
- 围堵成本分析（检验成本、报废成本）

**智能围堵建议：**
- 基于产品风险的围堵范围推荐
- 基于历史数据的类似问题处理方式推荐
- 基于供应链影响的最优处理方案推荐
- 围堵效果预测模型

**围堵追溯体系：**
- 完整的围堵单号编码规则
- 围堵单的全生命周期追溯
- 围堵相关的质量问题关联
- 围堵教训库建设和检索

---

## 4. QRQC快速反应模块

### 4.1 功能概述

QRQC（Quick Response Quality Control）是现场质量问题的快速响应机制，要求在24小时内响应和解决质量问题，支持汽车行业对快速响应的要求。

### 4.2 QRQC响应流程

\`\`\`
┌─────────────────────────────────────────────────────┐
│                   QRQC 24小时响应流程                    │
├─────────────────────────────────────────────────────┤
│                                                             │
│  问题发现 → 快速响应 → 现场分析 → 临时措施 → 根本解决 │
│      ↓           ↓           ↓           ↓           ↓     │
│  现场报警 → 15分钟响应 → 2小时分析 → 4小时措施 → 24小时解决 │
│      ↓           ↓           ↓           ↓           ↓     │
│  团队组建 → 现场调查 → 数据收集 → 方案制定 → 效果验证 │
│      ↓           ↓           ↓           ↓           ↓     │
│  团队协调 → 跨部门协作 → 专家咨询 → 决策制定 → 执行跟踪 │
└─────────────────────────────────────────────────────┘
\`\`\`

### 4.3 响应时效要求

| 问题级别 | 响应时间 | 分析时间 | 措施制定 | 效果验证 | 总时效 |
|----------|----------|----------|----------|----------|----------|
| S级（紧急） | 15分钟 | 2小时 | 4小时 | 24小时内 | ≤24小时 |
| A级（严重） | 30分钟 | 4小时 | 8小时 | 48小时内 | ≤48小时 |
| B级（一般） | 1小时 | 8小时 | 16小时 | 5天内 | ≤5天 |
| C级（轻微） | 2小时 | 24小时 | 48小时 | 10天内 | ≤10天 |

### 4.4 核心功能设计

**QRQC报警功能：**
- 现场一键报警（手机APP）
- 报警级别自动判定（基于问题类型和影响）
- 报警推送多通道（电话、短信、邮件、APP）
- 报警接收确认和升级机制
- 报警历史记录和统计分析

**QRQC团队管理：**
- QRQC团队自动组建（基于问题类型和部门）
- 专家库管理（内部专家、外部顾问）
- 团队沟通和协作平台
- 团队任务分配和跟踪
- 团队绩效评估

**现场调查工具：**
- 现场数据快速采集工具（移动端）
- 现场照片和视频上传
- 现场检验记录生成
- 数据和证据关联管理
- 现场调查报告模板

**临时措施管理：**
- 围堵方案快速制定
- 围堵任务分配和执行跟踪
- 围堵效果实时监控
- 围堵成本快速核算
- 围堵范围实时更新

**根本解决方案跟踪：**
- 长期解决方案跟踪和管理
- 解决方案实施进度监控
- 解决效果验证和评估
- 解决成本和效益分析
- 经验总结和知识沉淀

---

## 5. 报废功能模块

### 5.1 功能概述

报废功能用于管理不合格产品的报废流程，确保报废过程的合规性、可追溯性和成本准确性，满足IATF16949对不合格品控制的要求。

### 5.2 报废类型管理

**报废原因分类：**

| 报废原因分类 | 具体原因 | 占比目标 | 预防措施 |
|--------------|----------|----------|----------|
| 材料质量问题 | 成分超标、材质不符 | ≤20% | 加强材料检验 |
| 工艺问题 | 尺寸超差、外观缺陷 | ≤30% | 优化工艺参数 |
| 模具问题 | 模具磨损、设计缺陷 | ≤15% | 加强模具维护 |
| 设备问题 | 设备故障、精度不足 | ≤10% | 设备预防维护 |
| 设计问题 | 设计不合理、无法生产 | ≤10% | 优化设计流程 |
| 其他原因 | 未知、综合原因 | ≤15% | 持续分析改进 |

### 5.3 报废管理流程

**报废申请阶段：**
- 不合格品报废申请表单
- 报废原因分类和详细描述
- 报废产品信息关联（批次、数量、检验结果）
- 报废成本自动计算（材料成本+加工成本）
- 附件上传（检验报告、照片等）

**报废审批阶段：**
- 分级审批机制（基于报废金额和数量）
- 多部门协同审批（质量、生产、财务）
- 审批意见在线协作和记录
- 审批历史追溯
- 电子签名确认

**报废执行阶段：**
- 报废产品隔离和标识
- 报废产品信息记录（位置、数量、标识号）
- 报废执行过程追踪
- 报废照片和视频记录（如需要）
- 报废库存扣减
- 报废成本核算

**报废确认阶段：**
- 报废执行结果确认（实际报废数量和成本）
- 财务成本确认（报废材料成本、处理成本）
- 报废报告生成和归档
- 报废库存账目更新

### 5.4 核心功能设计

**报废成本管理：**
- 报废成本自动计算（材料成本+加工成本+人工成本）
- 报废成本统计和分析（按产品、部门、时间）
- 报废预算控制（按部门、按产品线）
- 报废成本趋势分析
- 报废成本与质量改进投入对比分析

**报废追溯体系：**
- 完整的报废单号编码规则
- 报废单全生命周期追溯
- 报废与相关质量问题的关联
- 报废数据分析和统计

**报废报表功能：**
- 报废统计报表（按产品、部门、原因、时间）
- 报废成本分析报表
- 报废率分析和趋势图
- 报废原因帕累托图
- 报废成本效益分析报表

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 文档类型：核心功能模块设计分册（第1-5章）
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,qn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册6：客诉/客退及8D管理模块**

---

## 1. 客诉管理流程

### 1.1 投诉接收

**多渠道投诉接收**：
- 客户门户在线投诉提交
- 客服热线电话投诉记录
- 邮件投诉接收和自动分类
- 微信/钉钉等即时通讯工具集成
- 现场投诉（客户到厂投诉）登记

**投诉信息标准化**：
- 投诉编号自动生成（年度+流水号）
- 投诉类型分类（质量、交付、服务、其他）
- 投诉紧急程度自动判定（S/A/B/C四级）
- 投诉相关产品信息自动关联（产品代码、批次、订单）
- 投诉证据上传（照片、视频、检测报告）

### 1.2 投诉处理

**投诉处理流程图**：
\`\`\`
┌─────────────────────────────────────────────────────┐
│                   客诉处理流程                           │
├─────────────────────────────────────────────────────┤
│                                                             │
│  投诉接收 → 初步评估 → 团队组建 → 根因分析 → 解决措施制定 → 措施实施 → 效果验证 → 客户确认 → 关闭   │
│      ↓           ↓           ↓           ↓           ↓           ↓           ↓           ↓           ↓       │
│  登记   → 风险评估 → 跨部门协作 → 5Why分析 → 方案决策 → 任务分配 → 进度跟踪 → 满意调查 → 归档     │
│      ↓           ↓           ↓           ↓           ↓           ↓           ↓           ↓           ↓       │
│  通知   → 报警触发 → 资源调配 → 鱼骨图   → 分管领导 → 优先处理 → 时效监控 → 验收评审 → 经验总结    │
└─────────────────────────────────────────────────────┘
\`\`\`

**关键决策点**：
- 是否启动围堵措施（根据投诉严重度）
- 是否需要客户见证检验（重大质量问题）
- 是否需要供应商协同（涉及外购材料或零件）
- 是否升级到高层管理（重大质量危机）

### 1.3 客退管理

**退货流程管理**：
- 客退申请在线提交
- 退货原因分类（质量、非质量、包装、其他）
- 退货产品信息关联和追溯
- 退货数量和金额自动核算

**退货检验标准**：
- 100%全检或按比例抽样检验
- 检验标准自动调用（IQC检验标准）
- 检验结果记录和拍照存档
- 合格品重新入库，不合格品进入处置流程

**退货成本计算**：
- 运输费用自动计算（重量、距离）
- 检验费用核算
- 处理费用统计
- 退货成本趋势分析

---

## 2. 8D报告管理

### 2.1 8D报告流程

**AIAG 8D流程（8个步骤）**：
- D0: 团队组建
- D1: 问题描述
- D2: 临时围堵措施
- D3: 根本原因分析
- D4: 永久纠正和预防措施
- D5: 措施实施和验证
- D6: 效果确认和标准化
- D7: 管理层支持和经验教训

### 2.2 8D各步骤详解

**D0 - 团队组建**：
- 团队角色定义：项目经理、质量工程师、技术工程师、生产代表、供应链代表
- 团队职责明确和沟通机制
- 专家资源协调（内部专家、外部顾问）
- 团队培训和8D工具使用

**D1 - 问题描述**：
- 问题的准确和详细描述（5W2H）
- 问题影响范围评估（产品批次、生产周期、客户影响）
- 严重度评级（1-10级）
- 优先级设定
- 相关证据收集（照片、数据、记录）

**D2 - 临时围堵措施**：
- 围堵方案制定（立即措施）
- 可疑产品隔离和标识
- 存货产品检查和追溯
- 在产产品排查和处置
- 客户沟通和安抚
- 围堵效果评估

**D3 - 根本原因分析**：
- 根因分析方法选择（5Why、鱼骨图、FTA、DOE）
- 数据收集和分析
- 假设验证和排除
- 多角度分析（人、机、料、法、环）
- 根因确认和专家评审

**D4 - 永久纠正和预防措施**：
- 纠正措施（消除根本原因）
- 预防措施（防止再次发生）
- 措施责任人分配和时限
- 措施成本估算
- 实施进度跟踪和监控

**D5 - 措施实施和验证**：
- 实施计划和执行
- 实施效果数据收集
- 客户验证和反馈
- 措施效果评估
- 必要时调整方案
- 完成时间确认

**D6 - 效果确认和标准化**：
- 效果确认（客户满意度、问题是否解决）
- 流程和文件更新（作业指导书、控制计划、检验标准）
- 培训要求和实施
- 管理层承诺和资源配置
- 经验教训总结和分享
- 预防措施纳入日常工作

**D7 - 管理层支持和经验教训**：
- 管理层支持和资源保障
- 跨部门协调和协作
- 成本效益分析和汇报
- 经验教训记录到知识库
- 系统改进建议
- 客户关系维护

### 2.3 8D报告模板

**8D报告结构**：
\`\`\`
┌─────────────────────────────────────────────────────┐
│                   8D报告结构示例                     │
├─────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────┐       │
│  │              报告信息         │       │
│  │  • 报告编号                     │       │
│  │  • 客户信息                     │       │
│  │  • 产品信息                     │       │
│  │  • 投诉时间                     │       │
│  │  • 报告时间                     │       │
│  └─────────────────────────────────────┘       │
│                              ↓                           │
│  ┌─────────────────────────────────────┐       │
│  │           D0-D7详细内容         │       │
│  │  • D0: 团队组建               │       │
│  │  • D1: 问题描述               │       │
│  │  • D2: 临时措施               │       │
│  │  • D3: 根因分析               │       │
│  │  • D4: 永久措施               │       │
│  │  • D5: 实施验证               │       │
│  │  • D6: 效果确认               │       │
│  │  • D7: 管理支持               │       │
│  └─────────────────────────────────────┘       │
│                              ↓                           │
│  ┌─────────────────────────────────────┐       │
│  │              附录内容             │       │
│  │  • 证据材料                     │       │
│  │  • 数据分析图表                 │       │
│  │  • 流程和文件更新               │       │
│  │  • 成本效益分析                 │       │
│  └─────────────────────────────────────┘       │
└─────────────────────────────────────────────┘
\`\`\`

### 2.4 8D报告管理功能

**报告生成功能**：
- 自动化8D报告模板
- 在线协同编辑（支持多人同时编辑）
- 智能内容推荐（基于历史8D数据）
- 报告版本控制和审批
- 报告导出（Word、PDF、Excel）

**报告追踪功能**：
- 8D进度看板（7个步骤的完成状态）
- 超时预警（步骤超期自动提醒）
- 责任人工作量统计
- 8D效率分析（平均完成时间）

**客户交互功能**：
- 客户门户查看报告
- 报告推送通知（邮件、短信）
- 客户反馈收集和满意度调查
- 报告在线确认和签署

---

## 3. 客户满意度管理

### 3.1 满意度调查

**调查类型**：
- 季度满意度调查（每年1次）
- 项目满意度调查（每个大项目完成后）
- 月度满意度跟踪（每月随机抽样）
- 投诉处理满意度调查（每次投诉处理后）
- 长期客户满意度追踪（每季度）

**调查指标体系**：

| 维度 | 指标 | 权重 | 评分标准 |
|------|------|------|----------|
| 产品质量 | 5分 | 30% | 质量稳定、符合标准 |
| 交付及时 | 5分 | 25% | 按时或提前交付 |
| 服务质量 | 5分 | 20% | 响应及时、服务态度好 |
| 沟通效率 | 5分 | 15% | 沟通及时、问题处理快 |
| 技术支持 | 5分 | 10% | 技术问题解决及时 |

**评分等级**：
- 90-100分：优秀
- 80-89分：良好
- 70-79分：合格
- 60-69分：需改进
- <60分：不合格

### 3.2 客户沟通管理

**沟通渠道管理**：
- 定期客户回访机制（每季度至少1次）
- 客户经理专人负责制
- 客户沟通记录管理
- 客户会议安排和纪要管理
- 客户节日问候和关怀

**沟通内容管理**：
- 质量改进措施沟通
- 新产品和工艺介绍
- 客户需求调研和反馈
- 行业动态和市场信息分享
- 质量数据和KPI共享

**客户关系管理**：
- 客户档案管理（基本信息、联系信息、历史订单）
- 客户分级管理（A/B/C/D四级）
- 客户投诉历史记录
- 客户满意度和改进趋势
- 客户增值服务和支持

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 文档类型：核心功能模块设计（第6章）
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,zn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册7：IQC/IPQC/FQC/OQC检验体系模块**

---

## 1. IQC来料检验管理

### 1.1 功能概述

IQC（Incoming Quality Control）来料检验是质量管理的第一道关口，确保进入生产环节的原材料、外协件等符合质量要求。

### 1.2 IQC检验类型

| 检验类型 | 检验内容 | 检验标准 | 检验方式 | 抽样方案 |
|----------|----------|----------|----------|----------|
| 铝合金材料 | 成分、硬度、外观 | 国标/企标 | 光谱分析 | 按批次抽样 |
| 锌合金材料 | 成分、杂质、外观 | 国标/企标 | 化学分析 | 按重量抽样 |
| 镁合金材料 | 成分、外观、密度 | 国标/企标 | 直读测试 | 按重量抽样 |
| 外协件 | 尺寸、外观、性能 | 图纸/技术协议 | 三坐标测量 | 按批次检验 |
| 包装材料 | 规格、外观、标识 | 标准规范 | 外观检查 | 按批次检验 |

### 1.3 IQC检验流程

\`\`\`
┌─────────────────────────────────────────────────────┐
│                   IQC检验流程                              │
├─────────────────────────────────────────────────────┤
│                                                             │
│  到货通知 → 检验任务创建 → 检验执行 → 结果判定 │
│      ↓           ↓              ↓           ↓     │
│  供单确认 → 检验标准调用 → 检验计划 → 批次标识 │
│      ↓           ↓              ↓           ↓     │
│  检验执行 → 数据录入 → 合格入库 → 不合格处置 │
│      ↓           ↓              ↓           ↓     │
│  检验报告 → 供应商通知 → 成本核算 → 归档     │
└─────────────────────────────────────────────────────┘
\`\`\`

### 1.4 核心功能设计

**检验计划管理**
- IQC检验计划自动生成（基于供单和检验标准）
- 检验任务分配和进度跟踪
- 检验资源（人员、设备、工时）管理
- 检验优先级管理

**检验执行功能**
- 移动端检验任务接收和执行
- 检验标准在线查询和展示
- 检验数据自动采集（对接光谱仪等设备）
- 检验照片和证据上传
- 检验异常上报和处理

**结果判定功能**
- 自动判定（基于检验标准和数据）
- 人工审核和判定（复杂情况）
- 检验报告自动生成
- 批次标识和追溯管理

---

## 2. IPQC过程检验管理

### 2.1 功能概述

IPQC（In-Process Quality Control）过程检验是在生产过程中对产品质量进行监控和控制的重要手段。

### 2.2 检验点位设计

| 检验点位 | 检验内容 | 检验频率 | 检验方式 | 责任人 |
|----------|----------|----------|----------|--------|--------|
| 首件检验FAI | 关键尺寸、外观、性能 | 每班次首件 | 100%检验 | 班组长 |
| 巡序检验 | 尺寸、表面处理 | 每件巡检 | 抽样检验 | 质检员 |
| 关键工序 | 工艺参数、关键特性 | 每2小时 | 在线检测 | 工艺工程师 |
| 末件检验 | 外观、尺寸、重量 | 每班次末件 | 100%检验 | 班组长 |
| 异常工序 | 异常情况分析 | 按需检验 | 专项检验 | 质检员 |

### 2.3 IPQC检验流程

\`\`\`
┌─────────────────────────────────────────────────────┐
│                   IPQC检验流程                              │
├─────────────────────────────────────────────────────┤
│                                                             │
│  检验计划 → 检验任务分配 → 检验执行 → 数据录入 │
│      ↓           ↓              ↓           ↓     │
│  标准调用 → 任务接收 → 检验记录 → 结果判定 │
│      ↓           ↓              ↓           ↓     │
│  异常上报 → 异常处理 → 措施制定 → 效果跟踪 │
│      ↓           ↓           ↓           ↓     │
│  报表生成 → 工艺参数分析 → 质量统计 → 持续改进 │
└─────────────────────────────────────────────────────┘
\`\`\`

### 2.4 核心功能设计

**巡检管理功能**
- 巡检路线规划和任务管理
- 移动端巡检任务执行
- 巡检问题记录和拍照
- 巡检报告生成和分享
- 巡检闭环管理

**检验标准管理**
- 多产品线检验标准管理
- 分工序检验规范管理
- 检验模板和记录表管理
- 检验标准版本控制和追溯

**异常管理功能**
- 检验异常实时上报
- 异常等级自动判定（轻微/一般/严重）
- 异常处理流程触发
- 异常整改跟踪和验证

---

## 3. FQC最终检验管理

### 3.1 功能概述

FQC（Final Quality Control）最终检验是产品出厂前的最后一道质量关口，确保交付客户的产品完全符合要求。

### 3.2 检验类型和标准

| 检验类型 | 检验内容 | 检验标准 | 检验方式 | 放行条件 |
|----------|----------|----------|----------|----------|
| 外观检验 | 外观、颜色、标识、包装 | 外观标准 | 100%检查 | IPQC合格 |
| 尺寸检验 | 关键尺寸、形位公差 | 图纸要求 | 三坐标 | 尺寸合格 |
| 功能检验 | 功能测试、性能验证 | 技术协议 | 功能测试 | 功能合格 |
| 包装检验 | 包装方式、标识、数量 | 包装标准 | 外观检查 | 包装合格 |
| 文件检验 | 检验报告、合格证、标签 | 客户要求 | 文档审核 | 文件合格 |
| 性能检验 | 力学性能、化学性能 | 性能标准 | 实验室 | 性能合格 |
| OQC标准 | 以上四项全部合格 | 满足客户要求 | 全面检查 | OQC放行 |

### 3.3 FQC检验流程

\`\`\`
┌─────────────────────────────────────────────────────┐
│                   FQC检验流程                              │
├─────────────────────────────────────────────────────┤
│                                                             │
│  OQC任务创建 → 检验计划制定 → 检验任务分配 │
│      ↓           ↓              ↓           ↓     │
│  检验标准调用 → 检验方案准备 → 样品准备 │
│      ↓           ↓              ↓           ↓     │
│  综合检验 → 数据汇总 → 结果判定 → OQC报告 │
│      ↓           ↓              ↓           ↓     │
│  结果评审 → 问题处理 → 复验申请 → 放行确认 │
│      ↓           ↓           ↓           ↓     │
│  客户确认 → 包装发货 → 单据归档 → 质量追溯 │
└─────────────────────────────────────────────────────┘
\`\`\`

### 3.4 核心功能设计

**检验任务管理**
- OQC检验任务创建和分配
- 多任务并行管理和跟踪
- 检验进度甘特图展示
- 检验资源调度和优化

**综合判定功能**
- 多项检验结果综合判定
- 自动计算合格率
- 问题汇总和优先级排序
- 放行决策支持

**报告生成功能**
- OQC检验报告自动生成
- 多格式导出（Word、PDF、Excel）
- 客户门户查看和下载
- 报告版本控制和追溯

---

## 4. 不合格品评审与处置

### 4.1 MRB评审机制

**MRB委员会架构**：
- MRB主席：质量总监
- MRB成员：质量工程师、生产经理、技术工程师、财务代表、采购代表
- MRB秘书：质量助理，负责会议组织和记录
- MRB专家：内外部专家（按需邀请）

### 4.2 不合格品分级

| 不合格等级 | 严重度 | 处置时效 | 决策权限 | 典型产品示例 |
|-----------|--------|----------|------------|----------------|
| CR-重大不合格 | 严重 | 2小时内 | 质量总监 | 安全关键件 |
| MJ-主要不合格 | 严重 | 4小时内 | MRB主席 | 发动机、变速箱 |
| MN-次要不合格 | 中等 | 1个工作日 | MRB成员 | 底盘、内饰件 |
| Mi-一般不合格 | 轻微 | 2个工作日 | 质量工程师 | 一般结构件 |
| 检验问题 | 不影响 | 即时处理 | 质量工程师 | 辅助材料 |

### 4.3 处置方式管理

| 处置方式 | 适用场景 | 处理流程 | 审批权限 | 成本核算 |
|----------|----------|----------|------------|----------|
| 报废 | 无法修复的材料/产品 | 申请→评审→执行→确认 | 质量总监 | 完整成本核算 |
| 返工 | 可修复的产品/零件 | 申请→评审→执行→复验→放行 | MRB主席 | 工时+材料成本 |
| 让步接收 | 不符合规格但可使用 | 申请→评审→客户确认→降级使用 | MRB主席 | 差异报价 |
| 退货 | 不符合规格且客户要求退货 | 申请→评审→执行→退款→跟踪 | 销售总监 | 退款流程管理 |
| 特采 | 特殊客户要求 | 申请→评审→执行→跟踪 | 项目经理 | 特采流程管理 |

### 4.4 处置流程设计

\`\`\`
┌─────────────────────────────────────────────────────┐
│                   MRB评审和处置流程                      │
├─────────────────────────────────────────────────────┤
│                                                             │
│  不合格品发现 → MRB会议 → 处置决策 → 执行处置 │
│      ↓           ↓           ↓           ↓     │
│  不合格登记 → 成本估算 → 供应商通知 → 处置跟踪 │
│      ↓           ↓           ↓           ↓     │
│  报废执行   → 财务处理   → 库存扣减 → 文档归档 │
│  返工执行   → 复验执行   → 重新入库 → 成本更新 │
│      ↓           ↓           ↓           ↓     │
│  让步执行   → 客户确认   → 降级管理   → 销售更新 │
│      ↓           ↓           ↓           ↓     │
│  退货执行   → 退款处理   → 运输跟踪   → 文档归档 │
│      ↓           ↓           ↓           ↓     │
│  处置完成   → 效果评估 → 经验总结 → 流程优化 │
└─────────────────────────────────────────────────────┘
\`\`\`

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 分册编号：07（检验体系模块）
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,Yn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册8：MSA/SPC分析系统模块**

---

## 一、MSA测量系统分析

### 1.1 功能概述

MSA（Measurement System Analysis）确保测量系统的准确性和可靠性，为质量控制和数据分析提供可靠的数据基础。

### 1.2 量具管理

**量具台账管理**：
- 量具基本信息：名称、型号、规格、精度等级
- 量具分类管理：卡尺、量规、三坐标、粗糙度仪、硬度计等
- 量具状态管理：在用、维修中、校准、报废
- 量具位置追踪：实时掌握量具分布和可用性

**量具校准计划**：
- 自动校准计划生成：基于使用频率和历史稳定性
- 校准提醒功能：提前7天和3天双提醒
- 校准证书管理：校准报告上传、有效期监控
- 校准服务商管理：内校/外校供应商管理

**校准记录管理**：
- 校准数据记录：校准日期、机构、校准人、校准结果
- 偏差数据管理：校前偏移、校后偏移、合格/不合格
- 校准成本核算：外校费用、内校工时
- 校准效果跟踪：校准前后测量数据对比分析

### 1.3 MSA研究

**Gage R&R研究**：
- **研究类型**：
  - 计数型研究
  - 量具型研究
  - 嵌套研究（多个测量系统组合）
- **研究流程**：
  1. 研究计划制定（目的、范围、测量方法）
  2. 测量者选择和培训
  3. 测量数据收集（通常10个零件×3位测量者×3次测量）
  4. 数据统计分析（可重复性、再现性计算）
  5. 研究报告生成和评审

- **研究标准**：
  - %GRR（总波动）：≤30%为优秀，≤20%为良好
  - %EV（测量系统变异）：≤30%为优秀
  - ndc（分辨力）：测量值/过程变异≥6
  - NDC（测量系统能力）：≥5

- **分析图表**：
  - 变异分析图（极差图、均值图、范围图）
  - 测量系统对比图（测量者间对比）
  - 交互图（零件×测量者）

**偏倚分析**：
- 偏倚计算：测量平均值-参考值
- 偏倚检验：t-检验、显著性分析
- 偏倚原因分析：系统误差、操作误差
- 偏倚校正建议：培训建议、工装调整

**线性分析**：
- 线性度检验：R²≥0.95为合格
- 测量范围验证：覆盖整个测量范围
- 线性图表：散点图、回归分析图
- 线性度评价：优秀/良好/合格/不合格

**稳定性分析**：
- 时间序列分析：测量系统随时间的变化
- 控制图：测量系统控制图
- 稳定性指标：测量系统变异随时间的稳定性

**研究报告功能**：
- 研究报告模板标准化
- 在线协作编辑
- 研究结果和建议总结
- 研究报告电子审批和归档

---

## 二、SPC统计过程控制

### 2.1 功能概述

SPC（Statistical Process Control）通过统计方法对过程进行监控和控制，是质量改进的核心工具。

### 2.2 控制图类型

**计量型控制图**：
- Xbar-R图（均值-极差控制图）
- Xbar-s图（均值-标准差控制图）
- I-MR图（单值-移动极差控制图）
- Xbar-s图（中位数-标准差控制图）

**计数型控制图**：
- p图（不合格品率控制图）
- np图（不合格品数控制图）
- c图（缺陷数控制图）
- u图（单位缺陷数控制图）

**特种控制图**：
- CUSUM控制图（累积和监控控制）
- EWMA控制图（指数加权移动平均）
- 短期能力指数（Cmk、Cpk）

### 2.3 SPC功能模块

**控制图管理**：
- 控制图配置：选择类型、计算参数、控制限设置
- 控制限计算：UCL（上控制限）、LCL（下控制限）
- 控制图绘制：实时数据绘制、颜色编码区域
- 控制图分析：趋势分析、周期识别、异常检测

**过程能力分析**：
- 能力指数计算：Cp、Cpk、Pp、Ppk、Cmk
- 能力评估：Cp≥1.33为优秀，≥1.0为合格
- 能力趋势分析：能力随时间的变化趋势
- 能力改善建议：基于分析结果提供改进建议

**数据采集接口**：
- 实时数据采集：支持手动录入、自动采集、设备对接
- 数据验证机制：数据范围检查、异常值过滤
- 数据预处理：数据清洗、缺失值处理、异常值处理
- 采样频率管理：固定频率、自适应频率、事件触发

**异常检测和报警**：
- 西方电气规则检测：点出控制限外的点
- 运行规则检测：连续7点在控制限同一侧
- 系统模式检测：9点模式识别
- 多维报警策略：控制限报警、趋势报警、系统模式报警

**过程分析报告**：
- 过程稳定性分析：过程受控状态评估
- 过程能力分析：过程能力提升情况
- 过程改进机会：基于分析的改进建议
- 过程预测分析：预测未来过程状态
- 异常原因分析：异常根本原因分析

---

## 三、抽样标准及调整规则模块

### 3.1 抽样标准管理

**多标准支持**：
- MIL-STD-105E（美军标准）
- ISO 2859-1（国际标准）
- GB/T 2828.1（国家标准）
- ANSI/ASQ（美国标准）
- 企业自定义标准

**标准要素管理**：
- AQL（可接收质量水平）等级：AQL-0.65、AQL-1.0、AQL-1.5、AQL-2.5、AQL-4.0
- 检验水平：一般检验水平I、II、III、特殊检验水平S-1、S-2、S-3、S-4
- 检验模式：一次检验、二次检验、多次检验、序贯检验
- 抽样类型：正常检验、加严检验、放宽检验、免检

**检验方案管理**：
- 一次抽样方案：样本量n、接收数Ac、拒收数Re
- 二次抽样方案：第一样本量n1、第二样本量n2
- 多次抽样方案：k次样本、累计样本量
- 转换规则：正常→加严→放宽→免检的转换条件
- 暂停规则：连续5批不合格，转为加严检验
- 恢复规则：连续5批合格，可恢复正常检验

### 3.2 放宽加严转换规则

**放宽条件**：
- 连续10批检验合格（正常检验下）
- 质量问题连续3个月未发现
- 过程能力稳定（Cpk≥1.33）
- 供应商评级为A级优秀
- 客户书面确认同意

**加严条件**：
- 连续5批中有2批不合格
- 重大质量问题发生
- 过程能力下降（Cpk<1.0）
- 新供应商或新工艺前3批
- 客户要求或风险增加

**免检条件**：
- 供应商A级认证且连续6个月无重大质量问题
- 质量过程能力指数≥1.33
- 客户质量评分≥90分
- 零缺陷率（PPM）≤100
- 首批通过加严检验验收合格

### 3.3 智能抽样管理

**抽样方案推荐**：
- 基于历史数据推荐最优抽样方案
- 基于质量等级推荐检验严格度
- 基于供应商评级推荐抽样频率
- 基于产品重要性推荐检验比例

**动态调整策略**：
- 基于质量趋势自动调整检验严格度
- 基于成本效益分析调整抽样比例
- 基于风险评估调整检验方案
- 调整前预警和确认

**抽样效果分析**：
- 抽样效率分析（检验成本vs缺陷检出率）
- 抽样代表性分析（抽样vs全检对比）
- 抽样成本效益分析
- 抽样方案优化建议

---

## 四、知识库/经验库模块

### 4.1 知识库管理

**知识分类体系**：
- 技术知识库：工艺知识、设备知识、材料知识、检验知识
- 管理知识库：质量管理、流程管理、项目管理
- 经验知识库：问题案例、最佳实践、教训总结
- 行业知识库：行业标准、法规要求、客户要求
- 培训知识库：培训材料、操作指南、FAQ

**知识创建功能**：
- 多格式支持：Word、PDF、PPT、视频、图片
- 在线编辑器支持：富文本编辑、公式编辑、图表插入
- 版本控制管理：知识版本追踪、版本对比
- 知识审核机制：专家评审、多级审批、质量检查

**知识检索功能**：
- 全文检索：支持关键词、全文、语义检索
- 智能推荐：基于搜索上下文推荐相关知识
- 标签分类：多维标签体系、智能标签推荐
- 搜索历史：记录搜索行为、优化搜索结果
- 相关知识推荐：推荐相关知识和案例

**知识分享功能**：
- 知识分享：一键分享到用户、部门、项目组
- 知识收藏：个人知识收藏和分类管理
- 知识评分：用户对知识的有用性评分
- 知识评论：用户评论和反馈
- 知识统计：使用频率、评分趋势

### 4.2 经验库管理

**案例分类体系**：
- 成功案例：质量改进、效率提升、成本降低
- 失败案例：问题分析、教训总结、改进建议
- 典型案例：标杆分析、最佳实践、创新案例
- 专项案例：PPAP成功、质量突破、数字化转型

**案例管理功能**：
- 案例模板标准化：背景、问题、解决方案、效果、启示
- 案例录入和编辑：标准化案例模板、富文本编辑
- 案例分类和标签：多维分类体系、智能标签
- 案例搜索和检索：全文检索、标签筛选、高级搜索
- 案例展示和分享：案例展示、案例分享、案例讨论

**案例应用功能**：
- 案例推荐：基于当前问题推荐相似案例
- 案例对比：多案例对比分析
- 案例学习：案例学习和知识提取
- 案例引用：在流程、培训、文档中引用案例
- 案例效果跟踪：案例应用效果反馈和评估

### 4.3 最佳实践库

**最佳实践分类**：
- IATF16949最佳实践：条款解读、实施指南、审核技巧
- 压铸行业最佳实践：材料管理、工艺控制、模具管理、设备管理
- 质量管理最佳实践：全面质量管理、持续改进、文化建设
- 数字化转型最佳实践：系统建设、数据驱动、智能分析

**最佳实践管理功能**：
- 实践模板管理：标准化的最佳实践模板
- 实践引用和关联：在流程、培训、审核中引用
- 实践效果跟踪：应用效果数据收集和分析
- 实践版本控制：最佳实践版本更新和追溯
- 实践评审和更新：专家评审、定期更新机制

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 分册编号：08（MSA/SPC/知识库）
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,Wn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册9：供应商质量管理模块**

---

## 一、供应商准入管理

### 1.1 供应商分类

| 供应商类型 | 准入标准 | 审核内容 | 审核周期 | 审核方式 |
|----------|----------|----------|----------|----------|
| 原材料供应商 | 资质证书、生产能力、质量体系 | SQ4评审+现场考察 | 1个月 | 现场+文件评审 |
| 外协件供应商 | 工艺能力、质量体系、交付能力 | 现场考察+样品验证 | 1个月 | 现场为主 |
| 服务供应商 | 服务能力、质量体系、价格水平 | 问卷调查+客户评价 | 2周 | 问卷为主 |
| 模具供应商 | 设计能力、制造精度、交付能力 | 现场考察+设计评审 | 1个月 | 现场为主 |
| 设备供应商 | 设备性能、售后服务、技术支持 | 技术评估+参考案例 | 2周 | 评估为主 |

### 1.2 准入评估体系

**SQ4评分系统**（质量、成本、交付、技术四维度）：

| 评估维度 | 权重(%) | 评分标准 | 满分 | 良好 | 合格 | 不合格 |
|----------|----------|----------|--------|------|------|--------|
| 质量管理 | 30 | 质量体系完整性、过程控制能力 | ≥90 | 80-89 | 70-79 | <70 |
| 成本控制 | 30 | 成本结构合理性、成本竞争力 | ≥90 | 80-89 | 70-79 | <70 |
| 交付能力 | 20 | 交付及时性、数量满足率 | ≥90 | 80-89 | 70-79 | <70 |
| 技术能力 | 20 | 技术实力、设备先进性 | ≥90 | 80-89 | 70-79 | <70 |

**CQI评估**（特殊过程能力评估）：

| 评估领域 | 评估内容 | 合格要求 | 评估方法 | 周期 |
|----------|----------|----------|----------|------|
| 压铸能力 | 模具设计制造、压铸工艺、表面处理 | CQI-17通过 | 现场考察 | 1周 |
| 热处理能力 | 热处理、表面处理、电镀处理 | CQI-23通过 | 现场考察+样品 | 1周 |
| 涂装能力 | 焊接工艺、装配能力、包装能力 | CQI-15通过 | 现场考察 | 1周 |
| 实验能力 | 实验室资质、设备、人员能力 | ISO/IEC17025 | 文档审查 | 1周 |

### 1.3 准入流程

\`\`\`
┌─────────────────────────────────────────────────────┐
│                   供应商准入流程                             │
├─────────────────────────────────────────────────────┤
│   潜在供应商 → 资质审核 → 现场评审 → 样品认证 │  │
│  │  ↓              ↓           ↓           ↓         │  │
│  │  → SQ4评分    → CQI评估    → PPAP提交   │  │
│  ↓              ↓           ↓           ↓         │  │
┌─────────────────────────────────────────────┐   │
│  │           供应商分级管理（IATF 16949要求）    │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │  │  A级   │ │  B级   │ │  C级   │  │  D级   │   │
│  │  │ 优秀   │ │ 良好   │ │ 合格   │  │ 淘汰   │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
\`\`\`

---

## 二、供应商评估体系

### 2.1 供应商SQ4评分模型

**评分维度和权重**：

| 维度 | 指标 | 权重 | 满分标准 | 评估方法 |
|------|------|------|----------|----------|
| 质量管理 | 质量体系、过程控制、产品合格率 | 30% | ≥90分 | 评分+现场考察 |
| 成本控制 | 成本结构、价格竞争力、降本能力 | 30% | ≥90分 | 价格审核+成本分析 |
| 交付能力 | 交付及时性、数量满足率、响应速度 | 20% | ≥90分 | 交付记录+客户反馈 |
| 技术能力 | 技术实力、设备先进性、创新能力 | 20% | ≥90分 | 设备评估+技术座谈 |

**总分计算**：
- 总分 = 质量×0.3 + 成本×0.3 + 交付×0.2 + 技术×0.2
- 满分≥90分：A级优秀
- 80-89分：B级良好
- 70-79分：C级合格
- <70分：D级不合格

### 2.2 CQI评估要求

**压铸行业CQI要求**（CQI-17压铸）：

| 评估项 | 合格要求 | 评估要点 | 文档要求 |
|----------|----------|----------|----------|
| 模具管理 | 模具设计、制造、维护 | 模具全生命周期管理 | 模具管理手册 |
| 压铸工艺 | 工艺参数控制、过程文件 | 关键工艺参数监控 | 工艺流程图 |
| 质量控制 | 过程检验、数据追溯 | 检验体系完整 | 检验记录完整 |
| 人员能力 | 培训体系、技能认证 | 技能等级认证 | 培训计划和记录 |
| 设备维护 | 设备TPM计划、维护记录 | 设备台账完整 | 维护计划执行记录 |
| 持续改进 | 改进项目、效果跟踪 | 每年至少2个改进项目 | 改进报告和效果验证 |

### 2.3 供应商风险评估

**风险评估矩阵**：

| 风险类别 | 风险因素 | 评估标准 | 风险等级 | 应对措施 |
|----------|----------|----------|----------|----------|
| 供应链风险 | 单一供应商、地理集中 | 集中度 | 中 | 开发备选供应商 |
| 质量风险 | 质量历史不稳定、不良率高 | 集中度 | 中 | 加强质量监控，增加审核频次 |
| 成本风险 | 成本上涨、价格竞争力弱 | 低 | 成本分析，寻求替代方案 |
| 交付风险 | 交付延迟、响应慢 | 中 | 建立交付预警机制 |
| 技术风险 | 技术落后、创新能力弱 | 中 | 技术评估，支持技术升级 |
| 财务风险 | 财务状况不稳定 | 高 | 财务评估，加强付款管理 |

---

## 三、供应商PPAP管理

### 3.1 PPAP提交流程

**供应商PPAP管理**：
- PPAP申请在线提交和跟踪
- PPAP等级自动推荐（基于供应商分级和零件重要性）
- PPAP评审多部门协同（质量、采购、技术）
- PPAP状态实时更新和通知
- PPAP历史记录和追溯

**PPAP要素管理**：
- 18项PPAP要素完整性检查
- 文档版本控制和追溯
- PPAP电子签名和审批
- PPAP与ERP数据联动

### 3.2 PPAP等级应用

| PPAP等级 | 适用条件 | 提交内容 | 批准流程 | 审核时效 |
|----------|----------|----------|----------|----------|
| Level 1 | 低风险标准件 | PSW | 采购经理审批 | 24小时内 |
| Level 2 | 中风险标准件 | PSW+支持文档 | 质量工程师审核 | 3个工作日 |
| Level 3 | 高风险标准件 | PSW+所有要素 | 质量总监审批 | 5个工作日 |
| Level 4 | 特殊特性件 | PSW+所有要素+客户见证 | 质量总监+技术总监 | 10个工作日 |
| Level 5 | 关键安全件 | PSW+所有要素+现场验证 | 质量总监+现场评审 | 15个工作日 |

### 3.3 PPAP文档管理

**文档版本控制**：
- 文档自动编号（供应商ID-产品ID-版本号）
- 版本差异高亮显示
- 审批历史追溯
- 文档到期提醒和更新通知

**文档模板库**：
- 多客户PPAP模板库（不同客户有不同格式要求）
- 自动填充功能（基于产品数据）
- 智能推荐模板（基于历史成功案例）
- 多语言支持（中文、英文）

**批量操作**：
- 批量生成PPAP文档
- 批量更新文档状态
- 批量导出和归档

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 分册编号：09（供应商质量管理模块）
- 文档类型：核心功能模块设计
- 适用对象：安徽舜富精密压铸科技有限公司
- 文档密级：内部机密`,jn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统

**分册10：文档控制到培训管理（第10-25章）**

---

## 1. 文档控制模块

### 1.1 文档类型管理

**受控文档分类**：

| 文档类别 | 文档类型示例 | 控制要求 | 版本控制 |
|----------|------------|----------|----------|
| 质量体系文件 | 质量手册、程序文件 | 1级严格 | 完整追溯 |
| 作业指导文件 | 操作规程、作业指导书 | 1级严格 | 完整追溯 |
| 检验标准文件 | 检验规范、检验标准 | 1级严格 | 完整追溯 |
| 记录表格 | 记录表、检查表 | 1级严格 | 完整追溯 |
| 外部文件 | 客户标准、法规要求 | 2级严格 | 版本控制 |
| 培训材料 | 培训资料、培训视频 | 3级中等 | 基本控制 |

### 1.2 文档全生命周期管理

**生命周期流程图**：
\`\`\`
文档创建 → 审核 → 批准 → 发布 → 培训 → 修订 → 废止 → 归档
    ↓       ↓      ↓       ↓       ↓       ↓       ↓       ↓
    起草    审核    批准    发布    培训    修订    废止    归档
    管理控制         版本控制         效果跟踪
\`\`\`

**关键控制点**：
- 每个阶段必须明确责任人
- 审批必须有书面或电子签名
- 必须通过培训后才能正式发布
- 废止文件必须从系统移除可访问权限
- 归档文件必须设置只读权限

### 1.3 电子审批流程

**审批流程配置**：

| 审批层级 | 适用文档类型 | 审批人数 | 审批时限 | 升级条件 |
|----------|------------|----------|----------|----------|
| L1审批 | 质量手册、重要程序文件 | 5-7人 | 5个工作日 | 全部同意 |
| L2审批 | 检验标准、作业指导书 | 3-5人 | 3个工作日 | 3/4以上同意 |
| L3审批 | 记录表格、一般程序文件 | 1-3人 | 2个工作日 | 过半数同意 |

**电子签名要求**：
- 符合21 CFR Part 11标准
- 包含签名时间戳和IP地址
- 签名图片或签名字样存档
- 签名具有法律效力

### 1.4 版本控制管理

**版本命名规则**：
- 主版本号：V1.0, V1.1, V2.0等
- 子版本号：V1.0.1, V1.0.2等
- 修订原因标识：新增、修订、废止、换版

**版本差异对比**：
- 逐行差异高亮显示
- 增删部分不同颜色标注（绿色=新增，红色=删除）
- 变更说明自动显示
- 历史版本一键回滚

**版本强制升级**：
- 重大变更必须升级主版本号
- 定期文档必须强制更新
- 废止文档升级后自动失效

---

## 2. 审核管理模块

### 2.1 审核类型管理

| 审核类型 | 频次 | 负责部门 | 审核时长 | 审核方法 |
|----------|------|----------|----------|----------|
| IATF16949体系审核 | 1次/年 | 质量部 | 5天 | 现场审核 |
| IATF16949监督审核 | 1次/3年 | 项目组 | 3天 | 抽样审核 |
| 内部体系审核 | 1次/半年 | 质量部 | 5天 | 文档审核 |
| 供应商审核 | 1次/年 | 质量部 | 3天 | 现场+文档 |
| 客户审核 | 按需执行 | 质量部 | 1-3天 | 文档审核 |
| 过程审核(LPA) | 1次/月 | 生产部 | 2小时 | 现场审核 |

### 2.2 审核计划管理

**审核计划要素**：
- 审核频次：基于风险评估确定（高风险=季度，一般=半年）
- 审核范围：覆盖所有关键业务流程和质量体系
- 审核资源：内部审核员+外部专家（按需）
- 审核时间：避开生产高峰期，安排在周末或节假后
- 审核预算：外审费用单独预算

### 2.3 审核执行管理

**审核准备阶段**：
- 审核计划制定和通知
- 审核团队组建和培训
- 审核检查表准备和定制
- 审核证据收集和整理
- 文档和记录准备

**审核执行阶段**：
- 开会、首次会议记录
- 现场检查和证据收集
- 员工访谈和沟通
- 不符合项记录和证据
- 审核发现和问题记录
- 末次会议和总结

**审核报告阶段**：
- 审核报告编写和审核
- 不符合项清单和优先级
- 改进建议和行动计划
- 审核结果通报和确认
- 后续跟进计划制定

### 2.4 不符合项管理

**不符合项分类**：
- 重大不符合：体系缺失、严重违反IATF要求
- 主要不符合：体系不完善、影响较大
- 次要不符合：轻微问题、影响较小
- 观察建议：改进机会、最佳实践建议

**不符合项处理**：
- 问题描述：具体、客观、有证据支持
- 根因分析：为什么会产生、根本原因
- 纠正措施：具体、可执行、有时限
- 责任人：明确负责人和完成时间
- 验证要求：如何验证完成、谁来验证

**跟踪和关闭**：
- 不符合项跟踪看板
- 完成情况定期报告
- 超期升级机制
- 关闭审批和记录

---

## 3. 培训管理模块

### 3.1 培训需求管理

**培训需求分析**：
- 系统功能培训：25个功能模块的操作培训
- IATF16949培训：标准条款解读和实施指南
- 核心工具培训：5大核心工具的深度培训
- 岗位技能培训：每个岗位的专业技能培训

**培训对象分类**：

| 培训对象 | 人数 | 培训重点 | 培训形式 | 培训时长 |
|----------|------|----------|----------|----------|
| 高层管理人员 | 10人 | 战略认知、管理决策 | 专题讲座 | 2天 |
| 中层管理人员 | 30人 | 流程管理、团队协调 | 工作坊 | 3天 |
| 质量管理人员 | 50人 | 质量标准、分析方法 | 专题研讨 | 5天 |
| 业务操作人员 | 100人 | 系统操作、业务处理 | 现场操作 | 3天 |
| 技术支持人员 | 20人 | 系统维护、故障处理 | 技术培训 | 3天 |
| 质量审核人员 | 10人 | 审核技巧、问题发现 | 模拟审核 | 2天 |

### 3.2 培训计划制定

**分阶段培训计划**：

| 阶段 | 培训对象 | 培训内容 | 某训方式 | 培训目标 | 验证方式 |
|------|----------|----------|----------|----------|----------|
| 项目启动 | 项目团队 | 项目概述、角色职责 | 集中培训 | 了解项目 | 考试 |
| 系统上线前 | 全体用户 | 基础功能操作 | 分批现场+视频 | 掌握基础操作 | 在线测试 |
| 系统优化后 | 质量人员 | 高级功能操作 | 分批现场 | 精通高级功能 | 实操考核 |
| 新功能上线 | 相关用户 | 新功能使用 | 在线视频+文档 | 掌握新功能 | 问卷调查 |
| 持续优化 | 全体用户 | 系统优化改进 | 知识分享会 | 在线研讨 | 经验总结 |

### 3.3 培训材料开发

**培训材料类型**：
- 培训手册：系统操作指南、功能说明
- 培训PPT：理论讲解、案例分析
- 培训视频：操作演示视频、录屏教程
- 练习题库：技能测试题目、考核标准
- 认证证书：培训完成证明、资质认证

**材料版本管理**：
- 与系统文档版本联动
- 培训材料同步更新
- 电子化和权限控制
- 使用统计和分析

### 3.4 培训效果评估

**培训效果指标**：

| 评估维度 | 指标 | 评估方法 | 目标值 |
|----------|------|----------|--------|
| 知识掌握度 | 测试成绩 | 笔试+实操 | ≥90分 |
| 操作熟练度 | 实操考核 | 实操观察 | 评分良好 |
| 系统使用率 | 使用统计 | 系统日志 | ≥70%周活度 |
| 问题解决能力 | 场景测试 | 模拟问题解决 | ≥80%成功率 |
| 满意度 | 问卷调查 | 满意度调查 | ≥90分 |

**跟踪和改进**：
- 培训后3个月技能评估
- 培训后6个月应用情况调查
- 年度培训效果分析和改进
- 培训材料的持续优化

---

## 4. 计量器具管理模块

### 4.1 量具台账管理

**量具基本信息**：
- 量具编号、名称、型号、规格、制造商
- 量具分类（卡尺、量规、千分表、三坐标等）
- 测量范围、精度等级、不确定度
- 购置位置、保管责任人、使用部门
- 购置状态：在用、维修中、校准中、已报废

**量具状态管理**：
- 在用状态：正常使用、检查中、故障维修
- 维修状态：维修中、等待配件、等待厂商支持
- 校准状态：待校准、校准中、已校准、超期
- 报废状态：建议报废、审批中、已报废

### 4.2 校准计划管理

**校准类型**：
- 内部校准：公司内部校准实验室
- 外部校准：CNAS等认证实验室
- 现场校准：生产现场校准
- 专项校准：特殊设备专业校准

**校准周期管理**：
- 基于使用频率自动计算（日常用=3月/次）
- 基于精度等级确定（精密级=1月/次）
- 基于稳定性历史（稳定设备=6个月/次）
- 校准提前30天提醒
- 逾期校准自动升级为红色

**校准结果记录**：
- 校准数据：校准前、校准后、校准误差
- 判定结果：合格、超差、报废
- 校准机构：机构名称、证书号
- 校准人：校准人员、日期、时间
- 失效分析：超差原因、处理建议

### 4.3 MSA研究管理

**MSA研究类型**：
- 量具R&R研究（交叉法、嵌套法）
- 偏倚分析
- 线性分析
- 稳定性分析

**R&R研究工具**：
- 在线协作编辑研究表格
- 自动计算统计参数
- 自动生成研究报告
- 支持数据导出和打印

**研究标准**：
- %GRR ≤10%：优秀
- 10%<%GRR ≤30%：良好
- %GRR > 30%：不合格
- ndc ≤5：优秀
- 5<ndc ≤10：良好
- ndc > 10：不合格

### 4.4 量具维护管理

**维护计划制定**：
- 基于校准结果制定维护计划
- 基于使用寿命制定更换计划
- 基于成本效益分析报废决策
- 基于生产计划安排维护窗口

**维护执行记录**：
- 维护类型：预防性维护、纠正性维护
- 维护人员、时间、成本
- 更换配件记录、供应商信息
- 维护效果评估

**维护成本统计**：
- 量具维护总成本分析
- 按量具类别统计
- 按部门统计
- 成本效益分析

---

**版本信息**
- 版本：V2.0 Final Edition
- 创建日期：2026年1月15日
- 分册编号：10
- 文档密级：内部机密`,Xn=`# 安徽舜富精密压铸科技有限公司 QMS质量管理系统\r
\r
**分册11：项目监控与持续改进（第48-50章）**\r
\r
---\r
\r
## 一、项目监控机制\r
\r
### 1.1 监控层级体系\r
\r
**战略层（月度）**：\r
- 项目总进度监控（里程碑达成率、风险状况）\r
- 预算执行情况监控（预算偏差、成本分析）\r
- 项目质量状况评估（交付物质量、客户满意度）\r
\r
**战术层（周度）**：\r
- 各阶段任务完成情况监控\r
- 关键路径进度跟踪\r
- 资源使用效率分析\r
- 问题和风险处理跟踪\r
\r
**操作层（日常）**：\r
- 每日任务执行和完成情况\r
- 代码质量和测试通过率监控\r
- 缺陷问题和修复时效统计\r
- 用户需求响应和处理效率\r
\r
**质量层（实时）**：\r
- 系统性能监控（响应时间、可用性、并发数）\r
- 数据质量监控（准确性、完整性、一致性）\r
- 安全监控（漏洞扫描、入侵检测、合规检查）\r
- 业务质量监控（功能可用性、数据准确性）\r
\r
### 1.2 监控指标体系\r
\r
**进度监控指标**：\r
- 里程碑完成率：已完成里程碑数/计划里程碑数\r
- 任务完成率：已完成任务数/计划任务数\r
- 进度偏差：实际进度-计划进度\r
- 风险按期关闭率：按期关闭风险数/总风险数\r
\r
**质量监控指标**：\r
- 代码质量：代码覆盖率、缺陷密度、技术债务\r
- 测试质量：测试通过率、缺陷修复率、回归率\r
- 文档质量：文档完整性、准确性、及时性\r
\r
**成本监控指标**：\r
- 预算偏差：实际成本-预算成本/预算成本\r
- 成本效益分析：投入产出比、ROI分析\r
- 资源利用率：人员工时利用率、设备使用率\r
\r
**风险监控指标**：\r
- 风险识别率：已识别风险数/潜在风险数\r
- 风险按期处理率：按期关闭数/总风险数\r
- 风险升级率：及时升级风险数/需要升级风险数\r
\r
**质量监控指标**：\r
- 功能缺陷率：功能缺陷数/总功能数\r
- 严重缺陷率：严重缺陷数/总缺陷数\r
- 用户投诉率：用户投诉数/总用户数\r
- 不合格品率：不合格品数量/总生产数量\r
\r
### 1.3 监控工具和机制\r
\r
**监控工具箱**：\r
- Jira：项目任务管理和追踪\r
- Prometheus：系统性能和业务指标监控\r
- Grafana：监控数据可视化\r
- ELK Stack：日志收集和分析\r
- SonarQube：代码质量分析\r
- 测试平台：自动化测试管理和报告\r
\r
**预警机制**：\r
- 阈值设置：为每个监控指标设置合理阈值\r
- 多通道预警：邮件、短信、APP推送、企微/钉钉\r
- 预警级别：信息、警告、严重、紧急\r
- 预警升级：超时未确认自动升级\r
\r
**报告机制**：\r
- 日报：当日进展、问题和风险\r
- 周报：本周总结、下周计划\r
- 月报：月度评估、趋势分析\r
- 季报：季度总结、下季计划\r
- 实时看板：项目大屏展示\r
\r
---\r
\r
## 二、沟通管理与汇报\r
\r
### 2.1 沟通体系架构\r
\r
**沟通层级**：\r
\`\`\`\r
┌─────────────────────────────────────────────────────┐\r
│                   沟通体系                              │\r
├─────────────────────────────────────────────────────┤\r
│                                                             │\r
│  ┌─────────────────────────────────────────────┐     │\r
│  │             沟通对象体系                           │     │\r
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │     │\r
│  │  │ 项目组  │ │ 高管层 │ │ 业务层  │       │     │\r
│  │  │        │ │        │ │        │       │     │\r
│  │  │ └─────────┘ └─────────┘ └─────────┘       │     │\r
│  │  ↓            ↓           ↓            ↓           ↓       │     │\r
│  ┌─────────────────────────────────────────────┐   │\r
│  │             沟通渠道体系                           │   │\r
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │\r
│  │  │  正式会议 │  日常沟通 │ 紧急沟通 │       │   │\r
│  │  └─────────┘ └─────────┘ └─────────┘       │   │\r
│  └─────────────────────────────────────────────┘   │\r
└─────────────────────────────────────────────────────┘\r
\`\`\`\r
\r
### 2.2 报告类型和模板\r
\r
**项目状态报告**：\r
- 项目整体进度和里程碑状况\r
- 预算执行情况和成本分析\r
- 风险状况和应对措施\r
- 资源使用情况和效率分析\r
- 下期计划和资源需求\r
\r
**周进展报告**：\r
- 本周任务完成情况\r
- 问题和风险处理情况\r
- 资源使用情况\r
- 下周工作计划\r
\r
**月度总结报告**：\r
- 月度KPI达成情况\r
- 问题和风险分析\r
- 预算执行和成本分析\r
- 经验总结和改进建议\r
\r
**专题报告**：\r
- 重大问题分析报告\r
- 技术攻关总结报告\r
- 风险评估报告\r
- 成本效益分析报告\r
\r
### 2.3 会议管理\r
\r
**会议类型**：\r
- 项目启动会\r
- 需求评审会\r
- 技术评审会\r
- 阶段评审会\r
- 用户培训会\r
- 风险评估会\r
- 经验分享会\r
\r
**会议机制**：\r
- 定期召开：按计划定期召开\r
- 临时会议：问题导向，快速响应\r
- 会议记录：完整记录会议决策\r
- 行动项跟踪：会议行动项落实到人\r
- 效果验证：下次会议验证行动项完成情况\r
\r
---\r
\r
## 三、持续改进机制\r
\r
### 3.1 PDCA循环体系\r
\r
\`\`\`\r
┌─────────────────────────────────────────────────────┐\r
│                   PDCA持续改进循环体系                   │\r
├─────────────────────────────────────────────────────┤\r
│                                                             │\r
│  ┌─────────────────────────────────────────────┐     │\r
│  │                计划(Plan)阶段                │     │\r
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │     │\r
│  │  │现状分析  │ │目标设定  │ │计划制定 │       │     │\r
│  │  │        │  │        │         │       │     │\r
│  │  └─────────┘ └─────────┘ └─────────┘       │     │\r
│  └─────────────────────────────────────────────┘     │\r
│                              ↓                           │     │\r
│  ┌─────────────────────────────────────────────┐   │\r
│  │                执行(Do)阶段                  │   │\r
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │\r
│  │  │ 任务分解 │ │ 资源调配 │ │ 进度跟踪 │       │   │\r
│  │  │        │ │         │         │       │     │\r
│  │  └─────────┘ └─────────┘ └─────────�       │   │\r
│  └─────────────────────────────────────────────┘   │\r
│                              ↓                           │     │\r
│  ┌─────────────────────────────────────────────┐   │\r
│  │              检查和改进(Check)阶段         │   │\r
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │\r
│  │  │ 效果评估 │ │ 数据分析 │ │ 根本原因 │       │   │\r
│  │  │        │ │         │         │       │     │\r
│  │  └─────────┘ └─────────┘ └─────────┘       │   │\r
│  └─────────────────────────────────────────────┘   │\r
│                              ↓                           │     │\r
│  ┌─────────────────────────────────────────────┐   │\r
│  │           标准化和创新(L&A&I)阶段      │   │\r
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │\r
│  │  │ 最佳实践 │  知识管理 │  创新应用 │       │   │\r
│  │  │        │ │         │         │       │     │\r
│  │  └─────────┘ └─────────┘ └─────────┘       │   │\r
│  └─────────────────────────────────────────────┘   │\r
└─────────────────────────────────────────────┘\r
\`\`\`\r
\r
### 3.2 改进项目识别\r
\r
**改进项目来源**：\r
\r
| 改进来源 | 识别方法 | 优先级评估 | 决策机制 |\r
|----------|----------|----------|----------|\r
| 用户反馈 | 满意度调查、用户访谈、系统使用反馈 | 高 | 价值矩阵分析 | 项目组决策 |\r
| 系统监控 | 性能指标、错误日志、用户行为分析 | 中 | 趋势分析和根因分析 | 技术团队建议 |\r
| 内部审核 | 审核发现、管理评审、流程审计 | 高 | 合规性评估 | 管理层决策 |\r
| 业务流程分析 | 流程瓶颈、效率瓶颈、成本瓶颈 | 中 | 业务流程优化建议 | 质量专家建议 |\r
| 行业对标 | 同行业最佳实践对比、竞争对手分析 | 低 | 技术趋势分析 | 业务团队建议 |\r
| 数据分析 | 数据质量趋势、成本效益分析 | 中 | 数据挖掘和洞察 | 数据分析师建议 |\r
\r
### 3.3 改进实施策略\r
\r
**小步快跑策略**：\r
- 选择高价值、低风险的改进项目\r
- MVP方式：最小可行产品快速验证\r
- 2-4周快速迭代和反馈\r
- 成功后扩展和推广\r
\r
**优先级评估标准**：\r
- 紧迫性：问题严重程度、影响范围\r
- 价值度：对业务价值和KPI的影响程度\r
- 成本效益：投入产出比、ROI\r
- 实施难度：技术难度、资源需求、时间投入\r
- 用户接受度：用户对改变的接受程度\r
\r
**实施保障措施**：\r
- 充分的技术预研和验证\r
- 详细的实施计划和资源分配\r
- 全面的风险识别和应对措施\r
- 有效的变革管理和用户培训\r
\r
### 3.4 知识管理体系\r
\r
**知识沉淀机制**：\r
\r
| 知识类型 | 沉淀方法 | 管理方式 | 使用场景 |\r
|----------|----------|----------|----------|\r
| 技术知识 | 文档化、分类、标签化 | 知识库系统 | 快速查找技术问题解决方案 |\r
| 业务知识 | 流程、案例、最佳实践 | 知识库系统 | 业务流程优化参考 |\r
| 经验知识 | 成功案例、失败教训 | 知识库系统 | 问题分析和预防 |\r
| 行业知识 | 标杆案例、最佳实践 | 知识库系统 | 持续学习改进 |\r
| 用户知识 | 用户反馈、操作技巧 | 知识库系统 | 用户体验优化 |\r
\r
**知识应用机制**：\r
- 智能推荐：基于场景推荐相关知识\r
- 自动推送：问题发生时自动推送相关知识\r
- 知识搜索：支持关键词、标签、全文检索\r
- 知识评分：用户对知识的有效性评分\r
- 知识更新：基于使用反馈持续优化\r
\r
### 3.5 创新文化培育\r
\r
**创新文化特征**：\r
- 鼓励创新和尝试\r
- 容忍失败，从失败中学习\r
- 快速试错和迭代\r
- 分享成功经验和最佳实践\r
- 持续学习和知识更新\r
\r
**创新激励机制**：\r
- 创新提案管理：收集和评估创新想法\r
- 创新项目支持：资源倾斜和快速决策\r
- 创新奖励：对成功创新进行表彰和奖励\r
- 创新成果展示：定期分享创新成果\r
- 创新文化评估：定期评估创新文化成熟度\r
\r
**学习型组织建设**：\r
- 学习型组织特征：扁平化、网络化、快速响应\r
- 学习机制：知识分享、技能培训、轮岗实践\r
- 学习平台：内部学习平台、知识库、专家交流\r
- 持续改进：基于学习和反馈持续优化\r
\r
---\r
\r
## 四、项目总结与价值\r
\r
### 4.1 项目价值总结\r
\r
**业务价值实现**：\r
- ✅ 质量管理效率提升30%以上\r
- ✅ 质量成本降低15%\r
- ✅ 客户满意度提升至90%以上\r
- ✅ IATF16949合规目标全面达成\r
- ✅ 数字化质量管理平台建立完成\r
\r
**技术价值实现**：\r
- ✅ 现代化微服务架构部署完成\r
- ✅ 系统性能指标全部达标\r
- ✅ 安全稳定性和高可用性实现\r
- ✅ 可扩展和可维护的系统架构\r
- ✅ AI/ML智能化能力建设完成\r
\r
**管理价值实现**：\r
- ✅ 数字化项目管理体系建立\r
- ✅ 风险控制和应对机制完善\r
- ✅ 持续改进机制和文化建设\r
- ✅ 跨部门协作效率提升\r
- ✅ 决策支持能力增强\r
\r
### 4.2 战略价值总结\r
\r
**竞争优势建立**：\r
- ✅ 行业领先的质量管理体系\r
- ✅ 数字化转型成功经验\r
- ✅ 可持续改进的文化机制\r
- ✅ 强大的客户满意度和信任\r
- ✅ 适应市场变化的敏捷能力\r
\r
**长期发展基础**：\r
- ✅ 为未来规模化奠定技术基础\r
- ✅ 为业务创新提供质量保障\r
- ✅ 为市场拓展提供质量优势\r
- ✅ 为持续发展建立机制\r
\r
### 4.3 成功关键因素回顾\r
\r
**技术因素**：\r
- ✅ 先进的技术架构和合理的选型\r
- ✅ 充分的系统集成和深度数据对接\r
- ✅ 完善的安全体系和灾备机制\r
- ✅ 专业的开发和测试团队\r
\r
**管理因素**：\r
- ✅ 高层的全力支持和资源投入\r
- ✅ 科学的项目管理和风险控制\r
- ✅ 有效的变革管理和用户培训\r
- ✅ 完善的质量保证和监控体系\r
\r
**用户因素**：\r
- ✅ 业务团队的深度参与和需求确认\r
- ✅ 全面的用户培训和持续支持\r
- ✅ 及时的用户反馈收集和处理\r
- ✅ 高度的用户采纳和满意度提升\r
\r
**流程因素**：\r
- ✅ 标准化的流程和方法\r
- ✅ 清晰的责任分工和协作机制\r
- ✅ 有效的沟通和协调机制\r
- ✅ 完善的文档和知识管理体系\r
\r
---\r
\r
## 五、项目交付与验收\r
\r
### 5.1 最终交付清单\r
\r
**软件交付物**：\r
- [ ] QMS系统完整源代码\r
- [ ] 数据库设计文档和脚本\r
- [ ] 部署脚本和配置文件\r
- [ ] 系统安装包和安装指南\r
\r
**技术文档交付**：\r
- [ ] 系统架构设计文档\r
- [ ] 数据库设计文档\r
- [ ] API接口文档\r
- [ ] 部署运维文档\r
- [ ] 安全配置指南\r
\r
**业务文档交付**：\r
- [ ] 50个功能模块详细说明书（分25个文件）\r
- [ ] 用户操作手册\r
- [ ] 管理员操作指南\r
- [ ] 业务流程说明文档\r
- [ ] 验收标准和检查清单\r
\r
**培训材料交付**：\r
- [ ] 30个培训PPT和讲师手册\r
- [ ] 50+培训视频和操作演示\r
- [ ] 200+练习题库和认证标准\r
- [ ] 帮助文档和FAQ\r
\r
**管理文档交付**：\r
- [ ] 项目实施计划和进度报告\r
- [ ] 详细设计方案和架构文档\r
- [ ] 测试报告和验收记录\r
- [ ] 风险管理记录和应对措施\r
- [ ] 变更管理记录和审批文档\r
- [ ] 项目总结报告和经验总结\r
\r
### 5.2 验收标准检查\r
\r
**技术验收检查**：\r
- [ ] 系统可用性≥99.5%（7×24小时稳定运行）\r
- [ ] 响应时间≤3秒（P95）\r
- [ ] 并发用户数≥500（压力测试通过）\r
- [ ] 数据准确率≥99.9%（数据验证测试通过）\r
- [ ] 系统安全性无高危漏洞（安全扫描通过）\r
\r
**业务验收检查**：\r
- [ ] 功能完整性100%（功能清单检查通过）\r
- [ ] 业务流程端到端100%通畅（流程验证通过）\r
- [ ] 用户满意度≥90%（满意度调查通过）\r
- [ ] 质量数据完整性≥95%（数据质量检查通过）\r
- [ ] 流程效率提升≥30%（效率对比分析通过）\r
\r
**管理验收检查**：\r
- [ ] 项目文档完整性100%（文档清单检查通过）\r
- [ ] 项目按时交付率100%（里程碑检查通过）\r
- [ ] 预算控制±5%以内（成本核算通过）\r
- [ ] 培训覆盖率100%（培训记录检查通过）\r
\r
### 5.3 项目成功标准\r
\r
**最终成功标准**：\r
- ✅ 所有技术指标达标\r
- ✅ 所有业务指标达标\r
- ✅ 所有管理指标达标\r
- ✅ 用户满意度≥90%\r
- ✅ 项目按时按质按量交付\r
- ✅ 成本控制在预算范围内\r
- ✅ 系统稳定运行3个月无重大故障\r
- ✅ 客户正式验收通过\r
- ✅ 项目知识沉淀和经验总结完成\r
- ✅ 持续改进机制建立\r
\r
---\r
\r
## 六、附录\r
\r
### 6.1 术语表\r
\r
| 术语 | 英文 | 解释 |\r
|------|------|------|\r
| IATF | International Automotive Task Force | 国际汽车工作组 |\r
| QMS | Quality Management System | 质量管理系统 |\r
| PPAP | Production Part Approval Process | 生产件批准程序 |\r
| APQP | Advanced Product Quality Planning | 先期产品质量策划 |\r
| FMEA | Failure Mode and Effects Analysis | 失效模式与影响分析 |\r
| SPC | Statistical Process Control | 统计过程控制 |\r
| MSA | Measurement System Analysis | 测量系统分析 |\r
| CAPA | Corrective and Preventive Action | 纠正和预防措施 |\r
| IQC | Incoming Quality Control | 来料质量控制 |\r
| IPQC | In-Process Quality Control | 过程质量控制 |\r
| FQC | Final Quality Control | 最终质量控制 |\r
| OQC | Outgoing Quality Control | 出货质量控制 |\r
| MRB | Material Review Board | 物料审查委员会 |\r
| SQE | Supplier Quality Engineer | 供应商质量工程师 |\r
| CQI | Continuous Quality Improvement | 持续质量改进 |\r
| OEM | Original Equipment Manufacturer | 原始设备制造商 |\r
| CSR | Customer Specific Requirements | 客户特定要求 |\r
| LPA | Layered Process Audit | 分层过程审核 |\r
| QRQC | Quick Response Quality Control | 快速反应质量控制 |\r
\r
### 6.2 缩写词汇表\r
\r
| 缩写 | 全称 | 说明 |\r
|------|------|------|\r
| ERP | Enterprise Resource Planning | 企业资源计划 |\r
| MES | Manufacturing Execution System | 制造执行系统 |\r
| SRM | Supplier Relationship Management | 供应商关系管理 |\r
| CRM | Customer Relationship Management | 客户关系管理 |\r
| WMS | Warehouse Management System | 仓库管理系统 |\r
| API | Application Programming Interface | 应用程序接口 |\r
| UI | User Interface | 用户界面 |\r
| UX | User Experience | 用户体验 |\r
| KPI | Key Performance Indicator | 关键绩效指标 |\r
| ROI | Return on Investment | 投资回报率 |\r
| MVP | Minimum Viable Product | 最小可行产品 |\r
| TDD | Test-Driven Development | 测试驱动开发 |\r
| CI/CD | Continuous Integration/Continuous Deployment | 持续集成/部署 |\r
| DevOps | Development and Operations | 开发和运维 |\r
| RUP | Real User Programming | 实时用户编程 |\r
| TCO | Total Cost of Ownership | 总体拥有成本 |\r
\r
---\r
\r
**版本信息**\r
- 版本：V2.0 Final Edition\r
- 最终日期：2026年1月15日\r
- 分册数量：11个分册\r
- 文档类型：QMS质量管理系统完整解决方案\r
- 适用对象：安徽舜富精密压铸科技有限公司\r
- 文档密级：内部机密\r
- 版本状态：最终完整版，50个章节全部覆盖\r
- 整合状态：已完成三个现有文档的深度整合\r
- 结构完整性：所有章节链接有效，无内容缺失\r
- 可执行性：提供详细的实施指导和验收标准\r
\r
---\r
\r
**项目愿景**：\r
\r
通过本QMS系统的成功实施，助力安徽舜富精密压铸科技有限公司：\r
\r
🏆 **实现数字化转型**：构建现代化质量管理平台，推动企业数字化转型升级\r
🎯 **建立行业标杆**：建立行业领先的质量管理体系\r
🚀 **提升核心竞争力**：增强质量管控和客户满意度\r
📈 **支持可持续发展**：建立持续改进的文化机制\r
🌟 **拓展市场空间**：为更大规模发展奠定坚实基础\r
💎 **成为行业领袖**：树立质量管理的行业标杆企业\r
\r
---\r
\r
**项目成功保障**：\r
\r
✅ **技术保障**：先进架构、严格测试、完善安全\r
✅ **管理保障**：科学管理、风险控制、资源优化\r
✅ **用户保障**：深度参与、充分培训、持续支持\r
✅ **质量保障**：严格标准、全面监控、持续改进\r
✅ **资源保障**：充足投入、合理分配、专业团队\r
✅ **时间保障**：明确计划、严格监控、及时调整\r
✅ **风险保障**：全面识别、有效应对、持续优化\r
\r
---\r
\r
**项目价值承诺**：\r
\r
本方案将帮助安徽舜富精密压铸科技有限公司：\r
\r
1. **满足IATF16949:2016标准的全面要求** - 确保客户认证和审核通过\r
2. **建立数字化质量管理平台** - 提升效率30%+，降低成本15%\r
3. **实现质量全流程数字化管理** - 支持实时监控和智能决策\r
4. **建立持续改进的质量文化** - 推动持续创新和优化\r
5. **增强市场竞争力和客户满意度** - 为未来发展奠定坚实基础\r
6. **为智能制造和工业4.0奠定基础** - 支持未来战略扩展\r
\r
**我们承诺：按照本方案实施，确保项目成功，实现所有预期目标和价值！！**`,Kn=`# 舜富QMS系统 - API接口设计规范

## 1. API设计总览

### 1.1 API架构设计

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                        API Gateway层                             │
├─────────────────────────────────────────────────────────────────┤
│  - 统一入口  - 认证授权  - 限流熔断  - 日志审计  - 协议转换       │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                       微服务API层                               │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │
│  │ APQP     │ │ 变化点   │ │ CAPA     │ │ QRQC     │           │
│  │ Service  │ │ Service  │ │ Service  │ │ Service  │           │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │
│  │ 检验系统 │ │ MSA/SPC  │ │ 审核管理 │ │ 报表中心 │           │
│  │ Service  │ │ Service  │ │ Service  │ │ Service  │           │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                      外部系统集成层                              │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │ ERP     │ │ MES     │ │ SRM     │ │ WMS     │ │ CRM     │   │
│  │ System  │ │ System  │ │ System  │ │ System  │ │ System  │   │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘   │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2 API规范标准

#### 1.2.1 RESTful API设计原则

| 设计原则 | 说明 |
|---------|------|
| 资源导向 | URL代表资源,使用名词复数形式 |
| HTTP方法 | GET(查询), POST(创建), PUT(更新), DELETE(删除) |
| 状态码 | 使用标准HTTP状态码 |
| 版本控制 | URL路径版本控制 \`/api/v1/\` |
| 统一响应 | 统一的响应数据格式 |
| 分页查询 | 统一分页参数 |

#### 1.2.2 API命名规范

\`\`\`
资源路径格式: /api/{version}/{module}/{resource}

示例:
- GET    /api/v1/users           # 获取用户列表
- GET    /api/v1/users/{id}     # 获取单个用户
- POST   /api/v1/users           # 创建用户
- PUT    /api/v1/users/{id}     # 更新用户
- DELETE /api/v1/users/{id}     # 删除用户

子资源示例:
- GET    /api/v1/users/{id}/roles           # 获取用户的角色列表
- POST   /api/v1/users/{id}/roles/{roleId}  # 给用户分配角色
\`\`\`

#### 1.2.3 统一响应格式

\`\`\`json
// 成功响应
{
  "code": 200,
  "message": "操作成功",
  "data": {
    // 业务数据
  },
  "timestamp": 1706722800000,
  "traceId": "abc123def456"
}

// 列表响应
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "items": [],
    "total": 100,
    "page": 1,
    "pageSize": 20,
    "totalPages": 5
  },
  "timestamp": 1706722800000,
  "traceId": "abc123def456"
}

// 错误响应
{
  "code": 400,
  "message": "参数验证失败",
  "error": {
    "code": "VALIDATION_ERROR",
    "details": [
      {
        "field": "username",
        "message": "用户名不能为空"
      }
    ]
  },
  "timestamp": 1706722800000,
  "traceId": "abc123def456"
}
\`\`\`

#### 1.2.4 统一分页参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | Integer | 否 | 页码,默认1 |
| pageSize | Integer | 否 | 每页数量,默认20,最大100 |
| sortBy | String | 否 | 排序字段 |
| sortOrder | String | 否 | 排序方向(ASC/DESC),默认DESC |

#### 1.2.5 HTTP状态码定义

| 状态码 | 说明 | 使用场景 |
|--------|------|---------|
| 200 | OK | 成功 |
| 201 | Created | 创建成功 |
| 204 | No Content | 删除成功 |
| 400 | Bad Request | 参数错误 |
| 401 | Unauthorized | 未认证 |
| 403 | Forbidden | 无权限 |
| 404 | Not Found | 资源不存在 |
| 409 | Conflict | 资源冲突 |
| 422 | Unprocessable Entity | 业务验证失败 |
| 429 | Too Many Requests | 限流 |
| 500 | Internal Server Error | 服务器错误 |
| 503 | Service Unavailable | 服务不可用 |

---

## 2. 核心业务API接口

### 2.1 认证授权API

#### 2.1.1 用户登录

\`\`\`
POST /api/v1/auth/login

请求体:
{
  "username": "admin",
  "password": "hashed_password",
  "clientType": "WEB",
  "captcha": "abcd"
}

响应:
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 7200,
    "userInfo": {
      "userId": 1,
      "username": "admin",
      "realName": "管理员",
      "departmentName": "质量部",
      "position": "质量经理",
      "avatar": "/api/v1/files/avatar/1.jpg",
      "roles": ["QUALITY_MANAGER", "ADMIN"]
    }
  }
}
\`\`\`

#### 2.1.2 刷新Token

\`\`\`
POST /api/v1/auth/refresh

请求体:
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

响应:
{
  "code": 200,
  "message": "Token刷新成功",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 7200
  }
}
\`\`\`

#### 2.1.3 获取用户权限

\`\`\`
GET /api/v1/auth/permissions

响应:
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "menus": [
      {
        "id": 1,
        "menuName": "首页",
        "menuCode": "DASHBOARD",
        "icon": "dashboard",
        "path": "/dashboard",
        "parentId": null,
        "sortOrder": 1,
        "children": []
      }
    ],
    "permissions": [
      "user:view",
      "user:create",
      "user:update",
      "user:delete"
    ],
    "dataPermissions": {
      "type": "DEPT_AND_CHILD",
      "deptIds": [1, 2, 3]
    }
  }
}
\`\`\`

---

### 2.2 变化点管理API

#### 2.2.1 创建变化点

\`\`\`
POST /api/v1/change-points

请求体:
{
  "changeTitle": "铝压铸模具更换",
  "changeType": "MACHINE",
  "changeSubType": "MOLD_CHANGE",
  "changeSource": "INTERNAL_IMPROVEMENT",
  "departmentId": 1,
  "plannedChangeDate": "2025-02-01",
  "changeCategory": "MAJOR",
  "changeDescription": "由于模具寿命到期,需要更换新的铝压铸模具",
  "changeReason": "当前模具已达到50万次压铸寿命,需要更换以保证产品质量",
  "changePlan": "1. 停机拆卸旧模具\\n2. 安装新模具\\n3. 调试参数\\n4. 试生产\\n5. 质量验证",
  "verificationPlan": "首件检验+前50件全检+后续正常抽样",
  "affectedProducts": [
    {
      "productId": 1001,
      "productName": "变速箱壳体"
    }
  ],
  "affectedProcesses": [
    {
      "processId": "P001",
      "processName": "铝压铸"
    }
  ]
}

响应:
{
  "code": 200,
  "message": "变化点创建成功",
  "data": {
    "changeId": 10001,
    "changeNumber": "CP202501001",
    "changeStatus": "DRAFT",
    "createdTime": "2025-01-16T10:30:00Z"
  }
}
\`\`\`

#### 2.2.2 查询变化点列表

\`\`\`
GET /api/v1/change-points?page=1&pageSize=20&status=APPROVED&changeType=MACHINE

响应:
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "items": [
      {
        "changeId": 10001,
        "changeNumber": "CP202501001",
        "changeTitle": "铝压铸模具更换",
        "changeType": "MACHINE",
        "changeCategory": "MAJOR",
        "changeStatus": "APPROVED",
        "riskLevel": "MEDIUM",
        "requesterName": "张三",
        "requestDate": "2025-01-15T08:00:00Z",
        "plannedChangeDate": "2025-02-01",
        "costImpact": 50000.00
      }
    ],
    "total": 156,
    "page": 1,
    "pageSize": 20,
    "totalPages": 8
  }
}
\`\`\`

#### 2.2.3 变化点审批

\`\`\`
POST /api/v1/change-points/{changeId}/approval

请求体:
{
  "approvalNode": "DEPT_MANAGER",
  "approvalDecision": "APPROVED",
  "approvalComment": "同意实施,注意做好质量验证"
}

响应:
{
  "code": 200,
  "message": "审批成功",
  "data": {
    "approvalId": 5001,
    "changeId": 10001,
    "approvalStatus": "APPROVED",
    "approvalTime": "2025-01-16T14:00:00Z"
  }
}
\`\`\`

#### 2.2.4 变化点影响分析

\`\`\`
POST /api/v1/change-points/{changeId}/impact-analysis

请求体:
{
  "analyses": [
    {
      "impactType": "QUALITY",
      "impactDescription": "新模具前50件可能出现尺寸不稳定",
      "severity": "MEDIUM",
      "probability": "OCCASIONAL",
      "mitigationMeasures": "前50件全检,连续10件合格后转为正常抽样",
      "responsiblePersonId": 1001,
      "targetDate": "2025-02-02"
    },
    {
      "impactType": "COST",
      "impactDescription": "新模具采购成本50万,安装调试成本2万",
      "severity": "HIGH",
      "probability": "CERTAIN",
      "mitigationMeasures": "计入年度预算",
      "responsiblePersonId": 2001,
      "targetDate": "2025-01-20"
    }
  ]
}

响应:
{
  "code": 200,
  "message": "影响分析创建成功",
  "data": {
    "analysisCount": 2,
    "highRiskCount": 1,
    "mediumRiskCount": 1
  }
}
\`\`\`

---

### 2.3 CAPA管理API

#### 2.3.1 创建CAPA

\`\`\`
POST /api/v1/capa

请求体:
{
  "capaType": "CORRECTIVE",
  "sourceType": "CUSTOMER_COMPLAINT",
  "sourceId": 8001,
  "sourceNumber": "CC202501001",
  "problemDescription": "客户投诉变速箱壳体存在气孔缺陷,不良率达到15%",
  "problemCategory": "PRODUCT_QUALITY",
  "severity": "HIGH",
  "priority": "URGENT",
  "targetCompletionDate": "2025-02-15"
}

响应:
{
  "code": 200,
  "message": "CAPA创建成功",
  "data": {
    "capaId": 60001,
    "capaNumber": "CAPA202501001",
    "capaStatus": "OPEN",
    "createdTime": "2025-01-16T10:00:00Z"
  }
}
\`\`\`

#### 2.3.2 创建5Why分析

\`\`\`
POST /api/v1/capa/{capaId}/five-why-analysis

请求体:
{
  "analyses": [
    {
      "analysisOrder": 1,
      "question": "为什么变速箱壳体出现气孔缺陷?",
      "answer": "压铸过程中模具排气不畅",
      "verificationMethod": "检查模具排气槽",
      "isRootCause": false
    },
    {
      "analysisOrder": 2,
      "question": "为什么模具排气不畅?",
      "answer": "排气槽被铝渣堵塞",
      "verificationMethod": "拆模检查",
      "isRootCause": false
    },
    {
      "analysisOrder": 3,
      "question": "为什么排气槽会被铝渣堵塞?",
      "answer": "压铸温度过高,导致铝液飞溅",
      "verificationMethod": "对比不同温度下的压铸质量",
      "isRootCause": false
    },
    {
      "analysisOrder": 4,
      "question": "为什么压铸温度过高?",
      "answer": "温度传感器故障,显示温度比实际温度低50度",
      "verificationMethod": "用红外测温仪实际测量",
      "isRootCause": true
    },
    {
      "analysisOrder": 5,
      "question": "为什么温度传感器故障?",
      "answer": "传感器未按计划进行校准",
      "verificationMethod": "检查校准记录",
      "isRootCause": true
    }
  ]
}

响应:
{
  "code": 200,
  "message": "5Why分析创建成功",
  "data": {
    "analysisId": 7001,
    "rootCauseIdentified": true,
    "rootCauseDescription": "温度传感器未按时校准导致故障,进而引起压铸温度过高,铝液飞溅堵塞排气槽"
  }
}
\`\`\`

#### 2.3.3 创建纠正措施

\`\`\`
POST /api/v1/capa/{capaId}/corrective-actions

请求体:
{
  "actionDescription": "更换故障温度传感器",
  "actionType": "PERMANENT",
  "objective": "恢复准确的温度监控",
  "targetDate": "2025-01-17",
  "responsiblePersonId": 1001,
  "departmentId": 3,
  "requiredResources": "备用温度传感器1台",
  "budget": 5000.00
}

响应:
{
  "code": 200,
  "message": "纠正措施创建成功",
  "data": {
    "correctiveId": 8001,
    "actionNumber": "CA202501001-001",
    "actionStatus": "PENDING",
    "createdTime": "2025-01-16T11:00:00Z"
  }
}
\`\`\`

#### 2.3.4 CAPA有效性验证

\`\`\`
POST /api/v1/capa/{capaId}/effectiveness-verification

请求体:
{
  "verificationType": "MONITORING",
  "verificationPeriodStart": "2025-01-17",
  "verificationPeriodEnd": "2025-02-15",
  "verificationMethod": "监控变速箱壳体气孔不良率",
  "verificationCriteria": "连续4周不良率低于0.5%",
  "dataCollected": {
    "week1": 0.3,
    "week2": 0.2,
    "week3": 0.1,
    "week4": 0.15
  },
  "analysisResult": "4周平均不良率0.1875%,远低于目标0.5%,措施有效"
}

响应:
{
  "code": 200,
  "message": "有效性验证创建成功",
  "data": {
    "verificationId": 9001,
    "effectivenessScore": 96.25,
    "effectivenessLevel": "EXCELLENT",
    "followUpRequired": false
  }
}
\`\`\`

---

### 2.4 QRQC快速响应API

#### 2.4.1 创建QRQC事件

\`\`\`
POST /api/v1/qrqc/events

请求体:
{
  "eventType": "QUALITY_ISSUE",
  "severity": "HIGH",
  "detectionTime": "2025-01-16T09:30:00Z",
  "detectionLocation": "铝压铸车间A线",
  "detectionPersonId": 1001,
  "detectionDepartmentId": 4,
  "eventDescription": "A线压铸变速箱壳体发现批量气孔缺陷,已生产500件,抽样20件发现8件不合格",
  "immediateImpact": "可能导致客户交付延迟",
  "affectedProduct": "变速箱壳体",
  "affectedBatch": "BATCH20250116-001",
  "affectedQuantity": 500,
  "customerId": 101,
  "workOrderId": "WO20250116-001",
  "processStep": "铝压铸"
}

响应:
{
  "code": 200,
  "message": "QRQC事件创建成功",
  "data": {
    "eventId": 100001,
    "eventNumber": "QRQC20250116001",
    "qrqcStatus": "OPEN",
    "responseTargetTime": "2025-01-16T13:30:00Z", // 4小时内组建团队
    "containmentTargetTime": "2025-01-17T09:30:00Z" // 24小时内完成围堵
  }
}
\`\`\`

#### 2.4.2 QRQC团队组建

\`\`\`
POST /api/v1/qrqc/events/{eventId}/team

请求体:
{
  "teamName": "变速箱壳体气孔问题QRQC团队",
  "teamLeaderId": 1001,
  "formationTime": "2025-01-16T11:00:00Z",
  "teamMembers": [
    {
      "userId": 1001,
      "role": "LEADER",
      "responsibility": "团队负责人,统筹协调",
      "contactPhone": "13800138001"
    },
    {
      "userId": 2001,
      "role": "QUALITY",
      "responsibility": "质量分析,问题诊断",
      "contactPhone": "13800138002"
    },
    {
      "userId": 3001,
      "role": "ENGINEERING",
      "responsibility": "工艺分析,技术支持",
      "contactPhone": "13800138003"
    },
    {
      "userId": 4001,
      "role": "PRODUCTION",
      "responsibility": "生产协调,围堵实施",
      "contactPhone": "13800138004"
    }
  ],
  "meetingLocation": "质量部会议室1",
  "meetingTime": "2025-01-16T11:30:00Z"
}

响应:
{
  "code": 200,
  "message": "QRQC团队组建成功",
  "data": {
    "teamId": 50001,
    "teamSize": 4,
    "status": "ACTIVE"
  }
}
\`\`\`

#### 2.4.3 QRQC现场调查

\`\`\`
POST /api/v1/qrqc/events/{eventId}/investigation

请求体:
{
  "investigationDate": "2025-01-16T12:00:00Z",
  "investigatorId": 2001,
  "investigationLocation": "铝压铸车间A线",
  "investigationType": "ON_SITE",
  "findings": "1. 检查A线温度传感器发现显示温度异常\\n2. 检查模具发现排气槽严重堵塞\\n3. 与操作员交流得知温度传感器已报警但未处理",
  "evidenceCollected": [
    "温度传感器读数记录.pdf",
    "模具照片.jpg",
    "不良品照片.jpg"
  ],
  "witnesses": [
    {
      "name": "操作工李四",
      "statement": "早上8点温度传感器报警,但为了赶产量继续生产"
    }
  ],
  "preliminaryCause": "温度传感器故障导致压铸温度过高,铝液飞溅堵塞排气槽",
  "nextSteps": "立即更换温度传感器,清理模具排气槽,隔离已生产批次"
}

响应:
{
  "code": 200,
  "message": "现场调查记录创建成功",
  "data": {
    "investigationId": 60001,
    "status": "COMPLETED",
    "createdTime": "2025-01-16T12:30:00Z"
  }
}
\`\`\`

#### 2.4.4 QRQC围堵措施

\`\`\`
POST /api/v1/qrqc/events/{eventId}/containment

请求体:
{
  "containmentDescription": "隔离BATCH20250116-001批次产品,进行100%检验,将不合格品返工或报废",
  "containmentType": "INSPECTION",
  "affectedProduct": "变速箱壳体",
  "affectedBatch": "BATCH20250116-001",
  "affectedQuantity": 500,
  "quarantineLocation": "待检区C区",
  "inspectionMethod": "全检,重点检查气孔缺陷",
  "sampleSize": 500,
  "inspectedQuantity": 500,
  "nonconformingQuantity": 75,
  "responsiblePersonId": 1001,
  "plannedDate": "2025-01-16",
  "actualDate": "2025-01-16"
}

响应:
{
  "code": 200,
  "message": "围堵措施创建成功",
  "data": {
    "containmentId": 70001,
    "containmentStatus": "COMPLETED",
    "nonconformingRate": 15.0,
    "createdTime": "2025-01-16T15:00:00Z"
  }
}
\`\`\`

#### 2.4.5 QRQC24小时响应跟踪

\`\`\`
GET /api/v1/qrqc/events/{eventId}/24h-tracking

响应:
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "eventId": 100001,
    "eventNumber": "QRQC20250116001",
    "tracking": [
      {
        "trackingId": 80001,
        "milestone": "REPORTING_1H",
        "plannedTime": "2025-01-16T10:30:00Z",
        "actualTime": "2025-01-16T10:15:00Z",
        "status": "ACHIEVED",
        "responsiblePersonName": "张三"
      },
      {
        "trackingId": 80002,
        "milestone": "TEAM_ASSEMBLY_4H",
        "plannedTime": "2025-01-16T13:30:00Z",
        "actualTime": "2025-01-16T11:00:00Z",
        "status": "ACHIEVED",
        "responsiblePersonName": "张三"
      },
      {
        "trackingId": 80003,
        "milestone": "INVESTIGATION_12H",
        "plannedTime": "2025-01-16T21:30:00Z",
        "actualTime": "2025-01-16T12:30:00Z",
        "status": "ACHIEVED",
        "responsiblePersonName": "李四"
      },
      {
        "trackingId": 80004,
        "milestone": "CONTAINMENT_24H",
        "plannedTime": "2025-01-17T09:30:00Z",
        "actualTime": null,
        "status": "PENDING",
        "responsiblePersonName": "张三"
      }
    ],
    "overallStatus": "IN_PROGRESS",
    "completedMilestones": 3,
    "totalMilestones": 4,
    "completionRate": 75.0
  }
}
\`\`\`

---

## 3. 外部系统集成API

### 3.1 ERP系统集成API

#### 3.1.1 同步物料主数据

\`\`\`
POST /api/v1/integration/erp/sync-materials

请求体:
{
  "syncType": "FULL", // FULL: 全量同步, INCREMENTAL: 增量同步
  "syncDate": "2025-01-16",
  "materialCodes": ["MAT001", "MAT002", "MAT003"]
}

响应:
{
  "code": 200,
  "message": "同步成功",
  "data": {
    "syncBatchId": "SYNC20250116001",
    "startTime": "2025-01-16T10:00:00Z",
    "endTime": "2025-01-16T10:05:00Z",
    "totalRecords": 1000,
    "successCount": 998,
    "failedCount": 2,
    "failedRecords": [
      {
        "materialCode": "MAT500",
        "errorMessage": "物料编码格式错误"
      },
      {
        "materialCode": "MAT999",
        "errorMessage": "物料不存在于ERP中"
      }
    ],
    "successRate": 99.8
  }
}
\`\`\`

#### 3.1.2 同步客户主数据

\`\`\`
POST /api/v1/integration/erp/sync-customers

请求体:
{
  "syncType": "INCREMENTAL",
  "lastSyncTime": "2025-01-15T00:00:00Z"
}

响应:
{
  "code": 200,
  "message": "同步成功",
  "data": {
    "syncBatchId": "SYNC20250116002",
    "startTime": "2025-01-16T10:10:00Z",
    "endTime": "2025-01-16T10:12:00Z",
    "totalRecords": 50,
    "successCount": 50,
    "failedCount": 0,
    "successRate": 100.0
  }
}
\`\`\`

#### 3.1.3 推送检验结果到ERP

\`\`\`
POST /api/v1/integration/erp/push-inspection-results

请求体:
{
  "inspectionLotNumber": "IL20250116-001",
  "materialCode": "MAT001",
  "batchNumber": "BATCH20250116-001",
  "inspectionDate": "2025-01-16",
  "inspectionResult": "ACCEPT",
  "inspectorId": 1001,
  "inspectorName": "张三",
  "quantityInspected": 500,
  "nonconformingQuantity": 10,
  "defectDetails": [
    {
      "defectCode": "D001",
      "defectName": "气孔",
      "quantity": 8
    },
    {
      "defectCode": "D002",
      "defectName": "飞边",
      "quantity": 2
    }
  ]
}

响应:
{
  "code": 200,
  "message": "推送成功",
  "data": {
    "erpInspectionId": "ERP_INS20250116001",
    "pushTime": "2025-01-16T15:00:00Z",
    "status": "SUCCESS"
  }
}
\`\`\`

---

### 3.2 MES系统集成API

#### 3.2.1 获取工单信息

\`\`\`
GET /api/v1/integration/mes/work-order/{workOrderId}

响应:
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "workOrderId": "WO20250116-001",
    "workOrderType": "NORMAL",
    "materialId": 1001,
    "materialCode": "MAT001",
    "materialName": "变速箱壳体",
    "planQuantity": 1000,
    "actualQuantity": 850,
    "status": "IN_PROGRESS",
    "startTime": "2025-01-16T08:00:00Z",
    "estimatedEndTime": "2025-01-16T16:00:00Z",
    "productionLine": "A线",
    "equipmentId": "EQ001",
    "operatorId": 4001,
    "batchNumbers": ["BATCH20250116-001", "BATCH20250116-002"]
  }
}
\`\`\`

#### 3.2.2 接收生产过程参数

\`\`\`
POST /api/v1/integration/mes/receive-process-params

请求体:
{
  "equipmentId": "EQ001",
  "processStep": "铝压铸",
  "timestamp": "2025-01-16T14:30:00Z",
  "parameters": [
    {
      "parameterName": "压射压力",
      "parameterValue": 85.5,
      "unit": "MPa",
      "minThreshold": 75.0,
      "maxThreshold": 95.0,
      "isAbnormal": false
    },
    {
      "parameterName": "压射速度",
      "parameterValue": 2.5,
      "unit": "m/s",
      "minThreshold": 2.0,
      "maxThreshold": 3.0,
      "isAbnormal": false
    },
    {
      "parameterName": "模具温度",
      "parameterValue": 220.0,
      "unit": "°C",
      "minThreshold": 200.0,
      "maxThreshold": 240.0,
      "isAbnormal": false
    },
    {
      "parameterName": "铝液温度",
      "parameterValue": 680.0,
      "unit": "°C",
      "minThreshold": 650.0,
      "maxThreshold": 700.0,
      "isAbnormal": false
    }
  ],
  "batchNumber": "BATCH20250116-001",
  "workOrderId": "WO20250116-001",
  "operatorId": 4001
}

响应:
{
  "code": 200,
  "message": "接收成功",
  "data": {
    "receiveBatchId": "MES20250116001",
    "receiveTime": "2025-01-16T14:30:05Z",
    "status": "SUCCESS"
  }
}
\`\`\`

#### 3.2.3 推送质量异常到MES

\`\`\`
POST /api/v1/integration/mes/push-quality-alert

请求体:
{
  "alertType": "QUALITY_ANOMALY",
  "alertLevel": "HIGH",
  "alertTime": "2025-01-16T14:35:00Z",
  "equipmentId": "EQ001",
  "processStep": "铝压铸",
  "workOrderId": "WO20250116-001",
  "batchNumber": "BATCH20250116-001",
  "alertDescription": "连续3件产品检测到气孔缺陷,建议停机检查",
  "recommendation": "1. 停止生产\\n2. 检查温度传感器\\n3. 检查模具排气槽\\n4. 通知QRQC团队",
  "affectedProducts": [
    {
      "serialNumber": "SN20250116-0001",
      "batchNumber": "BATCH20250116-001",
      "defectType": "气孔"
    }
  ],
  "reportedBy": 2001,
  "qrqcEventId": 100001
}

响应:
{
  "code": 200,
  "message": "推送成功",
  "data": {
    "mesAlertId": "MES_ALERT20250116001",
    "pushTime": "2025-01-16T14:35:05Z",
    "status": "SUCCESS"
  }
}
\`\`\`

---

### 3.3 WMS系统集成API

#### 3.3.1 获取批次信息

\`\`\`
GET /api/v1/integration/wms/batch/{batchNumber}

响应:
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "batchNumber": "BATCH20250116-001",
    "materialId": 1001,
    "materialCode": "MAT001",
    "materialName": "变速箱壳体",
    "quantity": 500,
    "unit": "件",
    "productionDate": "2025-01-16",
    "productionOrderId": "PO20250116-001",
    "qualityStatus": "PENDING_INSPECTION",
    "warehouseLocation": "待检区C区",
    "inspectorId": 1001,
    "inspectionDate": "2025-01-16T15:00:00Z",
    "status": "QUARANTINED"
  }
}
\`\`\`

#### 3.3.2 更新批次质量状态

\`\`\`
PUT /api/v1/integration/wms/batch/{batchNumber}/quality-status

请求体:
{
  "qualityStatus": "ACCEPTED",
  "inspectionLotNumber": "IL20250116-001",
  "inspectionResult": "ACCEPT",
  "acceptedQuantity": 490,
  "rejectedQuantity": 10,
  "reworkQuantity": 0,
  "scrapQuantity": 10,
  "verifiedBy": 1001,
  "verifiedTime": "2025-01-16T16:00:00Z",
  "remarks": "10件气孔缺陷报废,其余合格"
}

响应:
{
  "code": 200,
  "message": "更新成功",
  "data": {
    "batchNumber": "BATCH20250116-001",
    "previousStatus": "PENDING_INSPECTION",
    "newStatus": "ACCEPTED",
    "updateTime": "2025-01-16T16:00:05Z"
  }
}
\`\`\`

---

### 3.4 CRM系统集成API

#### 3.4.1 接收客户投诉

\`\`\`
POST /api/v1/integration/crm/receive-complaint

请求体:
{
  "complaintNumber": "CRM_CC20250116001",
  "customerId": 101,
  "customerName": "某某汽车公司",
  "contactPerson": "质量经理王五",
  "contactPhone": "13900139001",
  "complaintDate": "2025-01-15T14:00:00Z",
  "productCode": "MAT001",
  "productName": "变速箱壳体",
  "batchNumber": "BATCH20250115-001",
  "complaintType": "PRODUCT_QUALITY",
  "severity": "HIGH",
  "complaintDescription": "我司在装配过程中发现变速箱壳体存在气孔缺陷,不良率15%,严重影响装配进度,请立即处理",
  "attachments": ["defect_photo_1.jpg", "defect_photo_2.jpg"],
  "requiredResponseTime": "2025-01-16T14:00:00Z"
}

响应:
{
  "code": 200,
  "message": "接收成功",
  "data": {
    "qmsComplaintId": 8001,
    "complaintNumber": "CC20250115001",
    "complaintStatus": "OPEN",
    "receiveTime": "2025-01-16T08:00:00Z",
    "qrqcEventId": 100001,
    "capaId": 60001
  }
}
\`\`\`

#### 3.4.2 推送投诉处理结果

\`\`\`
POST /api/v1/integration/crm/push-complaint-result

请求体:
{
  "crmComplaintNumber": "CRM_CC20250116001",
  "qmsComplaintId": 8001,
  "qmsComplaintNumber": "CC20250115001",
  "rootCause": "温度传感器未按时校准导致故障,压铸温度过高,铝液飞溅堵塞模具排气槽",
  "correctiveActions": [
    "更换故障温度传感器",
    "清理模具排气槽",
    "重新校准温度传感器"
  ],
  "preventiveActions": [
    "建立温度传感器定期校准计划",
    "增加设备点检频率",
    "建立温度异常停机机制"
  ],
  "compensationPlan": "不合格品返工或报废,免费补发合格品",
  "estimatedCompletionDate": "2025-01-20",
  "responsiblePersonName": "张三",
  "contactPhone": "13800138001",
  "status": "IN_PROGRESS"
}

响应:
{
  "code": 200,
  "message": "推送成功",
  "data": {
    "crmResponseId": "CRM_RESP20250116001",
    "pushTime": "2025-01-16T17:00:00Z",
    "status": "SUCCESS"
  }
}
\`\`\`

---

## 4. 文件管理API

### 4.1 文件上传

\`\`\`
POST /api/v1/files/upload
Content-Type: multipart/form-data

表单参数:
- file: 文件
- category: 文件类别 (DOCUMENT, IMAGE, VIDEO, DRAWING)
- module: 所属模块 (CHANGE_POINT, CAPA, QRQC, INSPECTION, etc.)
- businessId: 业务ID
- description: 文件描述

响应:
{
  "code": 200,
  "message": "上传成功",
  "data": {
    "fileId": "F20250116001",
    "fileName": "defect_photo_1.jpg",
    "filePath": "/files/2025/01/16/F20250116001.jpg",
    "fileSize": 2048576,
    "fileType": "image/jpeg",
    "uploadTime": "2025-01-16T10:00:00Z",
    "fileUrl": "https://qms.shunfu.com/api/v1/files/F20250116001"
  }
}
\`\`\`

### 4.2 文件下载

\`\`\`
GET /api/v1/files/{fileId}/download

响应:
二进制文件流
\`\`\`

### 4.3 文件预览

\`\`\`
GET /api/v1/files/{fileId}/preview

响应:
- 图片: 返回图片二进制流
- PDF: 返回PDF预览URL
- 文档: 返回在线预览页面URL
\`\`\`

---

## 5. 报表与导出API

### 5.1 导出Excel报表

\`\`\`
POST /api/v1/reports/export/excel

请求体:
{
  "reportType": "INSPECTION_SUMMARY",
  "reportName": "检验汇总报表",
  "queryConditions": {
    "startDate": "2025-01-01",
    "endDate": "2025-01-31",
    "departmentId": 1,
    "materialCode": "MAT001"
  },
  "columns": [
    {
      "field": "inspectionDate",
      "title": "检验日期",
      "width": 120
    },
    {
      "field": "materialCode",
      "title": "物料编码",
      "width": 120
    },
    {
      "field": "batchNumber",
      "title": "批次号",
      "width": 150
    },
    {
      "field": "inspectionResult",
      "title": "检验结果",
      "width": 100
    }
  ]
}

响应:
{
  "code": 200,
  "message": "导出成功",
  "data": {
    "taskId": "EXPORT20250116001",
    "status": "PROCESSING",
    "downloadUrl": null,
    "estimatedTime": 30
  }
}

// 查询导出任务状态
GET /api/v1/reports/export/task/{taskId}

响应:
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "taskId": "EXPORT20250116001",
    "status": "COMPLETED",
    "downloadUrl": "https://qms.shunfu.com/api/v1/reports/download/EXPORT20250116001",
    "fileName": "检验汇总报表_20250101-20250131.xlsx",
    "fileSize": 1048576,
    "createTime": "2025-01-16T10:00:00Z",
    "completeTime": "2025-01-16T10:00:30Z"
  }
}
\`\`\`

---

## 6. 消息通知API

### 6.1 创建消息通知

\`\`\`
POST /api/v1/notifications

请求体:
{
  "notificationType": "CHANGE_POINT_APPROVAL",
  "title": "变化点待审批",
  "content": "您有一个变化点(CP202501001)需要审批,请及时处理",
  "priority": "HIGH",
  "targetUsers": [1001, 1002],
  "targetRoles": ["QUALITY_MANAGER", "DEPT_MANAGER"],
  "businessType": "CHANGE_POINT",
  "businessId": 10001,
  "actionUrl": "/change-points/10001/approval",
  "expireTime": "2025-01-17T10:00:00Z"
}

响应:
{
  "code": 200,
  "message": "通知创建成功",
  "data": {
    "notificationId": 90001,
    "sentTime": "2025-01-16T10:00:00Z",
    "targetUserCount": 2,
    "sentChannels": ["SYSTEM", "EMAIL", "SMS"]
  }
}
\`\`\`

### 6.2 查询消息列表

\`\`\`
GET /api/v1/notifications?page=1&pageSize=20&status=UNREAD&priority=HIGH

响应:
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "items": [
      {
        "notificationId": 90001,
        "notificationType": "CHANGE_POINT_APPROVAL",
        "title": "变化点待审批",
        "content": "您有一个变化点(CP202501001)需要审批,请及时处理",
        "priority": "HIGH",
        "readStatus": "UNREAD",
        "createTime": "2025-01-16T10:00:00Z",
        "actionUrl": "/change-points/10001/approval",
        "businessType": "CHANGE_POINT",
        "businessId": 10001
      }
    ],
    "total": 5,
    "page": 1,
    "pageSize": 20,
    "totalPages": 1
  }
}
\`\`\`

---

## 7. API安全策略

### 7.1 认证机制

| 认证方式 | 使用场景 | 说明 |
|---------|---------|------|
| JWT Token | 所有API调用 | 访问令牌,有效期2小时 |
| Refresh Token | 刷新访问令牌 | 有效期7天 |
| API Key | 系统间集成 | 固定密钥,用于ERP/MES等系统调用 |

### 7.2 签名验证

对于关键API,使用签名验证:

\`\`\`
签名算法: HMAC-SHA256
签名参数: timestamp + requestId + requestBody (按字典序排序)
签名密钥: 每个系统分配独立密钥

签名生成:
signature = HMAC-SHA256(apiSecret, timestamp + requestId + sortedParams)
\`\`\`

### 7.3 限流策略

| 限流维度 | 限制策略 | 说明 |
|---------|---------|------|
| IP限流 | 1000次/分钟 | 防止恶意攻击 |
| 用户限流 | 100次/分钟 | 防止滥用 |
| 系统限流 | 10000次/分钟 | 整体负载保护 |

### 7.4 权限控制

\`\`\`
权限控制模型: RBAC + 数据权限

API注解示例:
@PreAuthorize("hasRole('QUALITY_MANAGER')")
@PreAuthorize("hasPermission(#changeId, 'CHANGE_POINT_APPROVE')")
@DataPermission(scopeType = "DEPT_AND_CHILD", deptIdField = "departmentId")
\`\`\`

---

## 8. API文档规范

### 8.1 OpenAPI 3.0规范

所有API遵循OpenAPI 3.0规范,自动生成API文档。

\`\`\`
访问地址: https://qms.shunfu.com/api/docs
Swagger UI: https://qms.shunfu.com/api/swagger-ui.html
\`\`\`

### 8.2 API版本控制

采用URL路径版本控制:

\`\`\`
/api/v1/... - 当前版本
/api/v2/... - 未来版本
\`\`\`

版本兼容性策略:
- v1版本至少维护1年
- v2版本必须向后兼容v1的核心API
- 废弃API提前3个月通知

---

## 9. API测试规范

### 9.1 单元测试

所有API必须编写单元测试:

\`\`\`java
@SpringBootTest
@AutoConfigureMockMvc
class ChangePointControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void testCreateChangePoint() throws Exception {
        mockMvc.perform(post("/api/v1/change-points")
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                {
                    "changeTitle": "铝压铸模具更换",
                    "changeType": "MACHINE",
                    "changeDescription": "测试变化点"
                }
                """))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(200))
                .andExpect(jsonPath("$.data.changeNumber").exists());
    }
}
\`\`\`

### 9.2 集成测试

关键业务流程编写集成测试:

\`\`\`java
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
class QRQCFastResponseTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void testQRQCCompleteFlow() throws Exception {
        // 1. 创建QRQC事件
        // 2. 组建团队
        // 3. 现场调查
        // 4. 实施围堵
        // 5. 验证24小时响应
    }
}
\`\`\`

---

## 10. API监控与告警

### 10.1 监控指标

| 指标 | 阈值 | 告警级别 |
|-----|------|---------|
| 响应时间 | >3秒 | WARNING |
| 响应时间 | >10秒 | CRITICAL |
| 错误率 | >1% | WARNING |
| 错误率 | >5% | CRITICAL |
| QPS | >1000 | WARNING |
| QPS | >5000 | CRITICAL |

### 10.2 日志记录

所有API调用记录详细日志:

\`\`\`
日志级别: INFO
日志格式: [timestamp] [traceId] [userId] [method] [url] [params] [responseCode] [duration]
日志存储: Elasticsearch + Kibana
日志保留: 90天
\`\`\`

---

## 总结

本API设计规范为舜富QMS系统提供了完整的接口定义,包括:

1. **认证授权**: 登录、Token刷新、权限获取
2. **核心业务**: 变化点、CAPA、QRQC等11个核心模块的完整API
3. **系统集成**: ERP/MES/SRM/WMS/CRM 5大系统的集成接口
4. **辅助功能**: 文件管理、报表导出、消息通知
5. **安全策略**: 认证、签名、限流、权限控制
6. **测试规范**: 单元测试、集成测试
7. **监控告警**: 监控指标、日志记录

所有API遵循RESTful设计原则,采用统一响应格式,支持版本控制,提供完整的OpenAPI文档。
`,Jn=`# 舜富QMS系统 - 文档管理模块详细实现规范

## 1. 模块概述

### 1.1 功能定位
文档管理模块是舜富QMS系统的核心基础模块，负责所有质量相关文档的全生命周期管理，确保文档的规范性、可追溯性和合规性，满足IATF16949:2016标准对文档管理的要求。

### 1.2 业务价值
- **合规保障**: 确保所有质量文档符合IATF16949:2016标准要求
- **版本控制**: 实现文档版本的全生命周期管理
- **高效检索**: 提供智能化的文档搜索和定位功能
- **协作管理**: 支持多部门协作的文档审批和发布流程
- **知识沉淀**: 构建企业质量知识库，促进经验积累和复用

### 1.3 技术架构
- **前端**: Vue.js 3.x + Element Plus + 自定义文档编辑器
- **后端**: Spring Boot 3.x + Spring Security + MinIO/OSS
- **数据库**: PostgreSQL (元数据) + MongoDB (文档内容) + Elasticsearch (全文检索)
- **搜索**: Elasticsearch 8.x + IK分词器
- **存储**: MinIO分布式对象存储或阿里云OSS

## 2. 核心功能详细设计

### 2.1 文档分类管理

#### 2.1.1 多级分类体系
\`\`\`java
// 文档分类实体
@Entity
@Table(name = "qms_document_category")
@Data
public class DocumentCategory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(length = 500)
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private DocumentCategory parent;
    
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<DocumentCategory> children;
    
    @Column(nullable = false)
    private Integer level;
    
    @Column(nullable = false)
    private Integer sortOrder;
    
    @Column(nullable = false)
    private Boolean active = true;
    
    @Column(nullable = false)
    private String documentType; // PROCEDURE, WORK_INSTRUCTION, FORM, RECORD, STANDARD
}
\`\`\`

#### 2.1.2 分类管理API
\`\`\`java
@RestController
@RequestMapping("/api/document-categories")
@Tag(name = "文档分类管理", description = "文档分类的增删改查管理")
public class DocumentCategoryController {
    
    @PostMapping
    @Operation(summary = "创建文档分类")
    public ResponseEntity<DocumentCategoryDTO> createCategory(
            @Valid @RequestBody DocumentCategoryCreateDTO dto) {
        // 实现分类创建逻辑
    }
    
    @PutMapping("/{id}")
    @Operation(summary = "更新文档分类")
    public ResponseEntity<DocumentCategoryDTO> updateCategory(
            @PathVariable Long id, @Valid @RequestBody DocumentCategoryUpdateDTO dto) {
        // 实现分类更新逻辑
    }
    
    @DeleteMapping("/{id}")
    @Operation(summary = "删除文档分类")
    public ResponseEntity<Void> deleteCategory(@PathVariable Long id) {
        // 实现分类删除逻辑（包含子分类检查）
    }
    
    @GetMapping("/tree")
    @Operation(summary = "获取分类树结构")
    public ResponseEntity<List<CategoryTreeNodeDTO>> getCategoryTree() {
        // 返回完整的分类树结构
    }
}
\`\`\`

### 2.2 文档全生命周期管理

#### 2.2.1 文档生命周期状态机
\`\`\`java
// 文档状态枚举
public enum DocumentStatus {
    DRAFT("草稿"),
    REVIEW("审核中"),
    APPROVED("已批准"),
    PUBLISHED("已发布"),
    REVOKED("已撤销"),
    OBSOLETE("已过期"),
    ARCHIVED("已归档");

    private final String description;

    DocumentStatus(String description) {
        this.description = description;
    }
}

// 文档实体
@Entity
@Table(name = "qms_document")
@Data
public class Document {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String title;
    
    @Column(length = 1000)
    private String summary;
    
    @Column(nullable = false)
    private String documentCode; // QMS-DOC-2024-001
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private DocumentCategory category;
    
    @Column(nullable = false)
    private String documentType;
    
    @Column(nullable = false)
    private DocumentStatus status;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", nullable = false)
    private User author;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "approver_id")
    private User approver;
    
    @Column(nullable = false)
    private LocalDateTime publishDate;
    
    @Column(nullable = false)
    private LocalDateTime reviewDeadline;
    
    @Column(nullable = false)
    private Integer version;
    
    @Column(nullable = false)
    private String fileUrl;
    
    @Column(nullable = false)
    private Long fileSize;
    
    @Column(nullable = false)
    private String fileType;
    
    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL)
    private List<DocumentVersion> versions;
    
    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL)
    private List<DocumentAuditLog> auditLogs;
}
\`\`\`

#### 2.2.2 生命周期管理核心逻辑
\`\`\`java
@Service
@RequiredArgsConstructor
public class DocumentLifecycleService {
    
    private final DocumentRepository documentRepository;
    private final AuditLogRepository auditLogRepository;
    private final NotificationService notificationService;
    
    /**
     * 提交文档审核
     */
    @Transactional
    public void submitForReview(Long documentId) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        // 验证文档状态
        if (document.getStatus() != DocumentStatus.DRAFT) {
            throw new IllegalStateException("Only draft documents can be submitted for review");
        }
        
        // 更新状态
        document.setStatus(DocumentStatus.REVIEW);
        document.setReviewDeadline(LocalDateTime.now().plusDays(3)); // 3天审核期限
        
        // 创建审核流程
        createReviewWorkflow(document);
        
        // 通知审核人员
        notifyReviewers(document);
        
        documentRepository.save(document);
    }
    
    /**
     * 批准文档
     */
    @Transactional
    public void approveDocument(Long documentId, String approverComment) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        // 验证审核状态
        if (document.getStatus() != DocumentStatus.REVIEW) {
            throw new IllegalStateException("Only documents in review status can be approved");
        }
        
        // 创建新版本
        DocumentVersion newVersion = createNewVersion(document);
        
        // 更新文档状态
        document.setStatus(DocumentStatus.APPROVED);
        document.setApprover(SecurityUtils.getCurrentUser());
        document.setPublishDate(LocalDateTime.now());
        
        // 记录审核日志
        auditLogRepository.save(DocumentAuditLog.builder()
            .document(document)
            .action("APPROVE")
            .user(SecurityUtils.getCurrentUser())
            .comment(approverComment)
            .timestamp(LocalDateTime.now())
            .build());
        
        // 发布通知
        notificationService.sendDocumentApprovedNotification(document);
        
        documentRepository.save(document);
    }
    
    /**
     * 撤销文档
     */
    @Transactional
    public void revokeDocument(Long documentId, String reason) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        if (document.getStatus() != DocumentStatus.PUBLISHED && 
            document.getStatus() != DocumentStatus.APPROVED) {
            throw new IllegalStateException("Only published or approved documents can be revoked");
        }
        
        // 创建替代文档
        Document replacement = createReplacementDocument(document);
        
        // 更新原文档状态
        document.setStatus(DocumentStatus.REVOKED);
        documentRepository.save(document);
        
        // 启动替代文档流程
        submitDocumentForReview(replacement);
        
        // 发送通知
        notificationService.sendDocumentRevokedNotification(document, replacement, reason);
    }
}
\`\`\`

### 2.3 版本控制管理

#### 2.3.1 版本控制实体
\`\`\`java
@Entity
@Table(name = "qms_document_version")
@Data
public class DocumentVersion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "document_id", nullable = false)
    private Document document;
    
    @Column(nullable = false)
    private Integer version;
    
    @Column(nullable = false)
    private String versionDescription;
    
    @Column(nullable = false)
    private LocalDateTime createTime;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "creator_id", nullable = false)
    private User creator;
    
    @Column(nullable = false)
    private String fileUrl;
    
    @Column(nullable = false)
    private Long fileSize;
    
    @Column(nullable = false)
    private String fileType;
    
    @Column
    private String changeLog;
    
    @PrePersist
    protected void onCreate() {
        createTime = LocalDateTime.now();
    }
}
\`\`\`

#### 2.3.2 版本控制服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class DocumentVersionService {
    
    private final DocumentVersionRepository versionRepository;
    private final FileStorageService fileStorageService;
    private final DocumentRepository documentRepository;
    
    /**
     * 创建新版本
     */
    @Transactional
    public DocumentVersion createNewVersion(Document document, MultipartFile file, String changeLog) {
        // 获取最新版本号
        Integer latestVersion = versionRepository.findLatestVersion(document.getId())
            .orElse(0);
        
        Integer newVersion = latestVersion + 1;
        
        // 上传文件
        String fileUrl = fileStorageService.uploadDocument(file, document.getDocumentCode(), newVersion);
        
        // 创建版本记录
        DocumentVersion version = DocumentVersion.builder()
            .document(document)
            .version(newVersion)
            .versionDescription("Version " + newVersion)
            .creator(SecurityUtils.getCurrentUser())
            .fileUrl(fileUrl)
            .fileSize(file.getSize())
            .fileType(file.getContentType())
            .changeLog(changeLog)
            .build();
        
        versionRepository.save(version);
        
        // 更新文档主记录
        document.setVersion(newVersion);
        document.setFileUrl(fileUrl);
        document.setFileSize(file.getSize());
        document.setFileType(file.getContentType());
        documentRepository.save(document);
        
        return version;
    }
    
    /**
     * 比较版本差异
     */
    public VersionDiffResult compareVersions(Long documentId, Integer version1, Integer version2) {
        List<DocumentVersion> versions = versionRepository.findByDocumentIdAndVersionIn(
            documentId, List.of(version1, version2));
        
        if (versions.size() != 2) {
            throw new IllegalArgumentException("Versions not found");
        }
        
        // 实现文件内容比较逻辑
        return fileStorageService.compareDocumentFiles(
            versions.get(0).getFileUrl(), 
            versions.get(1).getFileUrl());
    }
    
    /**
     * 回滚到指定版本
     */
    @Transactional
    public void rollbackToVersion(Long documentId, Integer targetVersion) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        DocumentVersion target = versionRepository.findByDocumentIdAndVersion(documentId, targetVersion)
            .orElseThrow(() -> new EntityNotFoundException("Target version not found"));
        
        // 创建新版本作为回滚版本
        createNewVersion(document, target.getFileUrl(), "Rollback from version " + document.getVersion() + " to " + targetVersion);
        
        // 更新文档状态
        document.setStatus(DocumentStatus.DRAFT);
        documentRepository.save(document);
    }
}
\`\`\`

### 2.4 文档审批工作流

#### 2.4.1 审批流程配置
\`\`\`java
@Entity
@Table(name = "qms_workflow_definition")
@Data
public class WorkflowDefinition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String workflowName;
    
    @Column(nullable = false)
    private String workflowCode;
    
    @Column(nullable = false)
    private String description;
    
    @ElementCollection
    @CollectionTable(name = "qms_workflow_steps")
    private List<WorkflowStep> steps = new ArrayList<>();
    
    @Column(nullable = false)
    private Boolean active = true;
}

@Entity
@Table(name = "qms_workflow_steps")
@Data
@Embeddable
public class WorkflowStep {
    @Column(nullable = false)
    private Integer stepOrder;
    
    @Column(nullable = false, length = 100)
    private String stepName;
    
    @Column(nullable = false, length = 20)
    private String stepType; // APPROVAL, REVIEW, NOTIFICATION
    
    @Column(nullable = false)
    private Integer approverRole; // 1-一级审核, 2-二级审核, 3-三级审核
    
    @Column(nullable = false)
    private Boolean required = true;
    
    @Column(nullable = false)
    private Integer maxDuration; // 最大审批时长(小时)
    
    @Column
    private String conditionalLogic;
}
\`\`\`

#### 2.4.2 审批流程执行
\`\`\`java
@Service
@RequiredArgsConstructor
public DocumentApprovalService {
    
    private final WorkflowEngine workflowEngine;
    private final NotificationService notificationService;
    private final AuditLogRepository auditLogRepository;
    
    /**
     * 启动文档审批流程
     */
    @Transactional
    public WorkflowInstance startDocumentApproval(Long documentId) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        // 获取审批流程定义
        WorkflowDefinition workflow = getWorkflowByDocumentType(document.getDocumentType());
        
        // 启动工作流
        WorkflowInstance instance = workflowEngine.startWorkflow(
            workflow, 
            Map.of("documentId", documentId)
        );
        
        // 发送第一个审批任务
        assignFirstApprovalTask(instance);
        
        return instance;
    }
    
    /**
     * 处理审批任务
     */
    @Transactional
    public void processApprovalTask(Long taskId, ApprovalDecision decision, String comment) {
        WorkflowTask task = workflowEngine.getTask(taskId);
        
        // 记录审批日志
        auditLogRepository.save(DocumentAuditLog.builder()
            .document(documentRepository.findById(task.getVariables().get("documentId"))
                .orElseThrow(() -> new EntityNotFoundException("Document not found")))
            .action("APPROVAL_" + decision)
            .user(SecurityUtils.getCurrentUser())
            .comment(comment)
            .timestamp(LocalDateTime.now())
            .build());
        
        // 处理审批决定
        if (decision == ApprovalDecision.APPROVE) {
            workflowEngine.completeTask(taskId, Map.of("decision", "APPROVE"));
        } else {
            workflowEngine.completeTask(taskId, Map.of("decision", "REJECT", "comment", comment));
            
            // 发送拒绝通知
            notificationService.sendDocumentRejectedNotification(
                task.getVariables().get("documentId"), 
                comment);
        }
        
        // 分配下一个审批任务
        assignNextApprovalTask(task.getInstanceId());
    }
}
\`\`\`

### 2.5 智能文档管理

#### 2.5.1 文档标签管理
\`\`\`java
@Entity
@Table(name = "qms_document_tag")
@Data
public class DocumentTag {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 50)
    private String tagName;
    
    @Column(nullable = false, length = 200)
    private String tagDescription;
    
    @Column(nullable = false)
    private String tagColor;
    
    @ManyToMany(mappedBy = "tags")
    private Set<Document> documents = new HashSet<>();
}

@Entity
@Table(name = "qms_document_tagging")
@Data
public class DocumentTagging {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "document_id", nullable = false)
    private Document document;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tag_id", nullable = false)
    private DocumentTag tag;
    
    @Column(nullable = false)
    private LocalDateTime taggedAt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tagged_by")
    private User taggedBy;
}
\`\`\`

#### 2.5.2 智能标签推荐
\`\`\`java
@Service
@RequiredArgsConstructor
public class IntelligentTaggingService {
    
    private final DocumentRepository documentRepository;
    private final TaggingModelService taggingModelService;
    private final ElasticsearchTemplate elasticsearchTemplate;
    
    /**
     * 基于内容的智能标签推荐
     */
    public List<DocumentTag> recommendTags(Long documentId) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        // 提取文档内容
        String content = extractDocumentContent(document);
        
        // 使用机器学习模型推荐标签
        List<String> recommendedTagNames = taggingModelService.predictTags(content);
        
        // 获取标签实体
        return documentRepository.findTagsByNameIn(recommendedTagNames);
    }
    
    /**
     * 自动标签化
     */
    @Transactional
    public void autoTagDocument(Long documentId) {
        List<DocumentTag> recommendedTags = recommendTags(documentId);
        
        if (!recommendedTags.isEmpty()) {
            Document document = documentRepository.findById(documentId)
                .orElseThrow(() -> new EntityNotFoundException("Document not found"));
            
            // 自动应用推荐标签
            for (DocumentTag tag : recommendedTags) {
                if (!document.getTags().contains(tag)) {
                    document.getTags().add(tag);
                }
            }
            
            documentRepository.save(document);
        }
    }
    
    /**
     * 文档内容提取
     */
    private String extractDocumentContent(Document document) {
        try {
            // 从文件存储获取文档内容
            String fileUrl = document.getFileUrl();
            byte[] content = fileStorageService.downloadFile(fileUrl);
            
            // 根据文件类型解析内容
            return DocumentContentExtractor.extract(content, document.getFileType());
        } catch (Exception e) {
            log.error("Failed to extract document content", e);
            return "";
        }
    }
}
\`\`\`

### 2.6 文档检索系统

#### 2.6.1 Elasticsearch索引配置
\`\`\`java
@Configuration
@EnableElasticsearchRepositories(basePackages = "com.shunfu.qms.repository.search")
public class ElasticsearchConfig {
    
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        RestHighLevelClient client = new RestHighLevelClient(
            RestClient.builder(
                new HttpHost("localhost", 9200, "http"))
        );
        return client;
    }
}

@Document(indexName = "qms_documents")
@Data
public class DocumentSearchDocument {
    
    @Id
    private String id;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String title;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String summary;
    
    @Field(type = FieldType.Keyword)
    private String documentCode;
    
    @Field(type = FieldType.Keyword)
    private String documentType;
    
    @Field(type = FieldType.Keyword)
    private String categoryPath;
    
    @Field(type = FieldType.Date, format = DateFormat.date_time)
    private LocalDateTime publishDate;
    
    @Field(type = FieldType.Keyword)
    private String authorName;
    
    @Field(type = FieldType.Keyword)
    private String status;
    
    @Field(type = FieldType.Keyword)
    private List<String> tags;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String content;
    
    @Field(type = FieldType.Keyword)
    private List<String> departments;
}
\`\`\`

#### 2.6.2 高级检索服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class DocumentSearchService {
    
    private final DocumentSearchRepository searchRepository;
    private final UserRepository userRepository;
    
    /**
     * 全文检索
     */
    public Page<DocumentSearchResult> fullTextSearch(String keyword, Pageable pageable) {
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder()
            .withQuery(QueryBuilders.multiMatchQuery(keyword)
                .field("title", 3.0f)
                .field("summary", 2.0f)
                .field("content", 1.0f)
                .field("documentCode", 2.0f))
            .withPageable(pageable);
        
        SearchHits<DocumentSearchDocument> searchHits = 
            elasticsearchTemplate.search(queryBuilder.build(), DocumentSearchDocument.class);
        
        return convertToSearchResultPage(searchHits, pageable);
    }
    
    /**
     * 高级检索
     */
    public Page<DocumentSearchResult> advancedSearch(DocumentSearchCriteria criteria, Pageable pageable) {
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // 关键词搜索
        if (StringUtils.hasText(criteria.getKeyword())) {
            boolQuery.must(QueryBuilders.multiMatchQuery(criteria.getKeyword())
                .field("title", 3.0f)
                .field("summary", 2.0f)
                .field("content", 1.0f));
        }
        
        // 文档类型过滤
        if (StringUtils.hasText(criteria.getDocumentType())) {
            boolQuery.filter(QueryBuilders.termQuery("documentType", criteria.getDocumentType()));
        }
        
        // 分类过滤
        if (StringUtils.hasText(criteria.getCategory())) {
            boolQuery.filter(QueryBuilders.termQuery("categoryPath", criteria.getCategory()));
        }
        
        // 状态过滤
        if (criteria.getStatus() != null && !criteria.getStatus().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("status", criteria.getStatus()));
        }
        
        // 日期范围过滤
        if (criteria.getStartDate() != null && criteria.getEndDate() != null) {
            boolQuery.filter(QueryBuilders.rangeQuery("publishDate")
                .gte(criteria.getStartDate())
                .lte(criteria.getEndDate()));
        }
        
        // 标签过滤
        if (criteria.getTags() != null && !criteria.getTags().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("tags", criteria.getTags()));
        }
        
        // 部门过滤
        if (criteria.getDepartments() != null && !criteria.getDepartments().isEmpty()) {
            boolQuery.filter(QueryBuilders.termsQuery("departments", criteria.getDepartments()));
        }
        
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder()
            .withQuery(boolQuery)
            .withPageable(pageable);
        
        SearchHits<DocumentSearchDocument> searchHits = 
            elasticsearchTemplate.search(queryBuilder.build(), DocumentSearchDocument.class);
        
        return convertToSearchResultPage(searchHits, pageable);
    }
    
    /**
     * 相关文档推荐
     */
    public List<DocumentSearchDocument> findRelatedDocuments(Long documentId, int limit) {
        DocumentSearchDocument sourceDoc = searchRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        // 基于相似度推荐
        MoreLikeThisQueryBuilder queryBuilder = QueryBuilders.moreLikeThisQuery(
            new MoreLikeThisQueryBuilder.Item[] {
                new MoreLikeThisQueryBuilder.Item("qms_documents", documentId.toString())
            })
            .minTermFreq(1)
            .minDocFreq(1)
            .maxQueryTerms(25);
        
        NativeSearchQueryBuilder searchBuilder = new NativeSearchQueryBuilder()
            .withQuery(queryBuilder)
            .withPageable(PageRequest.of(0, limit));
        
        SearchHits<DocumentSearchDocument> searchHits = 
            elasticsearchTemplate.search(searchBuilder.build(), DocumentSearchDocument.class);
        
        return searchHits.getSearchHits().stream()
            .map(SearchHit::getContent)
            .collect(Collectors.toList());
    }
}
\`\`\`

### 2.7 权限与安全管理

#### 2.7.1 文档权限控制
\`\`\`java
@Entity
@Table(name = "qms_document_permission")
@Data
public class DocumentPermission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "document_id", nullable = false)
    private Document document;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "role_id")
    private Role role;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
    
    @Column(nullable = false)
    private String permission; // READ, WRITE, APPROVE, ADMIN
    
    @Column(nullable = false)
    private LocalDateTime grantedAt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "granted_by")
    private User grantedBy;
    
    @Column(nullable = false)
    private Boolean active = true;
}

@Service
@RequiredArgsConstructor
public class DocumentPermissionService {
    
    private final DocumentPermissionRepository permissionRepository;
    private final DocumentRepository documentRepository;
    
    /**
     * 检查文档权限
     */
    public boolean checkPermission(Long documentId, String permission) {
        SecurityContext context = SecurityContextHolder.getContext();
        Authentication authentication = context.getAuthentication();
        
        // 超级管理员拥有所有权限
        if (authentication.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
            return true;
        }
        
        // 检查用户直接权限
        boolean userPermission = permissionRepository.existsByDocumentIdAndUserIdAndPermissionAndActive(
            documentId, SecurityUtils.getCurrentUserId(), permission, true);
        
        if (userPermission) {
            return true;
        }
        
        // 检查角色权限
        boolean rolePermission = permissionRepository.existsByDocumentIdAndRoleNameAndPermissionAndActive(
            documentId, SecurityUtils.getCurrentRoleName(), permission, true);
        
        if (rolePermission) {
            return true;
        }
        
        // 检查部门权限
        boolean departmentPermission = permissionRepository.existsByDocumentIdAndDepartmentIdAndPermissionAndActive(
            documentId, SecurityUtils.getCurrentDepartmentId(), permission, true);
        
        return departmentPermission;
    }
    
    /**
     * 授权文档访问
     */
    @Transactional
    public void grantDocumentPermission(Long documentId, DocumentPermissionGrantDTO dto) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        
        DocumentPermission permission = DocumentPermission.builder()
            .document(document)
            .user(dto.getUserId() != null ? userRepository.findById(dto.getUserId()).orElse(null) : null)
            .role(dto.getRoleId() != null ? roleRepository.findById(dto.getRoleId()).orElse(null) : null)
            .department(dto.getDepartmentId() != null ? departmentRepository.findById(dto.getDepartmentId()).orElse(null) : null)
            .permission(dto.getPermission())
            .grantedAt(LocalDateTime.now())
            .grantedBy(SecurityUtils.getCurrentUser())
            .active(true)
            .build();
        
        permissionRepository.save(permission);
    }
}
\`\`\`

## 3. 技术实现规范

### 3.1 数据库设计

#### 3.1.1 核心表结构
\`\`\`sql
-- 文档分类表
CREATE TABLE qms_document_category (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description VARCHAR(500),
    parent_id BIGINT,
    level INTEGER NOT NULL,
    sort_order INTEGER NOT NULL,
    active BOOLEAN NOT NULL DEFAULT true,
    document_type VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES qms_document_category(id)
);

-- 文档主表
CREATE TABLE qms_document (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    summary VARCHAR(1000),
    document_code VARCHAR(50) NOT NULL UNIQUE,
    category_id BIGINT NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,
    author_id BIGINT NOT NULL,
    approver_id BIGINT,
    publish_date TIMESTAMP,
    review_deadline TIMESTAMP NOT NULL,
    version INTEGER NOT NULL DEFAULT 1,
    file_url VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES qms_document_category(id),
    FOREIGN KEY (author_id) REFERENCES qms_user(id),
    FOREIGN KEY (approver_id) REFERENCES qms_user(id)
);

-- 文档版本表
CREATE TABLE qms_document_version (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    version INTEGER NOT NULL,
    version_description VARCHAR(500) NOT NULL,
    create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    creator_id BIGINT NOT NULL,
    file_url VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    change_log TEXT,
    FOREIGN KEY (document_id) REFERENCES qms_document(id),
    FOREIGN KEY (creator_id) REFERENCES qms_user(id)
);

-- 文档标签表
CREATE TABLE qms_document_tag (
    id BIGSERIAL PRIMARY KEY,
    tag_name VARCHAR(50) NOT NULL UNIQUE,
    tag_description VARCHAR(200) NOT NULL,
    tag_color VARCHAR(20) NOT NULL DEFAULT '#007bff',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 文档标签关联表
CREATE TABLE qms_document_tagging (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    tag_id BIGINT NOT NULL,
    tagged_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    tagged_by BIGINT,
    FOREIGN KEY (document_id) REFERENCES qms_document(id),
    FOREIGN KEY (tag_id) REFERENCES qms_document_tag(id),
    FOREIGN KEY (tagged_by) REFERENCES qms_user(id),
    UNIQUE(document_id, tag_id)
);

-- 文档权限表
CREATE TABLE qms_document_permission (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    user_id BIGINT,
    role_id BIGINT,
    department_id BIGINT,
    permission VARCHAR(20) NOT NULL,
    granted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    granted_by BIGINT,
    active BOOLEAN NOT NULL DEFAULT true,
    FOREIGN KEY (document_id) REFERENCES qms_document(id),
    FOREIGN KEY (user_id) REFERENCES qms_user(id),
    FOREIGN KEY (role_id) REFERENCES qms_role(id),
    FOREIGN KEY (department_id) REFERENCES qms_department(id),
    FOREIGN KEY (granted_by) REFERENCES qms_user(id),
    UNIQUE(document_id, user_id, permission, active)
);

-- 文档审核日志表
CREATE TABLE qms_document_audit_log (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    action VARCHAR(50) NOT NULL,
    user_id BIGINT NOT NULL,
    comment TEXT,
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    details JSONB,
    FOREIGN KEY (document_id) REFERENCES qms_document(id),
    FOREIGN KEY (user_id) REFERENCES qms_user(id)
);
\`\`\`

### 3.2 API接口规范

#### 3.2.1 文档管理API
\`\`\`java
@RestController
@RequestMapping("/api/documents")
@Tag(name = "文档管理", description = "文档的增删改查管理")
@RequiredArgsConstructor
public class DocumentController {
    
    private final DocumentService documentService;
    private final DocumentSearchService searchService;
    
    /**
     * 创建文档
     */
    @PostMapping
    @Operation(summary = "创建新文档")
    @PreAuthorize("hasRole('DOCUMENT_CREATE')")
    public ResponseEntity<DocumentDTO> createDocument(
            @Valid @RequestBody DocumentCreateDTO dto,
            @RequestParam("file") MultipartFile file) {
        DocumentDTO result = documentService.createDocument(dto, file);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
    
    /**
     * 更新文档
     */
    @PutMapping("/{id}")
    @Operation(summary = "更新文档信息")
    @PreAuthorize("hasRole('DOCUMENT_UPDATE')")
    public ResponseEntity<DocumentDTO> updateDocument(
            @PathVariable Long id,
            @Valid @RequestBody DocumentUpdateDTO dto) {
        DocumentDTO result = documentService.updateDocument(id, dto);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 删除文档
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "删除文档")
    @PreAuthorize("hasRole('DOCUMENT_DELETE')")
    public ResponseEntity<Void> deleteDocument(@PathVariable Long id) {
        documentService.deleteDocument(id);
        return ResponseEntity.noContent().build();
    }
    
    /**
     * 获取文档详情
     */
    @GetMapping("/{id}")
    @Operation(summary = "获取文档详情")
    public ResponseEntity<DocumentDetailDTO> getDocument(@PathVariable Long id) {
        DocumentDetailDTO result = documentService.getDocumentDetail(id);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 文档全文检索
     */
    @GetMapping("/search")
    @Operation(summary = "全文检索文档")
    public ResponseEntity<Page<DocumentSearchResult>> searchDocuments(
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) String documentType,
            @RequestParam(required = false) String category,
            @RequestParam(required = false) List<String> status,
            @RequestParam(required = false) LocalDate startDate,
            @RequestParam(required = false) LocalDate endDate,
            @RequestParam(required = false) List<String> tags,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        DocumentSearchCriteria criteria = DocumentSearchCriteria.builder()
            .keyword(keyword)
            .documentType(documentType)
            .category(category)
            .status(status)
            .startDate(startDate)
            .endDate(endDate)
            .tags(tags)
            .build();
        
        Page<DocumentSearchResult> result = searchService.advancedSearch(criteria, PageRequest.of(page, size));
        return ResponseEntity.ok(result);
    }
    
    /**
     * 获取文档历史版本
     */
    @GetMapping("/{id}/versions")
    @Operation(summary = "获取文档版本历史")
    public ResponseEntity<List<DocumentVersionDTO>> getDocumentVersions(@PathVariable Long id) {
        List<DocumentVersionDTO> result = documentService.getDocumentVersions(id);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 上传文档附件
     */
    @PostMapping("/{id}/attachments")
    @Operation(summary = "上传文档附件")
    @PreAuthorize("hasRole('DOCUMENT_UPDATE')")
    public ResponseEntity<DocumentAttachmentDTO> uploadAttachment(
            @PathVariable Long id,
            @RequestParam("file") MultipartFile file) {
        DocumentAttachmentDTO result = documentService.uploadAttachment(id, file);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
}
\`\`\`

#### 3.2.2 审批流程API
\`\`\`java
@RestController
@RequestMapping("/api/document-approvals")
@Tag(name = "文档审批", description = "文档审批流程管理")
@RequiredArgsConstructor
public class DocumentApprovalController {
    
    private final DocumentApprovalService approvalService;
    
    /**
     * 提交文档审核
     */
    @PostMapping("/{documentId}/submit")
    @Operation(summary = "提交文档审核")
    @PreAuthorize("hasRole('DOCUMENT_APPROVE')")
    public ResponseEntity<WorkflowInstanceDTO> submitForReview(@PathVariable Long documentId) {
        WorkflowInstanceDTO result = approvalService.startDocumentApproval(documentId);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
    
    /**
     * 获取待处理审批任务
     */
    @GetMapping("/tasks/pending")
    @Operation(summary = "获取待处理审批任务")
    public ResponseEntity<List<ApprovalTaskDTO>> getPendingTasks() {
        List<ApprovalTaskDTO> result = approvalService.getPendingTasks(SecurityUtils.getCurrentUserId());
        return ResponseEntity.ok(result);
    }
    
    /**
     * 处理审批任务
     */
    @PostMapping("/tasks/{taskId}/process")
    @Operation(summary = "处理审批任务")
    public ResponseEntity<Void> processApprovalTask(
            @PathVariable Long taskId,
            @Valid @RequestBody ApprovalProcessDTO dto) {
        approvalService.processApprovalTask(taskId, dto.getDecision(), dto.getComment());
        return ResponseEntity.ok().build();
    }
    
    /**
     * 获取审批流程详情
     */
    @GetMapping("/instances/{instanceId}")
    @Operation(summary = "获取审批流程详情")
    public ResponseEntity<WorkflowInstanceDTO> getApprovalInstance(@PathVariable String instanceId) {
        WorkflowInstanceDTO result = approvalService.getWorkflowInstance(instanceId);
        return ResponseEntity.ok(result);
    }
}
\`\`\`

### 3.3 前端界面设计

#### 3.3.1 文档管理界面
\`\`\`vue
<!-- 文档管理主界面 -->
<template>
  <div class="document-management">
    <!-- 搜索栏 -->
    <div class="search-bar">
      <el-input
        v-model="searchForm.keyword"
        placeholder="搜索文档标题、编号、内容..."
        prefix-icon="Search"
        @keyup.enter="handleSearch"
      />
      <el-button type="primary" @click="handleSearch">搜索</el-button>
      <el-button @click="showAdvancedSearch = true">高级搜索</el-button>
    </div>
    
    <!-- 分类导航 -->
    <div class="category-nav">
      <el-tree
        :data="categoryTree"
        :props="categoryProps"
        @node-click="handleCategorySelect"
        :highlight-current="true"
      />
    </div>
    
    <!-- 文档列表 -->
    <div class="document-list">
      <div v-for="doc in documentList" :key="doc.id" class="document-item">
        <div class="document-header">
          <h3>{{ doc.title }}</h3>
          <span :class="['status-badge', doc.status]">{{ doc.statusText }}</span>
        </div>
        <div class="document-info">
          <p>{{ doc.summary }}</p>
          <div class="document-meta">
            <span>编号: {{ doc.documentCode }}</span>
            <span>版本: v{{ doc.version }}</span>
            <span>作者: {{ doc.authorName }}</span>
            <span>发布时间: {{ formatDate(doc.publishDate) }}</span>
          </div>
          <div class="document-tags">
            <el-tag
              v-for="tag in doc.tags"
              :key="tag.id"
              :color="tag.tagColor"
              size="small"
            >
              {{ tag.tagName }}
            </el-tag>
          </div>
        </div>
        <div class="document-actions">
          <el-button size="small" @click="viewDocument(doc)">查看</el-button>
          <el-button 
            v-if="canEdit(doc)" 
            size="small" 
            type="primary" 
            @click="editDocument(doc)"
          >
            编辑
          </el-button>
          <el-button 
            v-if="canApprove(doc)" 
            size="small" 
            type="success" 
            @click="approveDocument(doc)"
          >
            审核
          </el-button>
        </div>
      </div>
    </div>
    
    <!-- 分页 -->
    <div class="pagination">
      <el-pagination
        v-model:current-page="pagination.page"
        v-model:page-size="pagination.size"
        :total="pagination.total"
        @current-change="handlePageChange"
        @size-change="handleSizeChange"
      />
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import { Search } from '@element-plus/icons-vue'

const searchForm = reactive({
  keyword: '',
  documentType: '',
  category: '',
  status: [],
  tags: []
})

const categoryTree = ref([])
const documentList = ref([])
const pagination = reactive({
  page: 1,
  size: 20,
  total: 0
})

const categoryProps = {
  children: 'children',
  label: 'name'
}

// 搜索文档
const handleSearch = async () => {
  try {
    const params = {
      ...searchForm,
      page: pagination.page - 1,
      size: pagination.size
    }
    
    const response = await api.documents.search(params)
    documentList.value = response.data.content
    pagination.total = response.data.totalElements
  } catch (error) {
    ElMessage.error('搜索文档失败')
  }
}

// 查看文档详情
const viewDocument = (doc) => {
  router.push(\`/documents/\${doc.id}\`)
}

// 编辑文档
const editDocument = (doc) => {
  router.push(\`/documents/\${doc.id}/edit\`)
}

// 审核文档
const approveDocument = (doc) => {
  router.push(\`/documents/\${doc.id}/approval\`)
}
<\/script>
\`\`\`

#### 3.3.2 文档编辑器界面
\`\`\`vue
<!-- 文档编辑器 -->
<template>
  <div class="document-editor">
    <!-- 文档信息 -->
    <div class="document-info">
      <el-form :model="documentForm" label-width="120px">
        <el-form-item label="文档标题" required>
          <el-input v-model="documentForm.title" />
        </el-form-item>
        <el-form-item label="文档编号">
          <el-input v-model="documentForm.documentCode" />
        </el-form-item>
        <el-form-item label="文档类型" required>
          <el-select v-model="documentForm.documentType">
            <el-option label="程序文件" value="PROCEDURE" />
            <el-option label="作业指导书" value="WORK_INSTRUCTION" />
            <el-option label="表单记录" value="FORM" />
            <el-option label="标准规范" value="STANDARD" />
          </el-select>
        </el-form-item>
        <el-form-item label="分类" required>
          <el-cascader
            v-model="documentForm.category"
            :options="categoryOptions"
            :props="categoryProps"
          />
        </el-form-item>
        <el-form-item label="摘要">
          <el-input
            v-model="documentForm.summary"
            type="textarea"
            :rows="3"
          />
        </el-form-item>
        <el-form-item label="标签">
          <el-select
            v-model="documentForm.tags"
            multiple
            filterable
            allow-create
            default-first-option
            placeholder="选择或创建标签"
          >
            <el-option
              v-for="tag in availableTags"
              :key="tag.id"
              :label="tag.tagName"
              :value="tag.id"
            />
          </el-select>
        </el-form-item>
      </el-form>
    </div>
    
    <!-- 富文本编辑器 -->
    <div class="editor-container">
      <div class="editor-toolbar">
        <el-button-group>
          <el-button :icon="Bold" @click="editor.chain().focus().toggleBold().run()" />
          <el-button :icon="Italic" @click="editor.chain().focus().toggleItalic().run()" />
          <el-button :icon="Underline" @click="editor.chain().focus().toggleUnderline().run()" />
        </el-button-group>
        
        <el-button-group>
          <el-button :icon="Heading" @click="editor.chain().focus().toggleHeading({ level: 1 }).run()" />
          <el-button :icon="Heading" @click="editor.chain().focus().toggleHeading({ level: 2 }).run()" />
          <el-button :icon="Heading" @click="editor.chain().focus().toggleHeading({ level: 3 }).run()" />
        </el-button-group>
        
        <el-button-group>
          <el-button :icon="List" @click="editor.chain().focus().toggleBulletList().run()" />
          <el-button :icon="ListOrdered" @click="editor.chain().focus().toggleOrderedList().run()" />
        </el-button-group>
        
        <el-button-group>
          <el-button :icon="Link" @click="showLinkDialog = true" />
          <el-button :icon="Image" @click="showImageDialog = true" />
          <el-button :icon="Table" @click="insertTable" />
        </el-button-group>
        
        <el-button-group>
          <el-button :icon="Undo" @click="editor.chain().focus().undo().run()" />
          <el-button :icon="Redo" @click="editor.chain().focus().redo().run()" />
        </el-button-group>
      </div>
      
      <div class="editor-content">
        <editor-content :editor="editor" />
      </div>
    </div>
    
    <!-- 附件上传 -->
    <div class="attachments">
      <h3>附件</h3>
      <el-upload
        :action="uploadUrl"
        :headers="uploadHeaders"
        :on-success="handleUploadSuccess"
        :on-error="handleUploadError"
        multiple
        :file-list="attachments"
      >
        <el-button type="primary">上传附件</el-button>
      </el-upload>
    </div>
    
    <!-- 操作按钮 -->
    <div class="editor-actions">
      <el-button @click="saveDraft">保存草稿</el-button>
      <el-button type="primary" @click="submitReview">提交审核</el-button>
      <el-button @click="previewDocument">预览</el-button>
    </div>
    
    <!-- 链接对话框 -->
    <el-dialog v-model="showLinkDialog" title="插入链接">
      <el-form :model="linkForm">
        <el-form-item label="链接文本">
          <el-input v-model="linkForm.text" />
        </el-form-item>
        <el-form-item label="链接地址">
          <el-input v-model="linkForm.url" />
        </el-form-item>
      </el-form>
      <template #footer>
        <el-button @click="showLinkDialog = false">取消</el-button>
        <el-button type="primary" @click="insertLink">确定</el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, onBeforeUnmount } from 'vue'
import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import Link from '@tiptap/extension-link'
import Image from '@tiptap/extension-image'
import Table from '@tiptap/extension-table'
import TableRow from '@tiptap/extension-table-row'
import TableCell from '@tiptap/extension-table-cell'
import TableHeader from '@tiptap/extension-table-header'

const editor = useEditor({
  extensions: [
    StarterKit,
    Link.configure({
      openOnClick: false,
    }),
    Image,
    Table.configure({
      resizable: true,
    }),
    TableRow,
    TableCell,
    TableHeader,
  ],
  content: '<p>开始编辑文档内容...</p>',
})

// 文档表单
const documentForm = reactive({
  title: '',
  documentCode: '',
  documentType: '',
  category: [],
  summary: '',
  tags: []
})

// 附件列表
const attachments = ref([])

// 链接对话框
const showLinkDialog = ref(false)
const linkForm = reactive({
  text: '',
  url: ''
})

// 插入链接
const insertLink = () => {
  editor.value.chain().focus().insertContent({
    type: 'link',
    attrs: {
      href: linkForm.url,
    },
    content: linkForm.text,
  }).run()
  
  showLinkDialog.value = false
  linkForm.text = ''
  linkForm.url = ''
}

// 插入表格
const insertTable = () => {
  editor.value.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run()
}

// 保存草稿
const saveDraft = async () => {
  try {
    const formData = new FormData()
    formData.append('title', documentForm.title)
    formData.append('documentType', documentForm.documentType)
    formData.append('categoryId', documentForm.category[documentForm.category.length - 1])
    formData.append('summary', documentForm.summary)
    formData.append('tags', JSON.stringify(documentForm.tags))
    formData.append('content', editor.value.getHTML())
    
    // 保存文档
    const response = await api.documents.create(formData)
    ElMessage.success('文档已保存为草稿')
    
    // 跳转到文档详情页
    router.push(\`/documents/\${response.data.id}\`)
  } catch (error) {
    ElMessage.error('保存草稿失败')
  }
}

// 提交审核
const submitReview = async () => {
  try {
    await saveDraft()
    // 提交审核
    await api.documentApprovals.submit(reviewData.documentId)
    ElMessage.success('文档已提交审核')
    router.push('/documents')
  } catch (error) {
    ElMessage.error('提交审核失败')
  }
}
<\/script>
\`\`\`

## 4. 性能优化与扩展性

### 4.1 缓存策略
\`\`\`java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .disableCachingNullValues()
            .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(redisConnectionFactory)
            .cacheDefaults(config)
            .withInitialCacheConfigurations(getCacheConfigurations())
            .build();
    }
    
    private Map<String, RedisCacheConfiguration> getCacheConfigurations() {
        Map<String, RedisCacheConfiguration> configMap = new HashMap<>();
        
        // 文档详情缓存
        configMap.put("documentDetails", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .disableCachingNullValues());
        
        // 分类树缓存
        configMap.put("categoryTree", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(6))
            .disableCachingNullValues());
        
        // 标签缓存
        configMap.put("documentTags", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(2))
            .disableCachingNullValues());
        
        return configMap;
    }
}

@Service
@RequiredArgsConstructor
public class CachedDocumentService {
    
    private final DocumentRepository documentRepository;
    private final CategoryRepository categoryRepository;
    private final CacheManager cacheManager;
    
    @Cacheable(value = "documentDetails", key = "#id")
    public DocumentDTO getDocumentDTO(Long id) {
        Document document = documentRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Document not found"));
        return convertToDTO(document);
    }
    
    @CacheEvict(value = "documentDetails", key = "#id")
    public void updateDocument(Long id, DocumentDTO dto) {
        // 更新文档逻辑
    }
    
    @Cacheable(value = "categoryTree", key = "'all'")
    public List<CategoryTreeNodeDTO> getCategoryTree() {
        List<DocumentCategory> categories = categoryRepository.findByActiveTrueOrderBySortOrderAsc();
        return buildCategoryTree(categories);
    }
}
\`\`\`

### 4.2 文件存储优化
\`\`\`java
@Service
@RequiredArgsConstructor
public class OptimizedFileStorageService {
    
    private final MinioClient minioClient;
    private final CacheManager cacheManager;
    private final ThreadPoolExecutor executor;
    
    /**
     * 分块上传大文件
     */
    public String uploadDocumentInChunks(MultipartFile file, String documentCode, Integer version) {
        String objectName = buildObjectName(documentCode, version);
        String uploadId = initiateMultipartUpload(objectName);
        
        try {
            // 分块上传
            List<PartETag> partETags = uploadFileInParts(file, uploadId);
            
            // 完成上传
            completeMultipartUpload(objectName, uploadId, partETags);
            
            // 缓存文件信息
            cacheFileInfo(objectName, file);
            
            return getPublicUrl(objectName);
        } catch (Exception e) {
            abortMultipartUpload(objectName, uploadId);
            throw new FileUploadException("文件上传失败", e);
        }
    }
    
    /**
     * CDN加速
     */
    public String getCdnUrl(String fileUrl) {
        // 将MinIO URL转换为CDN URL
        String cdnDomain = "cdn.shunfu-qms.com";
        String originalPath = extractPathFromUrl(fileUrl);
        return "https://" + cdnDomain + originalPath;
    }
    
    /**
     * 文件预览
     */
    public String generatePreviewUrl(String fileUrl, String previewType) {
        // 根据文件类型生成预览URL
        if (isPreviewSupported(fileUrl)) {
            String previewToken = generatePreviewToken(fileUrl);
            return String.format("%s?preview=true&type=%s&token=%s", 
                fileUrl, previewType, previewToken);
        }
        return fileUrl;
    }
    
    private boolean isPreviewSupported(String fileUrl) {
        String extension = getFileExtension(fileUrl);
        return SUPPORTED_PREVIEW_TYPES.contains(extension.toLowerCase());
    }
}
\`\`\`

### 4.3 搜索性能优化
\`\`\`java
@Configuration
public class ElasticsearchOptimizationConfig {
    
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        // 连接池配置
        RestClientBuilder builder = RestClient.builder(
            new HttpHost("localhost", 9200, "http"))
            .setHttpClientConfigCallback(httpClientBuilder -> {
                httpClientBuilder.setMaxConnTotal(100);
                httpClientBuilder.setMaxConnPerRoute(50);
                httpClientBuilder.setConnectionTimeToLive(30, TimeUnit.SECONDS);
                return httpClientBuilder;
            });
        
        return new RestHighLevelClient(builder);
    }
}

@Service
@RequiredArgsConstructor
public class OptimizedDocumentSearchService {
    
    private final DocumentSearchRepository searchRepository;
    private final ElasticsearchTemplate elasticsearchTemplate;
    
    /**
     * 批量索引文档
     */
    @Async("documentSearchExecutor")
    public void batchIndexDocuments(List<Document> documents) {
        BulkRequest bulkRequest = new BulkRequest();
        
        for (Document doc : documents) {
            DocumentSearchDocument searchDoc = convertToSearchDocument(doc);
            IndexRequest indexRequest = new IndexRequest("qms_documents")
                .id(doc.getId().toString())
                .source(searchDoc);
            bulkRequest.add(indexRequest);
        }
        
        try {
            BulkResponse response = elasticsearchTemplate.bulk(bulkRequest, DocumentSearchDocument.class);
            if (response.hasFailures()) {
                log.error("批量索引文档失败: {}", response.buildFailureMessage());
            }
        } catch (Exception e) {
            log.error("批量索引文档异常", e);
        }
    }
    
    /**
     * 实时搜索优化
     */
    public Page<DocumentSearchResult> realTimeSearch(String keyword, Pageable pageable) {
        // 使用更快的查询方式
        SearchQuery query = new NativeSearchQueryBuilder()
            .withQuery(QueryBuilders.boolQuery()
                .must(QueryBuilders.queryStringQuery(keyword)
                    .field("title").boost(3.0f)
                    .field("summary").boost(2.0f)
                    .field("content").boost(1.0f)))
            .withPageable(pageable)
            .withSort(SortBuilders.fieldSort("_score").order(SOrder.DESC))
            .build();
        
        return elasticsearchTemplate.queryForPage(query, DocumentSearchDocument.class, 
            this::convertToSearchResult);
    }
}
\`\`\`

## 5. 安全与合规

### 5.1 文档访问控制
\`\`\`java
@Configuration
@EnableWebSecurity
public class DocumentSecurityConfig {
    
    @Bean
    public SecurityFilterChain documentSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            .securityMatcher("/api/documents/**")
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/documents/search").permitAll()
                .requestMatchers("/api/documents/{id}").hasAnyRole("DOCUMENT_READ", "ADMIN")
                .requestMatchers("/api/documents/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(documentAuthorizationFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public DocumentAuthorizationFilter documentAuthorizationFilter() {
        return new DocumentAuthorizationFilter();
    }
}

@Component
public class DocumentAuthorizationFilter extends OncePerRequestFilter {
    
    private final DocumentPermissionService permissionService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                 HttpServletResponse response, 
                                 FilterChain filterChain) throws ServletException, IOException {
        
        String requestURI = request.getRequestURI();
        Long documentId = extractDocumentIdFromUri(requestURI);
        
        if (documentId != null && requiresDocumentAuthorization(requestURI)) {
            String permission = determineRequiredPermission(requestURI, request.getMethod());
            
            if (!permissionService.checkPermission(documentId, permission)) {
                response.sendError(HttpStatus.FORBIDDEN.value(), "Access denied");
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private Long extractDocumentIdFromUri(String uri) {
        try {
            // 从URI中提取文档ID
            Pattern pattern = Pattern.compile("/api/documents/(\\\\d+)");
            Matcher matcher = pattern.matcher(uri);
            if (matcher.find()) {
                return Long.parseLong(matcher.group(1));
            }
        } catch (Exception e) {
            log.warn("Failed to extract document ID from URI: {}", uri, e);
        }
        return null;
    }
    
    private boolean requiresDocumentAuthorization(String uri) {
        return !uri.contains("/search") && !uri.contains("/public");
    }
    
    private String determineRequiredPermission(String uri, String method) {
        if (uri.contains("/approve") || "POST".equals(method)) {
            return "APPROVE";
        } else if (uri.contains("/edit") || "PUT".equals(method)) {
            return "WRITE";
        } else {
            return "READ";
        }
    }
}
\`\`\`

### 5.2 审计日志
\`\`\`java
@Aspect
@Component
public class DocumentAuditAspect {
    
    private final AuditLogRepository auditLogRepository;
    
    @AfterReturning("execution(* com.shunfu.qms.service.*.*Document(..)) && args(documentId,..)")
    public void auditDocumentOperation(JoinPoint joinPoint, Long documentId) {
        String operation = joinPoint.getSignature().getName();
        String action = convertOperationToAction(operation);
        
        auditLogRepository.save(DocumentAuditLog.builder()
            .documentId(documentId)
            .action(action)
            .userId(SecurityUtils.getCurrentUserId())
            .timestamp(LocalDateTime.now())
            .details(Map.of(
                "operation", operation,
                "method", joinPoint.getSignature().toShortString(),
                "args", joinPoint.getArgs()
            ))
            .build());
    }
    
    private String convertOperationToAction(String operation) {
        switch (operation) {
            case "createDocument":
                return "CREATE";
            case "updateDocument":
                return "UPDATE";
            case "deleteDocument":
                return "DELETE";
            case "approveDocument":
                return "APPROVE";
            case "rejectDocument":
                return "REJECT";
            default:
                return "OTHER";
        }
    }
}

@Entity
@Table(name = "qms_system_audit_log")
@Data
public class SystemAuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String module;
    
    @Column(nullable = false)
    private String action;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false)
    private String userName;
    
    @Column(nullable = false)
    private String userEmail;
    
    @Column(nullable = false)
    private String ipAddress;
    
    @Column(nullable = false)
    private String userAgent;
    
    @Column(nullable = false)
    private LocalDateTime timestamp;
    
    @Column
    private String details;
    
    @Column(nullable = false)
    private String sessionId;
}
\`\`\`

## 6. 部署与运维

### 6.1 Docker部署配置
\`\`\`dockerfile
# Dockerfile for Document Service
FROM openjdk:17-jre-slim

WORKDIR /app

COPY target/qms-document-service-0.0.1-SNAPSHOT.jar app.jar

EXPOSE 8080

ENV JAVA_OPTS="-Xmx2g -Xms1g"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
\`\`\`

\`\`\`yaml
# docker-compose.yml
version: '3.8'

services:
  document-service:
    build: ./document-service
    ports:
      - "8081:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/qms_document
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
    depends_on:
      - postgres
      - minio
      - elasticsearch
  
  minio:
    image: minio/minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin
    command: server /data --console-address ":9001"
  
  elasticsearch:
    image: elasticsearch:8.8.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data
  
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=qms_document
      - POSTGRES_USER=qms
      - POSTGRES_PASSWORD=qms123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  es_data:
  postgres_data:
\`\`\`

### 6.2 监控与告警
\`\`\`yaml
# prometheus-document-service.yml
groups:
  - name: document_service
    interval: 15s
    rules:
      - alert: DocumentServiceHighErrorRate
        expr: rate(http_server_requests_total{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Document Service high error rate"
          description: "Error rate is {{ $value }} errors per second"
      
      - alert: DocumentStorageLowDiskSpace
        expr: (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 80
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Document storage low disk space"
          description: "Disk usage is at {{ $value }}%"
      
      - alert: DocumentSearchSlowQuery
        expr: rate(elasticsearch_query_time_seconds_sum[5m]) / rate(elasticsearch_query_time_seconds_count[5m]) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Document search slow query"
          description: "Average query time is {{ $value }} seconds"
\`\`\`

## 7. 测试策略

### 7.1 单元测试
\`\`\`java
@ExtendWith(MockitoExtension.class)
class DocumentServiceTest {
    
    @Mock
    private DocumentRepository documentRepository;
    
    @Mock
    private CategoryRepository categoryRepository;
    
    @Mock
    private FileStorageService fileStorageService;
    
    @InjectMocks
    private DocumentService documentService;
    
    @Test
    void createDocument_shouldCreateDocumentSuccessfully() {
        // Arrange
        DocumentCreateDTO dto = new DocumentCreateDTO();
        dto.setTitle("Test Document");
        dto.setDocumentType("PROCEDURE");
        dto.setCategoryId(1L);
        
        MultipartFile file = new MockMultipartFile("test.pdf", "test.pdf", "application/pdf", "test content".getBytes());
        
        DocumentCategory category = new DocumentCategory();
        category.setId(1L);
        
        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));
        when(fileStorageService.uploadDocument(any(), any(), any())).thenReturn("http://test.com/test.pdf");
        
        // Act
        DocumentDTO result = documentService.createDocument(dto, file);
        
        // Assert
        assertNotNull(result);
        assertEquals("Test Document", result.getTitle());
        assertEquals("PROCEDURE", result.getDocumentType());
    }
    
    @Test
    void createDocument_shouldThrowExceptionWhenCategoryNotFound() {
        // Arrange
        DocumentCreateDTO dto = new DocumentCreateDTO();
        dto.setCategoryId(1L);
        
        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
        
        // Act & Assert
        assertThrows(EntityNotFoundException.class, () -> {
            documentService.createDocument(dto, null);
        });
    }
}
\`\`\`

### 7.2 集成测试
\`\`\`java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class DocumentControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private DocumentRepository documentRepository;
    
    @Test
    void searchDocuments_shouldReturnDocuments() {
        // Arrange
        Document doc = new Document();
        doc.setTitle("Test Document");
        doc.setDocumentCode("QMS-DOC-001");
        doc.setStatus("PUBLISHED");
        documentRepository.save(doc);
        
        // Act
        ResponseEntity<Page<DocumentSearchResult>> response = restTemplate.getForEntity(
            "/api/documents/search?keyword=Test", 
            new ParameterizedTypeReference<Page<DocumentSearchResult>>() {}
        );
        
        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody().getContent().size() > 0);
    }
    
    @Test
    void createDocument_shouldCreateDocument() {
        // Arrange
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("title", "Integration Test Document");
        body.add("documentType", "PROCEDURE");
        body.add("categoryId", "1");
        
        MockMultipartFile file = new MockMultipartFile(
            "file", 
            "test.pdf", 
            "application/pdf", 
            "test content".getBytes()
        );
        body.add("file", file);
        
        // Act
        ResponseEntity<DocumentDTO> response = restTemplate.postForEntity(
            "/api/documents", 
            body, 
            DocumentDTO.class
        );
        
        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("Integration Test Document", response.getBody().getTitle());
    }
}
\`\`\`

## 8. 项目总结

### 8.1 实现要点总结
1. **完整的文档生命周期管理**: 从草稿到发布、撤销的全流程管理
2. **智能文档检索**: 基于Elasticsearch的高效全文检索
3. **版本控制机制**: 支持文档版本比较和回滚
4. **权限细粒度控制**: 基于角色、部门、用户的权限管理
5. **工作流集成**: 可配置的多级审批流程
6. **智能化特性**: 自动标签推荐、相关文档推荐
7. **高性能优化**: 缓存、分块上传、CDN加速
8. **安全性保障**: 完善的审计日志和访问控制

### 8.2 技术特色
- **微服务架构**: 独立部署的文档管理服务
- **多存储方案**: 支持MinIO、阿里云OSS等多种存储
- **搜索优化**: Elasticsearch全文检索与智能推荐
- **容器化部署**: Docker + Kubernetes支持
- **监控告警**: Prometheus + Grafana监控体系

### 8.3 业务价值
为舜富精密压铸提供:
1. 完全合规的文档管理体系
2. 高效的文档检索和协作工具
3. 智能化的文档管理体验
4. 完善的版本控制和审计功能
5. 与QMS其他系统的无缝集成

---

**文档管理模块详细实现规范完成。接下来继续实现供应商管理模块详细规范。**`,Zn=`# 舜富QMS系统 - 培训管理模块详细实现规范

## 1. 模块概述

### 1.1 功能定位
培训管理模块是舜富QMS系统的人才发展核心，负责质量培训的全生命周期管理，确保员工具备必要的质量知识、技能和资质，满足IATF16949:2016对人员能力的要求。

### 1.2 业务价值
- **能力提升**: 系统化提升员工质量管理能力和专业技能
- **合规保障**: 确保员工资质符合IATF16949:2016标准要求
- **知识传承**: 将质量知识和经验有效传递给员工
- **绩效改进**: 通过培训提升质量意识和操作技能
- **人才培养**: 构建完善的质量人才培养体系

### 1.3 技术架构
- **前端**: Vue.js 3.x + Element Plus + ECharts可视化
- **后端**: Spring Boot 3.x + Spring Security + Spring Data JPA
- **数据库**: PostgreSQL (主业务) + MongoDB (文档) + Redis (缓存)
- **视频服务**: FFmpeg + Nginx-RTMP + HLS
- **在线考试**: Ant Design + Vue.js + WebSocket
- **报表系统**: JasperReports + Apache POI
- **移动端**: Uni-app + 微信小程序

## 2. 核心功能详细设计

### 2.1 培训课程管理

#### 2.1.1 课程体系架构
\`\`\`java
// 培训课程实体
@Entity
@Table(name = "qms_training_course")
@Data
public class TrainingCourse {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String courseName;
    
    @Column(nullable = false, length = 50)
    private String courseCode; // QMS-TRN-2024-001
    
    @Column(length = 1000)
    private String courseDescription;
    
    @Column(nullable = false)
    private CourseType courseType; // MANDATORY, ELECTIVE, CUSTOM
    
    @Column(nullable = false)
    private CourseCategory category; // QUALITY_AWARENESS, TECHNICAL_SKILL, PROCESS_KNOWLEDGE, MANAGEMENT
    
    @Column(nullable = false)
    private TrainingLevel level; // BASIC, INTERMEDIATE, ADVANCED, EXPERT
    
    @Column(nullable = false)
    private Integer durationHours; // 培训时长(小时)
    
    @Column(nullable = false)
    private Integer validPeriod; // 有效期(月)
    
    @Column(nullable = false)
    private String targetAudience; // 目标受众
    
    @Column(nullable = false)
    private String learningObjectives; // 学习目标
    
    @Column(length = 1000)
    private String prerequisites; // 前置要求
    
    @Column(nullable = false)
    private CourseStatus status; // DRAFT, PUBLISHED, ARCHIVED
    
    @Column(nullable = false)
    private LocalDateTime publishDate;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", nullable = false)
    private User author;
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL)
    private List<CourseModule> modules = new ArrayList<>();
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL)
    private List<CourseSchedule> schedules = new ArrayList<>();
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL)
    private List<CourseRequirement> requirements = new ArrayList<>();
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL)
    private List<CourseMaterial> materials = new ArrayList<>();
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL)
    private List<CourseAssessment> assessments = new ArrayList<>();
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "qms_course_instructor",
        joinColumns = @JoinColumn(name = "course_id"),
        inverseJoinColumns = @JoinColumn(name = "instructor_id")
    )
    private Set<User> instructors = new HashSet<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

// 课程模块实体
@Entity
@Table(name = "qms_course_module")
@Data
public class CourseModule {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id", nullable = false)
    private TrainingCourse course;
    
    @Column(nullable = false)
    private Integer moduleOrder;
    
    @Column(nullable = false, length = 200)
    private String moduleName;
    
    @Column(length = 1000)
    private String moduleDescription;
    
    @Column(nullable = false)
    private Integer estimatedDuration; // 预估时长(分钟)
    
    @Column(nullable = false)
    private ModuleType moduleType; // VIDEO, DOCUMENT, QUIZ, PRACTICE, DISCUSSION
    
    @Column(nullable = false)
    private ModuleStatus status; // DRAFT, PUBLISHED, ARCHIVED
    
    @Column(length = 500)
    private String videoUrl;
    
    @Column(length = 500)
    private String documentUrl;
    
    @Column(length = 1000)
    private String quizQuestions;
    
    @Column(length = 1000)
    private String practiceTasks;
    
    @Column(length = 500)
    private String discussionTopic;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @OneToMany(mappedBy = "module", cascade = CascadeType.ALL)
    private List<ModuleResource> resources = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}
\`\`\`

#### 2.1.2 课程管理服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class TrainingCourseService {
    
    private final TrainingCourseRepository courseRepository;
    private final CourseModuleRepository moduleRepository;
    private final UserRepository userRepository;
    private final FileStorageService fileStorageService;
    private final NotificationService notificationService;
    
    /**
     * 创建培训课程
     */
    @Transactional
    public TrainingCourseDTO createCourse(TrainingCourseCreateDTO dto) {
        // 验证课程编号唯一性
        validateCourseCode(dto.getCourseCode());
        
        // 创建课程
        TrainingCourse course = TrainingCourse.builder()
            .courseName(dto.getCourseName())
            .courseCode(dto.getCourseCode())
            .courseDescription(dto.getCourseDescription())
            .courseType(dto.getCourseType())
            .category(dto.getCategory())
            .level(dto.getLevel())
            .durationHours(dto.getDurationHours())
            .validPeriod(dto.getValidPeriod())
            .targetAudience(dto.getTargetAudience())
            .learningObjectives(dto.getLearningObjectives())
            .prerequisites(dto.getPrerequisites())
            .status(CourseStatus.DRAFT)
            .author(SecurityUtils.getCurrentUser())
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();
        
        courseRepository.save(course);
        
        // 创建课程模块
        createCourseModules(course, dto.getModules());
        
        // 设置讲师
        if (dto.getInstructorIds() != null && !dto.getInstructorIds().isEmpty()) {
            Set<User> instructors = userRepository.findAllById(dto.getInstructorIds());
            course.setInstructors(instructors);
        }
        
        courseRepository.save(course);
        
        return convertToDTO(course);
    }
    
    /**
     * 更新课程信息
     */
    @Transactional
    public TrainingCourseDTO updateCourse(Long courseId, TrainingCourseUpdateDTO dto) {
        TrainingCourse course = courseRepository.findById(courseId)
            .orElseThrow(() -> new EntityNotFoundException("Course not found"));
        
        // 更新基本信息
        if (StringUtils.hasText(dto.getCourseName())) {
            course.setCourseName(dto.getCourseName());
        }
        if (StringUtils.hasText(dto.getCourseDescription())) {
            course.setCourseDescription(dto.getCourseDescription());
        }
        if (dto.getDurationHours() != null) {
            course.setDurationHours(dto.getDurationHours());
        }
        if (dto.getValidPeriod() != null) {
            course.setValidPeriod(dto.getValidPeriod());
        }
        
        // 更新讲师
        if (dto.getInstructorIds() != null) {
            Set<User> instructors = userRepository.findAllById(dto.getInstructorIds());
            course.setInstructors(instructors);
        }
        
        course.setUpdatedAt(LocalDateTime.now());
        courseRepository.save(course);
        
        return convertToDTO(course);
    }
    
    /**
     * 发布课程
     */
    @Transactional
    public void publishCourse(Long courseId) {
        TrainingCourse course = courseRepository.findById(courseId)
            .orElseThrow(() -> new EntityNotFoundException("Course not found"));
        
        // 验证课程完整性
        validateCourseForPublish(course);
        
        // 发布所有模块
        publishAllModules(course);
        
        // 更新课程状态
        course.setStatus(CourseStatus.PUBLISHED);
        course.setPublishDate(LocalDateTime.now());
        courseRepository.save(course);
        
        // 通知相关人员
        notifyCoursePublished(course);
    }
    
    /**
     * 归档课程
     */
    @Transactional
    public void archiveCourse(Long courseId, String reason) {
        TrainingCourse course = courseRepository.findById(courseId)
            .orElseThrow(() -> new EntityNotFoundException("Course not found"));
        
        if (course.getStatus() == CourseStatus.ARCHIVED) {
            throw new IllegalStateException("Course is already archived");
        }
        
        course.setStatus(CourseStatus.ARCHIVED);
        course.setUpdatedAt(LocalDateTime.now());
        courseRepository.save(course);
        
        // 发送归档通知
        notificationService.sendCourseArchivedNotification(course, reason);
    }
    
    /**
     * 获取课程详情
     */
    public TrainingCourseDetailDTO getCourseDetail(Long courseId) {
        TrainingCourse course = courseRepository.findByIdWithDetails(courseId)
            .orElseThrow(() -> new EntityNotFoundException("Course not found"));
        
        TrainingCourseDetailDTO dto = convertToDetailDTO(course);
        
        // 获取课程统计
        CourseStats stats = getCourseStats(courseId);
        dto.setStats(stats);
        
        return dto;
    }
    
    /**
     * 课程搜索
     */
    public Page<TrainingCourseDTO> searchCourses(CourseSearchCriteria criteria, Pageable pageable) {
        Specification<TrainingCourse> spec = Specification.where(null);
        
        // 关键词搜索
        if (StringUtils.hasText(criteria.getKeyword())) {
            spec = spec.and((root, query, cb) -> cb.or(
                cb.like(root.get("courseName"), "%" + criteria.getKeyword() + "%"),
                cb.like(root.get("courseDescription"), "%" + criteria.getKeyword() + "%"),
                cb.like(root.get("learningObjectives"), "%" + criteria.getKeyword() + "%")
            ));
        }
        
        // 课程类型过滤
        if (criteria.getCourseType() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("courseType"), criteria.getCourseType()));
        }
        
        // 分类过滤
        if (criteria.getCategory() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("category"), criteria.getCategory()));
        }
        
        // 等级过滤
        if (criteria.getLevel() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("level"), criteria.getLevel()));
        }
        
        // 状态过滤
        if (criteria.getStatus() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("status"), criteria.getStatus()));
        }
        
        Page<TrainingCourse> page = courseRepository.findAll(spec, pageable);
        return page.map(this::convertToDTO);
    }
    
    /**
     * 创建课程模块
     */
    private void createCourseModules(TrainingCourse course, List<ModuleCreateDTO> moduleDTOs) {
        if (moduleDTOs == null || moduleDTOs.isEmpty()) {
            return;
        }
        
        for (int i = 0; i < moduleDTOs.size(); i++) {
            ModuleCreateDTO moduleDTO = moduleDTOs.get(i);
            
            CourseModule module = CourseModule.builder()
                .course(course)
                .moduleOrder(i + 1)
                .moduleName(moduleDTO.getModuleName())
                .moduleDescription(moduleDTO.getModuleDescription())
                .estimatedDuration(moduleDTO.getEstimatedDuration())
                .moduleType(moduleDTO.getModuleType())
                .status(ModuleStatus.DRAFT)
                .createdAt(LocalDateTime.now())
                .build();
            
            moduleRepository.save(module);
            course.getModules().add(module);
            
            // 处理模块资源
            handleModuleResources(module, moduleDTO);
        }
    }
    
    /**
     * 发布所有模块
     */
    private void publishAllModules(TrainingCourse course) {
        for (CourseModule module : course.getModules()) {
            if (module.getStatus() == ModuleStatus.DRAFT) {
                module.setStatus(ModuleStatus.PUBLISHED);
                moduleRepository.save(module);
            }
        }
    }
    
    /**
     * 验证课程发布完整性
     */
    private void validateCourseForPublish(TrainingCourse course) {
        // 检查是否有模块
        if (course.getModules().isEmpty()) {
            throw new IllegalStateException("课程必须包含至少一个模块");
        }
        
        // 检查所有模块是否已发布
        for (CourseModule module : course.getModules()) {
            if (module.getStatus() != ModuleStatus.PUBLISHED) {
                throw new IllegalStateException("所有模块都必须已发布才能发布课程");
            }
        }
        
        // 检查是否设置了讲师
        if (course.getInstructors().isEmpty()) {
            throw new IllegalStateException("课程必须设置讲师");
        }
        
        // 检查是否有评估
        if (course.getAssessments().isEmpty()) {
            throw new IllegalStateException("课程必须包含评估方式");
        }
    }
    
    /**
     * 获取课程统计
     */
    private CourseStats getCourseStats(Long courseId) {
        CourseStats stats = new CourseStats();
        stats.setCourseId(courseId);
        
        // 注册人数
        Long registrationCount = courseRegistrationRepository.countByCourseId(courseId);
        stats.setRegistrationCount(registrationCount != null ? registrationCount : 0);
        
        // 完成人数
        Long completionCount = courseRegistrationRepository
            .countByCourseIdAndStatus(courseId, RegistrationStatus.COMPLETED);
        stats.setCompletionCount(completionCount != null ? completionCount : 0);
        
        // 平均评分
        Double averageRating = courseRegistrationRepository
            .getAverageRatingByCourseId(courseId);
        stats.setAverageRating(averageRating != null ? averageRating : 0.0);
        
        // 最近学习人数
        Long recentLearners = courseRegistrationRepository
            .countByCourseIdAndLastAccessTimeAfter(courseId, 
                LocalDateTime.now().minusDays(7));
        stats.setRecentLearners(recentLearners != null ? recentLearners : 0);
        
        return stats;
    }
    
    /**
     * 通知课程发布
     */
    private void notifyCoursePublished(TrainingCourse course) {
        // 通知目标受众
        notificationService.sendCoursePublishedNotification(course);
        
        // 通知讲师
        for (User instructor : course.getInstructors()) {
            notificationService.sendInstructorCourseNotification(course, instructor);
        }
    }
}
\`\`\`

### 2.2 培训计划管理

#### 2.2.1 计划体系实体
\`\`\`java
// 培训计划实体
@Entity
@Table(name = "qms_training_plan")
@Data
public class TrainingPlan {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String planName;
    
    @Column(nullable = false, length = 50)
    private String planCode; // QMS-PLAN-2024-001
    
    @Column(length = 1000)
    private String planDescription;
    
    @Column(nullable = false)
    private PlanType planType; // DEPARTMENT, POSITION, INDIVIDUAL, COMPANY
    
    @Column(nullable = false)
    private PlanStatus status; // DRAFT, PUBLISHED, ACTIVE, COMPLETED, ARCHIVED
    
    @Column(nullable = false)
    private LocalDate startDate;
    
    @Column(nullable = false)
    private LocalDate endDate;
    
    @Column(nullable = false)
    private Integer totalDuration; // 总时长(小时)
    
    @Column(nullable = false)
    private Integer targetParticipants; // 目标人数
    
    @Column(length = 1000)
    private String planGoals; // 计划目标
    
    @Column(length = 1000)
    private String successCriteria; // 成功标准
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id", nullable = false)
    private User manager;
    
    @OneToMany(mappedBy = "plan", cascade = CascadeType.ALL)
    private List<PlanCourse> planCourses = new ArrayList<>();
    
    @OneToMany(mappedBy = "plan", cascade = CascadeType.ALL)
    private List<PlanSchedule> schedules = new ArrayList<>();
    
    @OneToMany(mappedBy = "plan", cascade = CascadeType.ALL)
    private List<PlanParticipant> participants = new ArrayList<>();
    
    @OneToMany(mappedBy = "plan", cascade = CascadeType.ALL)
    private List<PlanRequirement> requirements = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

// 计划课程关联实体
@Entity
@Table(name = "qms_plan_course")
@Data
public class PlanCourse {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plan_id", nullable = false)
    private TrainingPlan plan;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id", nullable = false)
    private TrainingCourse course;
    
    @Column(nullable = false)
    private Integer courseOrder;
    
    @Column(nullable = false)
    private LocalDate scheduledDate;
    
    @Column(nullable = false)
    private String sessionTime; // "09:00-12:00"
    
    @Column(nullable = false)
    private String location;
    
    @Column(nullable = false)
    private Integer maxParticipants;
    
    @Column(nullable = false)
    private CourseSessionStatus status; // SCHEDULED, ONGOING, COMPLETED, CANCELLED
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @OneToMany(mappedBy = "planCourse", cascade = CascadeType.ALL)
    private List<SessionRegistration> registrations = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}
\`\`\`

#### 2.2.2 计划管理服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class TrainingPlanService {
    
    private final TrainingPlanRepository planRepository;
    private final TrainingCourseRepository courseRepository;
    private final PlanCourseRepository planCourseRepository;
    private final UserRepository userRepository;
    private final NotificationService notificationService;
    
    /**
     * 创建培训计划
     */
    @Transactional
    public TrainingPlanDTO createPlan(TrainingPlanCreateDTO dto) {
        // 验证计划编号唯一性
        validatePlanCode(dto.getPlanCode());
        
        // 创建培训计划
        TrainingPlan plan = TrainingPlan.builder()
            .planName(dto.getPlanName())
            .planCode(dto.getPlanCode())
            .planDescription(dto.getPlanDescription())
            .planType(dto.getPlanType())
            .status(PlanStatus.DRAFT)
            .startDate(dto.getStartDate())
            .endDate(dto.getEndDate())
            .totalDuration(dto.getTotalDuration())
            .targetParticipants(dto.getTargetParticipants())
            .planGoals(dto.getPlanGoals())
            .successCriteria(dto.getSuccessCriteria())
            .manager(SecurityUtils.getCurrentUser())
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();
        
        planRepository.save(plan);
        
        // 添加计划课程
        addPlanCourses(plan, dto.getCourseIds());
        
        // 设置参与者
        if (dto.getParticipantIds() != null && !dto.getParticipantIds().isEmpty()) {
            addParticipants(plan, dto.getParticipantIds());
        }
        
        planRepository.save(plan);
        
        return convertToDTO(plan);
    }
    
    /**
     * 发布培训计划
     */
    @Transactional
    public void publishPlan(Long planId) {
        TrainingPlan plan = planRepository.findById(planId)
            .orElseThrow(() -> new EntityNotFoundException("Training plan not found"));
        
        // 验证计划完整性
        validatePlanForPublish(plan);
        
        // 更新状态
        plan.setStatus(PlanStatus.PUBLISHED);
        planRepository.save(plan);
        
        // 发送发布通知
        notifyPlanPublished(plan);
    }
    
    /**
     * 激活培训计划
     */
    @Transactional
    public void activatePlan(Long planId) {
        TrainingPlan plan = planRepository.findById(planId)
            .orElseThrow(() -> new EntityNotFoundException("Training plan not found"));
        
        if (plan.getStatus() != PlanStatus.PUBLISHED) {
            throw new IllegalStateException("Only published plans can be activated");
        }
        
        // 创建培训安排
        createTrainingSchedules(plan);
        
        // 更新状态
        plan.setStatus(PlanStatus.ACTIVE);
        planRepository.save(plan);
        
        // 通知参与者
        notifyPlanActivated(plan);
    }
    
    /**
     * 完成培训计划
     */
    @Transactional
    public void completePlan(Long planId) {
        TrainingPlan plan = planRepository.findById(planId)
            .orElseThrow(() -> new EntityNotFoundException("Training plan not found"));
        
        if (plan.getStatus() != PlanStatus.ACTIVE) {
            throw new IllegalStateException("Only active plans can be completed");
        }
        
        // 更新状态
        plan.setStatus(PlanStatus.COMPLETED);
        planRepository.save(plan);
        
        // 生成计划报告
        generatePlanReport(plan);
        
        // 发送完成通知
        notificationService.sendPlanCompletedNotification(plan);
    }
    
    /**
     * 获取计划详情
     */
    public TrainingPlanDetailDTO getPlanDetail(Long planId) {
        TrainingPlan plan = planRepository.findByIdWithDetails(planId)
            .orElseThrow(() -> new EntityNotFoundException("Training plan not found"));
        
        TrainingPlanDetailDTO dto = convertToDetailDTO(plan);
        
        // 获取计划统计
        PlanStats stats = getPlanStats(planId);
        dto.setStats(stats);
        
        return dto;
    }
    
    /**
     * 获取用户参与的计划
     */
    public Page<TrainingPlanDTO> getUserPlans(PlanSearchCriteria criteria, Pageable pageable) {
        User user = SecurityUtils.getCurrentUser();
        
        Specification<TrainingPlan> spec = Specification.where(null);
        
        // 根据用户角色过滤
        if (user.getRole().getName().equals("MANAGER")) {
            // 管理员可以看到自己管理的计划
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("manager"), user));
        } else {
            // 普通员工可以看到自己参与的计划
            spec = spec.and((root, query, cb) -> {
                Join<TrainingPlan, PlanParticipant> participantJoin = root.join("participants", JoinType.LEFT);
                return cb.equal(participantJoin.get("user"), user);
            });
        }
        
        // 状态过滤
        if (criteria.getStatus() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("status"), criteria.getStatus()));
        }
        
        // 时间范围过滤
        if (criteria.getStartDate() != null && criteria.getEndDate() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.between(root.get("startDate"), criteria.getStartDate(), criteria.getEndDate()));
        }
        
        Page<TrainingPlan> page = planRepository.findAll(spec, pageable);
        return page.map(this::convertToDTO);
    }
    
    /**
     * 添加计划课程
     */
    private void addPlanCourses(TrainingPlan plan, List<Long> courseIds) {
        if (courseIds == null || courseIds.isEmpty()) {
            return;
        }
        
        List<TrainingCourse> courses = courseRepository.findAllById(courseIds);
        
        for (int i = 0; i < courses.size(); i++) {
            TrainingCourse course = courses.get(i);
            
            PlanCourse planCourse = PlanCourse.builder()
                .plan(plan)
                .course(course)
                .courseOrder(i + 1)
                .status(CourseSessionStatus.SCHEDULED)
                .createdAt(LocalDateTime.now())
                .build();
            
            planCourseRepository.save(planCourse);
            plan.getPlanCourses().add(planCourse);
            
            // 计算总时长
            plan.setTotalDuration(plan.getTotalDuration() + course.getDurationHours());
        }
    }
    
    /**
     * 添加参与者
     */
    private void addParticipants(TrainingPlan plan, List<Long> participantIds) {
        List<User> participants = userRepository.findAllById(participantIds);
        
        for (User participant : participants) {
            PlanParticipant planParticipant = PlanParticipant.builder()
                .plan(plan)
                .user(participant)
                .participantRole("PARTICIPANT")
                .enrollmentDate(LocalDate.now())
                .status(RegistrationStatus.REGISTERED)
                .createdAt(LocalDateTime.now())
                .build();
            
            plan.getParticipants().add(planParticipant);
        }
    }
    
    /**
     * 验证计划发布完整性
     */
    private void validatePlanForPublish(TrainingPlan plan) {
        // 检查是否有课程
        if (plan.getPlanCourses().isEmpty()) {
            throw new IllegalStateException("计划必须包含至少一个课程");
        }
        
        // 检查日期逻辑
        if (plan.getStartDate().isAfter(plan.getEndDate())) {
            throw new IllegalStateException("开始日期不能晚于结束日期");
        }
        
        // 检查是否有参与者
        if (plan.getParticipants().isEmpty()) {
            throw new IllegalStateException("计划必须设置参与者");
        }
        
        // 检查成功标准
        if (!StringUtils.hasText(plan.getSuccessCriteria())) {
            throw new IllegalStateException("计划必须设置成功标准");
        }
    }
    
    /**
     * 创建培训安排
     */
    private void createTrainingSchedules(TrainingPlan plan) {
        LocalDate currentDate = plan.getStartDate();
        
        for (PlanCourse planCourse : plan.getPlanCourses()) {
            // 为每个课程创建具体的培训安排
            PlanSchedule schedule = PlanSchedule.builder()
                .plan(plan)
                .planCourse(planCourse)
                .sessionDate(currentDate)
                .sessionTime(planCourse.getSessionTime())
                .location(planCourse.getLocation())
                .maxParticipants(planCourse.getMaxParticipants())
                .status(SessionStatus.SCHEDULED)
                .createdAt(LocalDateTime.now())
                .build();
            
            plan.getSchedules().add(schedule);
            
            // 递增日期
            currentDate = currentDate.plusDays(1);
        }
    }
    
    /**
     * 获取计划统计
     */
    private PlanStats getPlanStats(Long planId) {
        PlanStats stats = new PlanStats();
        stats.setPlanId(planId);
        
        // 总参与人数
        Long totalParticipants = planParticipantRepository.countByPlanId(planId);
        stats.setTotalParticipants(totalParticipants != null ? totalParticipants : 0);
        
        // 已完成人数
        Long completedParticipants = planParticipantRepository
            .countByPlanIdAndStatus(planId, RegistrationStatus.COMPLETED);
        stats.setCompletedParticipants(completedParticipants != null ? completedParticipants : 0);
        
        // 完成率
        Double completionRate = totalParticipants > 0 ? 
            new Double(completedParticipants) / totalParticipants * 100 : 0.0;
        stats.setCompletionRate(completionRate);
        
        // 平均评分
        Double averageRating = planParticipantRepository
            .getAverageRatingByPlanId(planId);
        stats.setAverageRating(averageRating != null ? averageRating : 0.0);
        
        // 课程完成情况
        Map<String, Integer> courseCompletion = planCourseRepository
            .getCourseCompletionStats(planId);
        stats.setCourseCompletion(courseCompletion);
        
        return stats;
    }
    
    /**
     * 通知计划发布
     */
    private void notifyPlanPublished(TrainingPlan plan) {
        // 通知计划管理员
        notificationService.sendPlanPublishedNotification(plan, plan.getManager());
        
        // 通知讲师
        for (PlanCourse planCourse : plan.getPlanCourses()) {
            User instructor = planCourse.getCourse().getAuthor();
            notificationService.sendInstructorPlanNotification(plan, planCourse, instructor);
        }
    }
    
    /**
     * 通知计划激活
     */
    private void notifyPlanActivated(TrainingPlan plan) {
        // 通知所有参与者
        for (PlanParticipant participant : plan.getParticipants()) {
            notificationService.sendPlanActivatedNotification(plan, participant.getUser());
        }
    }
    
    /**
     * 生成计划报告
     */
    private void generatePlanReport(TrainingPlan plan) {
        // 收集统计数据
        PlanStats stats = getPlanStats(plan.getId());
        
        // 生成PDF报告
        byte[] reportData = reportGenerator.generateTrainingPlanReport(plan, stats);
        
        // 保存报告
        String reportUrl = fileStorageService.uploadReport(reportData, 
            "training-plan-report-" + plan.getId() + ".pdf");
        
        // 创建报告记录
        TrainingPlanReport report = TrainingPlanReport.builder()
            .plan(plan)
            .reportUrl(reportUrl)
            .reportType("COMPLETION_REPORT")
            .generatedBy(SecurityUtils.getCurrentUser())
            .generatedAt(LocalDateTime.now())
            .build();
        
        planReportRepository.save(report);
    }
}
\`\`\`

### 2.3 培训实施管理

#### 2.3.1 实施过程管理
\`\`\`java
// 培训会话实体
@Entity
@Table(name = "qms_training_session")
@Data
public class TrainingSession {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plan_course_id", nullable = false)
    private PlanCourse planCourse;
    
    @Column(nullable = false)
    private LocalDate sessionDate;
    
    @Column(nullable = false)
    private String sessionTime; // "09:00-12:00"
    
    @Column(nullable = false)
    private String location;
    
    @Column(nullable = false)
    private SessionStatus status; // SCHEDULED, ONGOING, COMPLETED, CANCELLED
    
    @Column(nullable = false)
    private LocalDateTime startTime;
    
    @Column
    private LocalDateTime endTime;
    
    @Column(nullable = false)
    private Integer actualDuration; // 实际时长(分钟)
    
    @Column(nullable = false)
    private String sessionMode; // ONLINE, OFFLINE, HYBRID
    
    @Column(nullable = false)
    private String platform; // ZOOM, TEAMS, CLASSROOM
    
    @Column(length = 1000)
    private String sessionNotes;
    
    @Column(length = 500)
    private String recordingUrl;
    
    @OneToMany(mappedBy = "session", cascade = CascadeType.ALL)
    private List<SessionAttendance> attendance = new ArrayList<>();
    
    @OneToMany(mappedBy = "session", cascade = CascadeType.ALL)
    private List<SessionFeedback> feedback = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        startTime = LocalDateTime.now();
        actualDuration = 0;
    }
}

// 培训报名实体
@Entity
@Table(name = "qms_training_registration")
@Data
public class TrainingRegistration {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plan_course_id", nullable = false)
    private PlanCourse planCourse;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false)
    private RegistrationStatus status; // REGISTERED, COMPLETED, CANCELLED, FAILED
    
    @Column(nullable = false)
    private LocalDateTime registrationDate;
    
    @Column
    private LocalDateTime completionDate;
    
    @Column(nullable = false)
    private Integer progressPercentage; // 进度百分比
    
    @Column(nullable = false)
    private Long totalTimeSpent; // 总学习时间(分钟)
    
    @Column
    private BigDecimal finalScore; // 最终成绩
   `,$n=`# 舜富QMS系统 - 审核管理模块详细实现

## 1. 审核管理模块总览

### 1.1 审核模块架构设计

\`\`\`
┌─────────────────────────────────────────────────────────────┐
│               审核管理模块 - 微服务架构                      │
├─────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                审核业务流程层                            │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 内部审核     │ │ 外部审核     │ │ 分层审核     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                审核计划管理层                           │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 审核计划     │ │ 审核执行     │ │ 审核报告     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                审核数据层                               │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 审核记录     │ │ 审核发现     │ │ 审核整改     │       │  │
│  │  │PostgreSQL  │ │PostgreSQL   │ │MongoDB     │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2 审核类型体系

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                       审核类型体系                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                     审核体系                             │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │  内部审核    │    │  外部审核    │    │  专项审核    │         │
│  └─────────────┘    └─────────────┘    └─────────────┘         │
│       │                │                    │                   │
│  ┌────┴────┐    ┌──────┴──────┐    ┌────────┴────────┐       │
│  ▼         ▼    ▼             ▼    ▼                ▼       │
│ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐     │
││体系审核││过程审核││产品审核││合规审核││客户审核││认证审核││内审员审核││     │
│└─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘     │
│       │                │                    │                   │
│  ┌────┴────┐    ┌──────┴──────┐    ┌────────┴────────┐       │
│  │LPA审核  │    │供应商审核  │    │质量体系审核  │       │
│  └─────────┘    └──────────┬──┘    └──────────┬─────┘       │
│                          ↓                  ↓                │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                    分层审核 (LPA)                        │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │
│  │操作员审核  │ │主管审核  │ │经理审核  │ │高层审核  │           │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

---

## 2. 内部审核模块详细实现

### 2.1 内部审核流程

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                        内部审核流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ 审核计划  │───▶│ 组建团队  │───▶│ 审核准备  │                   │
│  └──────────┘    └──────────┘    └──────────┘                   │
│                               │                                │
│                  ┌────────────┴────────────┐                   │
│                  ▼                         ▼                   │
│           ┌──────────┐              ┌──────────┐               │
│           │ 文件审查  │              │ 现场审核  │               │
│           └──────────┘              └──────────┘               │
│                  │                        │                │
│           ┌──────┴──────┐               ┌─┴────┐            │
│           ▼              ▼               ▼      ▼             │
│  ┌──────────┐  ┌──────────┐     ┌──────────┐ ┌──────────┐      │
│  │ 资料验证  │  │ 证据收集  │     │ 发现确认  │ │ 不符合项  │      │
│  └──────────┘  └──────────┘     └──────────┘ └──────────┘      │
│                  │                        │                │
│           ┌──────┴──────┐               ┌─┴────┐            │
│           ▼              ▼               ▼      ▼             │
│  ┌──────────┐  ┌──────────┐     ┌──────────┐ ┌──────────┐      │
│  │ 初次会议  │  │ 现场审核  │     │ 末次会议  │ │ 报告编制  │      │
│  └──────────┘  └──────────┘     └──────────┘ └──────────┘      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 2.2 内部审核核心类设计

\`\`\`java
/**
 * 审核记录实体
 */
@Data
@Entity
@Table(name = "audit_record")
@DynamicUpdate
public class AuditRecord {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "audit_id")
    private Long auditId;
    
    @Column(name = "audit_number", unique = true, nullable = false)
    private String auditNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "audit_type", nullable = false)
    private AuditType auditType; // INTERNAL, EXTERNAL, SECOND_PARTY, SUPPLIER, LPA
    
    @Column(name = "audit_sub_type")
    private String auditSubType;
    
    @Column(name = "audit_category", nullable = false)
    private String auditCategory; // SYSTEM, PROCESS, PRODUCT, COMPLIANCE
    
    @Column(name = "audit_name", nullable = false)
    private String auditName;
    
    // 审核计划信息
    @Column(name = "planned_start_date", nullable = false)
    private LocalDate plannedStartDate;
    
    @Column(name = "planned_end_date", nullable = false)
    private LocalDate plannedEndDate;
    
    @Column(name = "actual_start_date")
    private LocalDate actualStartDate;
    
    @Column(name = "actual_end_date")
    private LocalDate actualEndDate;
    
    @Column(name = "audit_location", nullable = false)
    private String auditLocation;
    
    @Column(name = "audit_scope", columnDefinition = "TEXT")
    private String auditScope;
    
    @Column(name = "audit_standard", columnDefinition = "TEXT")
    private String auditStandard;
    
    @Column(name = "audit_method")
    private String auditMethod; // DOCUMENT_REVIEW, INTERVIEW, OBSERVATION
    
    @Column(name = "objective", columnDefinition = "TEXT")
    private String objective;
    
    @Column(name = "key_finding")
    private String keyFinding;
    
    @Column(name = "overall_rating")
    private String overallRating; // EXCELLENT, GOOD, SATISFACTORY, NEEDS_IMPROVEMENT, POOR
    
    @Enumerated(EnumType.STRING)
    @Column(name = "audit_status", nullable = false)
    private AuditStatus auditStatus; // PLANNING, IN_PROGRESS, COMPLETED, CLOSED
    
    @Column(name = "lead_auditor_id", nullable = false)
    private Long leadAuditorId;
    
    @Column(name = "lead_auditor_name", nullable = false)
    private String leadAuditorName;
    
    @Type(type = "json")
    @Column(name = "audit_team", columnDefinition = "jsonb")
    private AuditTeam auditTeam;
    
    @Type(type = "json")
    @Column(name = "standards", columnDefinition = "jsonb")
    private List<StandardReference> standards;
    
    @Type(type = "json")
    @Column(name = "findings", columnDefinition = "jsonb")
    private List<AuditFinding> findings;
    
    @Type(type = "json")
    @Column(name = "attachments", columnDefinition = "jsonb")
    private List<AuditAttachment> attachments;
    
    @Column(name = "report_summary", columnDefinition = "TEXT")
    private String reportSummary;
    
    @Column(name = "auditor_signature", columnDefinition = "TEXT")
    private String auditorSignature;
    
    @Column(name = "auditee_signature", columnDefinition = "TEXT")
    private String auditeeSignature;
    
    @Column(name = "approval_date")
    private LocalDate approvalDate;
    
    @Column(name = "approval_notes", columnDefinition = "TEXT")
    private String approvalNotes;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "created_time", nullable = false, updatable = false)
    private LocalDateTime createdTime;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
    
    // LPA特有字段
    @Enumerated(EnumType.STRING)
    @Column(name = "lpa_layer")
    private LPALayer lpaLayer; // OPERATOR, SUPERVISOR, MANAGER, EXECUTIVE
    
    @Column(name = "lpa_frequency")
    private String lpaFrequency; // DAILY, WEEKLY, MONTHLY, QUARTERLY
    
    @Column(name = "lpa_process_area")
    private String lpaProcessArea;
    
    @Column(name = "lpa_score")
    private Double lpaScore;
    
    @Column(name = "lpa_checklist")
    private String lpaChecklist;
}

/**
 * 审核发现实体
 */
@Data
@Entity
@Table(name = "audit_finding")
public class AuditFinding {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "finding_id")
    private Long findingId;
    
    @Column(name = "audit_id", nullable = false)
    private Long auditId;
    
    @Column(name = "finding_number")
    private String findingNumber;
    
    @Column(name = "finding_type")
    private FindingType findingType; // MAJOR_NC, MINOR_NC, OP_IMPROVEMENT, STRENGTH
    
    @Column(name = "reference_standard", nullable = false)
    private String referenceStandard;
    
    @Column(name = "reference_clause", nullable = false)
    private String referenceClause;
    
    @Column(name = "finding_description", columnDefinition = "TEXT", nullable = false)
    private String findingDescription;
    
    @Column(name = "evidence_description", columnDefinition = "TEXT", nullable = false)
    private String evidenceDescription;
    
    @Column(name = "effect_description", columnDefinition = "TEXT")
    private String effectDescription;
    
    @Column(name = "finding_severity", nullable = false)
    private FindingSeverity findingSeverity; // LOW, MEDIUM, HIGH
    
    @Column(name = "root_cause_analysis", columnDefinition = "TEXT")
    private String rootCauseAnalysis;
    
    @Column(name = "corrective_action_plan", columnDefinition = "TEXT")
    private String correctiveActionPlan;
    
    @Column(name = "target_completion_date")
    private LocalDate targetCompletionDate;
    
    @Column(name = "responsible_department")
    private String responsibleDepartment;
    
    @Column(name = "responsible_person_id")
    private Long responsiblePersonId;
    
    @Column(name = "responsible_person_name")
    private String responsiblePersonName;
    
    @Column(name = "verification_method")
    private String verificationMethod;
    
    @Column(name = "verification_date")
    private LocalDate verificationDate;
    
    @Column(name = "verification_result")
    private String verificationResult;
    
    @Column(name = "finding_status", nullable = false)
    private FindingStatus findingStatus; // OPEN, IN_PROGRESS, COMPLETED, VERIFIED
    
    @Column(name = "closure_date")
    private LocalDate closureDate;
    
    @Column(name = "closure_notes", columnDefinition = "TEXT")
    private String closureNotes;
    
    @Type(type = "json")
    @Column(name = "supporting_evidence", columnDefinition = "jsonb")
    private List<SupportingEvidence> supportingEvidence;
    
    @Type(type = "json")
    @Column(name = "verification_notes", columnDefinition = "jsonb")
    private List<VerificationNote> verificationNotes;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "created_time", nullable = false, updatable = false)
    private LocalDateTime createdTime;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
}
\`\`\`

### 2.3 内部审核计划服务

\`\`\`java
/**
 * 内部审核计划服务
 */
@Service
@Slf4j
@Transactional
public class InternalAuditPlanServiceImpl implements InternalAuditPlanService {
    
    @Autowired
    private AuditRecordRepository auditRecordRepository;
    
    @Autowired
    private DepartmentRepository departmentRepository;
    
    @Autowired
    private StandardService standardService;
    
    @Autowired
    private AuditTeamService auditTeamService;
    
    /**
     * 创建内部审核计划
     */
    @Override
    public AuditPlanDTO createAuditPlan(AuditPlanCreateDTO dto) {
        log.info("创建内部审核计划,审核类型: {}, 审核范围: {}", dto.getAuditType(), dto.getAuditScope());
        
        // 1. 验证数据完整性
        validateAuditPlanData(dto);
        
        // 2. 生成审核编号
        String auditNumber = generateAuditNumber(dto.getAuditType());
        
        // 3. 创建审核记录
        AuditRecord auditRecord = createAuditRecord(dto, auditNumber);
        
        // 4. 创建审核团队
        createAuditTeam(auditRecord);
        
        // 5. 创建审核检查清单
        createAuditChecklist(auditRecord);
        
        // 6. 发送通知
        sendAuditPlanNotification(auditRecord);
        
        log.info("内部审核计划创建成功,审核编号: {}", auditNumber);
        
        return convertToDTO(auditRecord);
    }
    
    /**
     * 创建审核记录
     */
    private AuditRecord createAuditRecord(AuditPlanCreateDTO dto, String auditNumber) {
        AuditRecord auditRecord = new AuditRecord();
        auditRecord.setAuditNumber(auditNumber);
        auditRecord.setAuditType(dto.getAuditType());
        auditRecord.setAuditSubType(dto.getAuditSubType());
        auditRecord.setAuditCategory(dto.getAuditCategory());
        auditRecord.setAuditName(dto.getAuditName());
        auditRecord.setPlannedStartDate(dto.getPlannedStartDate());
        auditRecord.setPlannedEndDate(dto.getPlannedEndDate());
        auditRecord.setAuditLocation(dto.getAuditLocation());
        auditRecord.setAuditScope(dto.getAuditScope());
        auditRecord.setAuditStandard(dto.getAuditStandard());
        auditRecord.setAuditMethod(dto.getAuditMethod());
        auditRecord.setObjective(dto.getObjective());
        auditRecord.setOverallRating("待定");
        auditRecord.setAuditStatus(AuditStatus.PLANNING);
        auditRecord.setLeadAuditorId(dto.getLeadAuditorId());
        auditRecord.setLeadAuditorName(dto.getLeadAuditorName());
        auditRecord.setCreatedBy(SecurityUtils.getCurrentUserId());
        auditRecord.setCreatedTime(LocalDateTime.now());
        
        // LPA审核特有字段
        if (dto.getAuditType() == AuditType.LPA) {
            auditRecord.setLpaLayer(dto.getLpaLayer());
            auditRecord.setLpaFrequency(dto.getLpaFrequency());
            auditRecord.setLpaProcessArea(dto.getLpaProcessArea());
            auditRecord.setLpaChecklist(dto.getLpaChecklist());
        }
        
        return auditRecordRepository.save(auditRecord);
    }
    
    /**
     * 创建审核团队
     */
    private void createAuditTeam(AuditRecord auditRecord) {
        // 1. 查询审核团队成员
        List<AuditTeamMember> teamMembers = auditTeamService.getAuditTeamMembers(
            auditRecord.getLeadAuditorId(), 
            auditRecord.getAuditType()
        );
        
        // 2. 设置审核团队信息
        AuditTeam auditTeam = new AuditTeam();
        auditTeam.setLeadAuditorId(auditRecord.getLeadAuditorId());
        auditTeam.setLeadAuditorName(auditRecord.getLeadAuditorName());
        auditTeam.setMembers(teamMembers);
        auditTeam.setTeamSize(teamMembers.size());
        auditRecord.setAuditTeam(auditTeam);
        
        auditRecordRepository.save(auditRecord);
    }
    
    /**
     * 审核计划执行
     */
    @Override
    public AuditExecutionDTO executeAudit(Long auditId, AuditExecuteDTO dto) {
        log.info("执行审核计划,审核ID: {}", auditId);
        
        // 1. 查询审核记录
        AuditRecord auditRecord = getAuditById(auditId);
        
        // 2. 验证审核状态
        if (AuditStatus.IN_PROGRESS != auditRecord.getAuditStatus()) {
            throw new BusinessException("审核计划处于" + auditRecord.getAuditStatus() + "状态,无法执行");
        }
        
        // 3. 更新审核信息
        auditRecord.setActualStartDate(dto.getActualStartDate());
        auditRecord.setActualEndDate(dto.getActualEndDate());
        auditRecord.setAuditStatus(AuditStatus.COMPLETED);
        auditRecord.setUpdatedBy(SecurityUtils.getCurrentUserId());
        auditRecord.setUpdatedTime(LocalDateTime.now());
        
        // 4. 处理审核发现
        processAuditFindings(auditRecord, dto.getFindings());
        
        // 5. 生成审核总结
        generateAuditSummary(auditRecord);
        
        // 6. 计算总体评级
        calculateOverallRating(auditRecord);
        
        auditRecord = auditRecordRepository.save(auditRecord);
        
        log.info("审核执行完成,审核编号: {}, 总体评级: {}", 
            auditRecord.getAuditNumber(), auditRecord.getOverallRating());
        
        return convertToExecutionDTO(auditRecord);
    }
    
    /**
     * 处理审核发现
     */
    private void processAuditFindings(AuditRecord auditRecord, List<AuditFindingCreateDTO> findingDTOs) {
        List<AuditFinding> findings = new ArrayList<>();
        
        for (AuditFindingCreateDTO dto : findingDTOs) {
            AuditFinding finding = new AuditFinding();
            BeanUtils.copyProperties(dto, finding);
            finding.setAuditId(auditRecord.getAuditId());
            finding.setFindingNumber(generateFindingNumber(auditRecord.getAuditId(), findings.size() + 1));
            finding.setFindingStatus(FindingStatus.OPEN);
            finding.setCreatedBy(SecurityUtils.getCurrentUserId());
            finding.setCreatedTime(LocalDateTime.now());
            
            findings.add(finding);
        }
        
        auditFindingRepository.saveAll(findings);
        auditRecord.setFindings(findings);
        
        log.info("审核发现处理完成,发现数量: {}, 不符合项: {}, 改进机会: {}", 
            findings.size(), 
            findings.stream().filter(f -> f.getFindingType() == FindingType.MAJOR_NC || 
                                         f.getFindingType() == FindingType.MINOR_NC).count(),
            findings.stream().filter(f -> f.getFindingType() == FindingType.OP_IMPROVEMENT).count());
    }
    
    /**
     * 计算总体评级
     */
    private void calculateOverallRating(AuditRecord auditRecord) {
        List<AuditFinding> findings = auditRecord.getFindings();
        
        if (findings == null || findings.isEmpty()) {
            auditRecord.setOverallRating("EXCELLENT");
            return;
        }
        
        // 统计发现类型
        long majorNCCount = findings.stream()
            .filter(f -> f.getFindingType() == FindingType.MAJOR_NC)
            .count();
            
        long minorNCCount = findings.stream()
            .filter(f -> f.getFindingType() == FindingType.MINOR_NC)
            .count();
            
        long opImprovementCount = findings.stream()
            .filter(f -> f.getFindingType() == FindingType.OP_IMPROVEMENT)
            .count();
            
        long strengthCount = findings.stream()
            .filter(f -> f.getFindingType() == FindingType.STRENGTH)
            .count();
        
        // 基于IATF16949评级标准
        if (majorNCCount > 0) {
            auditRecord.setOverallRating("NEEDS_IMPROVEMENT");
        } else if (minorNCCount <= 2) {
            if (strengthCount >= findings.size() * 0.5) {
                auditRecord.setOverallRating("EXCELLENT");
            } else {
                auditRecord.setOverallRating("GOOD");
            }
        } else if (minorNCCount <= 5) {
            auditRecord.setOverallRating("SATISFACTORY");
        } else {
            auditRecord.setOverallRating("POOR");
        }
        
        log.info("总体评级计算完成,严重不符合项: {}, 一般不符合项: {}, 改进机会: {}, 优势: {}", 
            majorNCCount, minorNCCount, opImprovementCount, strengthCount);
    }
}
\`\`\`

---

## 3. 分层审核(LPA)模块详细实现

### 3.1 LPA审核体系

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                     分层审核(LPA)体系                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                    审核层级                              │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                   4个审核层级                             │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │
│  │ 操作员  │ │ 主管审核  │ │经理审核  │ │高层审核  │           │
│  │ 审核     │ │ (LPA-3)  │ │ (LPA-2)  │ │ (LPA-1)  │           │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │
│       │                │                    │                   │
│  ┌────┴────┐    ┌──────┴──────┐    ┌────────┴────────┐       │
│  │生产现场  │    │ 质量控制     │    │  质量体系      │       │
│  │质量检查  │    │ 管理审核     │    │ 运行审核      │       │
│  └─────────┘    └──────────┬──┘    └──────────┬─────┘       │
│                          ↓                  ↓                │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                    LPA审核标准                            │     │
│  │ 1. 操作员关注现场执行和产品质量                            │     │
│  │ 2. 主管关注过程控制和质量控制                            │     │
│  │ 3. 经理关注体系运行和资源保障                            │     │
│  │ 4. 高层关注战略方向和管理绩效                            │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                   LPA频率要求                             │     │
│  │ 1. 操作员级: 每日审核                                    │     │
│  │ 2. 主管级: 每周审核                                      │     │
│  │ 3. 经理级: 每月审核                                      │     │
│  │ 4. 高层级: 每季度审核                                    │     │
│  └─────────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 3.2 LPA审核服务

\`\`\`java
/**
 * LPA审核服务
 */
@Service
@Slf4j
@Transactional
public class LayeredProcessAuditServiceImpl implements LayeredProcessAuditService {
    
    @Autowired
    private AuditRecordRepository auditRecordRepository;
    
    @Autowired
    private LPAChecklistRepository lpaChecklistRepository;
    
    @Autowired
    private LPARepository lpaRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 创建LPA审核计划
     */
    @Override
    public LPAPlanDTO createLPAPlan(LPAPlanCreateDTO dto) {
        log.info("创建LPA审核计划,审核层级: {}, 审核区域: {}", dto.getLpaLayer(), dto.getLpaProcessArea());
        
        // 1. 验证LPA层级
        validateLPALayer(dto.getLpaLayer());
        
        // 2. 获取LPA检查清单
        LPAChecklist checklist = getLPAChecklist(dto.getLpaLayer(), dto.getLpaProcessArea());
        
        // 3. 创建LPA审核记录
        LPA lpa = new LPA();
        BeanUtils.copyProperties(dto, lpa);
        lpa.setLpaNumber(generateLpaNumber(dto.getLpaLayer()));
        lpa.setStatus(LPAStatus.PLANNED);
        lpa.setChecklistId(checklist.getChecklistId());
        lpa.setCreatedBy(SecurityUtils.getCurrentUserId());
        lpa.setCreatedTime(LocalDateTime.now());
        
        lpa = lpaRepository.save(lpa);
        
        // 4. 生成LPA评分项目
        createLPAScoringItems(lpa, checklist);
        
        // 5. 发送计划通知
        sendLPAPlanNotification(lpa);
        
        log.info("LPA审核计划创建成功,LPA编号: {}", lpa.getLpaNumber());
        
        return convertToDTO(lpa);
    }
    
    /**
     * 执行LPA审核
     */
    @Override
    public LPAResultDTO executeLPA(Long lpaId, LPAExecuteDTO dto) {
        log.info("执行LPA审核,LPA ID: {}", lpaId);
        
        // 1. 查询LPA记录
        LPA lpa = getLPAById(lpaId);
        
        // 2. 验证审核状态
        if (LPAStatus.EXECUTED != lpa.getStatus()) {
            throw new BusinessException("LPA处于" + lpa.getStatus() + "状态,无法执行");
        }
        
        // 3. 更新审核状态
        lpa.setStatus(LPAStatus.COMPLETED);
        lpa.setActualExecutionTime(LocalDateTime.now());
        lpa.setAuditorId(SecurityUtils.getCurrentUserId());
        lpa.setAuditorName(SecurityUtils.getCurrentUserName());
        
        // 4. 处理评分项目
        processScoringItems(lpa, dto.getScoringItems());
        
        // 5. 计算LPA总分
        calculateLPAScore(lpa);
        
        // 6. 确定评级
        determineLPARating(lpa);
        
        lpa = lpaRepository.save(lpa);
        
        // 7. 生成LPA报告
        generateLPAReport(lpa);
        
        log.info("LPA审核执行完成,LPA编号: {}, 总分: {}, 评级: {}", 
            lpa.getLpaNumber(), lpa.getLpaScore(), lpa.getLpaRating());
        
        return convertToResultDTO(lpa);
    }
    
    /**
     * 处理评分项目
     */
    private void processScoringItems(LPA lpa, List<LPAScoringDTO> scoringDTOs) {
        for (LPAScoringDTO dto : scoringDTOs) {
            LPAScoringItem item = new LPAScoringItem();
            BeanUtils.copyProperties(dto, item);
            item.setLpaId(lpa.getLpaId());
            item.setScoringTime(LocalDateTime.now());
            
            lpaScoringItemRepository.save(item);
        }
        
        log.info("LPA评分项目处理完成,评分数量: {}", scoringDTOs.size());
    }
    
    /**
     * 计算LPA总分
     */
    private void calculateLPAScore(LPA lpa) {
        List<LPAScoringItem> scoringItems = lpaScoringItemRepository.findByLpaId(lpa.getLpaId());
        
        double totalScore = 0;
        double maxPossibleScore = 0;
        
        for (LPAScoringItem item : scoringItems) {
            totalScore += item.getScore() * item.getWeight();
            maxPossibleScore += item.getMaxScore() * item.getWeight();
        }
        
        // 计算标准化分数 (0-100)
        double normalizedScore = (totalScore / maxPossibleScore) * 100;
        
        lpa.setLpaScore(Math.round(normalizedScore * 100.0) / 100.0); // 保留两位小数
        lpa.setMaxScore(maxPossibleScore);
        
        log.info("LPA总分计算完成,原始总分: {}, 标准化分数: {}", totalScore, normalizedScore);
    }
    
    /**
     * 确定LPA评级
     */
    private void determineLPARating(LPA lpa) {
        double score = lpa.getLpaScore();
        
        // LPA评级标准
        if (score >= 90) {
            lpa.setLpaRating("EXEMPLARY");
            lpa.setRatingDescription("卓越表现");
        } else if (score >= 80) {
            lpa.setLpaRating("STRONG");
            lpa.setRatingDescription("表现优秀");
        } else if (score >= 70) {
            lpa.setLpaRating("SATISFACTORY");
            lpa.setRatingDescription("表现满意");
        } else if (score >= 60) {
            lpa.setLpaRating("NEEDS_IMPROVEMENT");
            lpa.setRatingDescription("需要改进");
        } else {
            lpa.setLpaRating("POOR");
            lpa.setRatingDescription("表现较差");
        }
        
        log.info("LPA评级确定完成,分数: {}, 评级: {}", score, lpa.getLpaRating());
    }
    
    /**
     * 生成LPA趋势分析
     */
    @Override
    public LPATrendAnalysisDTO analyzeLPATrend(Long lpaLayer, Long processAreaId, String period) {
        log.info("分析LPA趋势,审核层级: {}, 区域: {}, 周期: {}", lpaLayer, processAreaId, period);
        
        LPATrendAnalysisDTO trendAnalysis = new LPATrendAnalysisDTO();
        
        // 1. 查询历史LPA记录
        List<LPA> historicalLPAs = getHistoricalLPAs(lpaLayer, processAreaId, period);
        
        // 2. 计算趋势指标
        calculateTrendMetrics(trendAnalysis, historicalLPAs);
        
        // 3. 分析质量趋势
        analyzeQualityTrend(trendAnalysis, historicalLPAs);
        
        // 4. 分析改进趋势
        analyzeImprovementTrend(trendAnalysis, historicalLPAs);
        
        // 5. 生成趋势报告
        generateTrendReport(trendAnalysis, historicalLPAs);
        
        log.info("LPA趋势分析完成,审核记录数量: {}", historicalLPAs.size());
        
        return trendAnalysis;
    }
    
    /**
     * 计算趋势指标
     */
    private void calculateTrendMetrics(LPATrendAnalysisDTO trendAnalysis, List<LPA> historicalLPAs) {
        if (historicalLPAs.isEmpty()) {
            return;
        }
        
        // 1. 计算平均分
        double averageScore = historicalLPAs.stream()
            .mapToDouble(LPA::getLpaScore)
            .average()
            .orElse(0.0);
        trendAnalysis.setAverageScore(averageScore);
        
        // 2. 计算最高分和最低分
        OptionalDouble maxScore = historicalLPAs.stream()
            .mapToDouble(LPA::getLpaScore)
            .max();
        trendAnalysis.setMaxScore(maxScore.orElse(0.0));
        
        OptionalDouble minScore = historicalLPAs.stream()
            .mapToDouble(LPA::getLpaScore)
            .min();
        trendAnalysis.setMinScore(minScore.orElse(0.0));
        
        // 3. 计算稳定性指标
        double variance = calculateVariance(
            historicalLPAs.stream()
                .mapToDouble(LPA::getLpaScore)
                .toArray()
        );
        trendAnalysis.setVariance(variance);
        trendAnalysis.setStabilityScore(calculateStabilityScore(variance));
        
        // 4. 计算改进率
        double improvementRate = calculateImprovementRate(historicalLPAs);
        trendAnalysis.setImprovementRate(improvementRate);
    }
    
    /**
     * 分析质量趋势
     */
    private void analyzeQualityTrend(LPATrendAnalysisDTO trendAnalysis, List<LPA> historicalLPAs) {
        // 1. 统计各评级分布
        Map<String, Long> ratingDistribution = historicalLPAs.stream()
            .collect(Collectors.groupingBy(
                LPA::getLpaRating,
                Collectors.counting()
            ));
        trendAnalysis.setRatingDistribution(ratingDistribution);
        
        // 2. 计算质量得分率
        double qualityScoreRate = calculateQualityScoreRate(ratingDistribution);
        trendAnalysis.setQualityScoreRate(qualityScoreRate);
        
        // 3. 判断趋势方向
        TrendDirection direction = determineTrendDirection(historicalLPAs);
        trendAnalysis.setTrendDirection(direction);
        
        // 4. 分析趋势原因
        List<TrendFactor> trendFactors = analyzeTrendFactors(historicalLPAs);
        trendAnalysis.setTrendFactors(trendFactors);
    }
    
    /**
     * 自动LPA审核提醒
     */
    @Scheduled(cron = "0 0 9 * * ?") // 每天9点执行
    public void autoLPAReminder() {
        log.info("执行LPA审核自动提醒");
        
        // 1. 查询需要执行的LPA
        List<LPA> pendingLPAs = lpaRepository
            .findPendingLPAs(LocalDate.now());
        
        for (LPA lpa : pendingLPAs) {
            // 2. 生成提醒通知
            sendLPAReminderNotification(lpa);
            
            // 3. 更新提醒状态
            lpa.setReminderSent(true);
            lpaRepository.save(lpa);
        }
        
        log.info("LPA提醒完成,提醒数量: {}", pendingLPAs.size());
    }
}
\`\`\`

---

## 4. 外部审核模块详细实现

### 4.1 外部审核流程管理

\`\`\`java
/**
 * 外部审核管理服务
 */
@Service
@Slf4j
@Transactional
public class ExternalAuditManagementServiceImpl implements ExternalAuditManagementService {
    
    @Autowired
    private ExternalAuditRepository externalAuditRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private CertificationRepository certificationRepository;
    
    @Autowired
    private AuditPreparationService auditPreparationService;
    
    /**
     * 创建外部审核计划
     */
    @Override
    public ExternalAuditDTO createExternalAudit(ExternalAuditCreateDTO dto) {
        log.info("创建外部审核计划,审核类型: {}, 审核机构: {}", dto.getAuditType(), dto.getAuditorName());
        
        // 1. 验证审核类型
        validateExternalAuditType(dto.getAuditType());
        
        // 2. 创建外部审核记录
        ExternalAudit externalAudit = new ExternalAudit();
        BeanUtils.copyProperties(dto, externalAudit);
        externalAudit.setAuditNumber(generateExternalAuditNumber(dto.getAuditType()));
        externalAudit.setAuditStatus(ExternalAuditStatus.PLANNED);
        externalAudit.setCreatedBy(SecurityUtils.getCurrentUserId());
        externalAudit.setCreatedTime(LocalDateTime.now());
        
        // 3. 处理客户审核
        if (dto.getAuditType() == ExternalAuditType.CUSTOMER) {
            Customer customer = customerRepository.findById(dto.getRelatedEntityId()).orElse(null);
            if (customer != null) {
                externalAudit.setCustomerName(customer.getCustomerName());
            }
        }
        
        // 4. 处理认证审核
        if (dto.getAuditType() == ExternalAuditType.CERTIFICATION) {
            Certification certification = certificationRepository.findById(dto.getRelatedEntityId()).orElse(null);
            if (certification != null) {
                externalAudit.setCertificationName(certification.getCertificationName());
            }
        }
        
        externalAudit = externalAuditRepository.save(externalAudit);
        
        // 5. 创建审核准备工作
        auditPreparationService.createAuditPreparation(externalAudit);
        
        // 6. 发送通知
        sendExternalAuditNotification(externalAudit);
        
        log.info("外部审核计划创建成功,审核编号: {}", externalAudit.getAuditNumber());
        
        return convertToDTO(externalAudit);
    }
    
    /**
     * 审核前准备管理
     */
    @Override
    public AuditPreparationResultDTO prepareForAudit(Long auditId, AuditPreparationDTO dto) {
        log.info("准备外部审核,审核ID: {}", auditId);
        
        // 1. 查询外部审核记录
        ExternalAudit externalAudit = getExternalAuditById(auditId);
        
        // 2. 更新审核准备状态
        externalAudit.setPreparationStatus(PreparationStatus.IN_PROGRESS);
        externalAuditRepository.save(externalAudit);
        
        // 3. 准备审核文档
        prepareAuditDocuments(externalAudit, dto.getDocumentChecklist());
        
        // 4. 准备审核人员
        prepareAuditPersonnel(externalAudit, dto.getPersonnelList());
        
        // 5. 准备审核现场
        prepareAuditSite(externalAudit, dto.getSitePreparation());
        
        // 6. 模拟审核
        if (dto.isConductMockAudit()) {
            conductMockAudit(externalAudit);
        }
        
        // 7. 完成准备
        externalAudit.setPreparationStatus(PreparationStatus.COMPLETED);
        externalAudit.setPreparationCompletedTime(LocalDateTime.now());
        externalAuditRepository.save(externalAudit);
        
        // 8. 发送准备完成通知
        sendAuditPreparationCompletedNotification(externalAudit);
        
        log.info("审核准备完成,审核编号: {}", externalAudit.getAuditNumber());
        
        return convertToPreparationResultDTO(externalAudit);
    }
    
    /**
     * 审核过程跟踪
     */
    @Override
    public AuditTrackingDTO trackAuditProgress(Long auditId) {
        log.info("跟踪审核进度,审核ID: {}", auditId);
        
        // 1. 查询审核信息
        ExternalAudit externalAudit = getExternalAuditById(auditId);
        
        // 2. 构建跟踪信息
        AuditTrackingDTO tracking = new AuditTrackingDTO();
        tracking.setAuditId(auditId);
        tracking.setAuditNumber(externalAudit.getAuditNumber());
        tracking.setAuditType(externalAudit.getAuditType());
        tracking.setAuditStatus(externalAudit.getAuditStatus());
        
        // 3. 获取审核进度
        List<AuditMilestone> milestones = getAuditMilestones(auditId);
        tracking.setMilestones(milestones);
        
        // 4. 计算完成进度
        double progress = calculateAuditProgress(milestones);
        tracking.setProgress(progress);
        
        // 5. 获取当前阶段
        AuditPhase currentPhase = getCurrentAuditPhase(milestones);
        tracking.setCurrentPhase(currentPhase);
        
        // 6. 获取待办事项
        List<AuditTask> pendingTasks = getPendingAuditTasks(auditId);
        tracking.setPendingTasks(pendingTasks);
        
        return tracking;
    }
    
    /**
     * 审核后改进管理
     */
    @Override
    public AuditImprovementDTO manageAuditImprovements(Long auditId) {
        log.info("管理审核后改进,审核ID: {}", auditId);
        
        // 1. 查询外部审核记录
        ExternalAudit externalAudit = getExternalAuditById(auditId);
        
        // 2. 处理审核发现
        processAuditFindings(externalAudit);
        
        // 3. 制定改进计划
        createImprovementPlan(externalAudit);
        
        // 4. 跟踪改进进度
        trackImprovementProgress(externalAudit);
        
        // 5. 验证改进效果
        verifyImprovements(externalAudit);
        
        // 6. 生成审核报告
        generateAuditReport(externalAudit);
        
        // 7. 关闭审核
        closeAudit(externalAudit);
        
        log.info("审核后改进管理完成,审核编号: {}", externalAudit.getAuditNumber());
        
        return convertToImprovementDTO(externalAudit);
    }
}
\`\`\`

---

## 5. 审核管理模块集成与扩展

### 5.1 审核文档管理系统

\`\`\`java
/**
 * 审核文档管理服务
 */
@Service
@Slf4j
public class AuditDocumentManagementServiceImpl implements AuditDocumentManagementService {
    
    @Autowired
    private AuditDocumentRepository auditDocumentRepository;
    
    @Autowired
    private DocumentStorageService documentStorageService;
    
    /**
     * 上传审核文档
     */
    @Override
    public AuditDocumentDTO uploadAuditDocument(Long auditId, AuditDocumentUploadDTO dto) {
        log.info("上传审核文档,审核ID: {}, 文档类型: {}", auditId, dto.getDocumentType());
        
        // 1. 验证审核状态
        validateAuditDocumentUpload(auditId);
        
        // 2. 处理文档上传
        String documentUrl = processDocumentUpload(dto);
        
        // 3. 创建审核文档记录
        AuditDocument auditDocument = new AuditDocument();
        auditDocument.setAuditId(auditId);
        auditDocument.setDocumentName(dto.getDocumentName());
        auditDocument.setDocumentType(dto.getDocumentType());
        auditDocument.setDocumentUrl(documentUrl);
        auditDocument.setFileSize(dto.getFileSize());
        auditDocument.setContentType(dto.getContentType());
        auditDocument.setUploadedBy(SecurityUtils.getCurrentUserId());
        auditDocument.setUploadTime(LocalDateTime.now());
        
        auditDocument = auditDocumentRepository.save(auditDocument);
        
        // 4. 记录审核文档变更
        logDocumentUpload(auditDocument);
        
        log.info("审核文档上传成功,文档ID: {}", auditDocument.getDocumentId());
        
        return convertToDTO(auditDocument);
    }
    
    /**
     * 审核文档版本管理
     */
    @Override
    public AuditDocumentVersionDTO manageDocumentVersion(Long documentId, DocumentVersionDTO dto) {
        log.info("管理文档版本,文档ID: {}", documentId);
        
        // 1. 创建新版本
        AuditDocumentVersion newVersion = createNewVersion(documentId, dto);
        
        // 2. 标记旧版本为历史版本
        markOldVersionsAsHistorical(documentId);
        
        // 3. 记录版本变更
        logVersionChange(newVersion);
        
        log.info("文档版本管理完成,文档ID: {}, 版本号: {}", documentId, newVersion.getVersionNumber());
        
        return convertToVersionDTO(newVersion);
    }
    
    /**
     * 审核文档智能检索
 */
    @Override
    public List<AuditDocumentDTO> searchAuditDocuments(AuditDocumentSearchDTO dto) {
        log.info("搜索审核文档,审核ID: {}, 关键词: {}", dto.getAuditId(), dto.getSearchKeyword());
        
        // 1. 构建查询条件
        Example<AuditDocument> example = buildSearchExample(dto);
        
        // 2. 执行文档检索
        List<AuditDocument> documents = auditDocumentRepository.findAll(example);
        
        // 3. 对文档进行相关性评分
        List<AuditDocumentScored> scoredDocuments = scoreDocuments(documents, dto);
        
        // 4. 按相关性排序
        scoredDocuments.sort(Comparator.comparing(AuditDocumentScored::getRelevanceScore).reversed());
        
        // 5. 转换为DTO并返回
        return convertToDTOList(scoredDocuments.stream()
            .map(AuditDocumentScored::getDocument)
            .collect(Collectors.toList()));
    }
    
    /**
     * 审核文档分析
     */
    @Override
    public AuditDocumentAnalysisDTO analyzeAuditDocuments(Long auditId) {
        log.info("分析审核文档,审核ID: {}", auditId);
        
        AuditDocumentAnalysisDTO analysis = new AuditDocumentAnalysisDTO();
        
        // 1. 统计文档分布
        Map<String, Long> documentTypeDistribution = auditDocumentRepository
            .countDocumentsByType(auditId);
        analysis.setDocumentTypeDistribution(documentTypeDistribution);
        
        // 2. 分析文档质量
        List<DocumentQualityIssue> qualityIssues = analyzeDocumentQuality(auditId);
        analysis.setQualityIssues(qualityIssues);
        
        // 3. 生成文档完整性报告
        DocumentCompletenessReport completenessReport = generateCompletenessReport(auditId);
        analysis.setCompletenessReport(completenessReport);
        
        // 4. 提供改进建议
        List<Recommendation> recommendations = generateDocumentRecommendations(analysis);
        analysis.setRecommendations(recommendations);
        
        return analysis;
    }
}
\`\`\`

### 5.2 审核培训与知识管理

\`\`\`java
/**
 * 审核培训服务
 */
@Service
@Slf4j
public class AuditTrainingServiceImpl implements AuditTrainingService {
    
    @Autowired
    private AuditTrainingRepository auditTrainingRepository;
    
    @Autowired
    private TrainingMaterialRepository trainingMaterialRepository;
    
    /**
     * 创建审核培训计划
     */
    @Override
    public AuditTrainingDTO createAuditTraining(AuditTrainingCreateDTO dto) {
        log.info("创建审核培训计划,培训类型: {}, 目标群体: {}", dto.getTrainingType(), dto.getTargetAudience());
        
        // 1. 创建培训记录
        AuditTraining training = new AuditTraining();
        BeanUtils.copyProperties(dto, training);
        training.setTrainingStatus(TrainingStatus.PLANNED);
        training.setTrainingNumber(generateTrainingNumber());
        training.setCreatedBy(SecurityUtils.getCurrentUserId());
        training.setCreatedTime(LocalDateTime.now());
        
        training = auditTrainingRepository.save(training);
        
        // 2. 分配培训讲师
        assignTrainingInstructors(training);
        
        // 3. 生成培训材料
        generateTrainingMaterials(training);
        
        // 4. 通知参训人员
        notifyTrainees(training);
        
        log.info("审核培训计划创建成功,培训编号: {}", training.getTrainingNumber());
        
        return convertToDTO(training);
    }
    
    /**
     * 审核知识库管理
     */
    @Override
    public AuditKnowledgeDTO manageAuditKnowledge(AuditKnowledgeCreateDTO dto) {
        log.info("管理审核知识,知识类型: {}, 标题: {}", dto.getKnowledgeType(), dto.getTitle());
        
        // 1. 创建知识条目
        AuditKnowledge knowledge = new AuditKnowledge();
        BeanUtils.copyProperties(dto, knowledge);
        knowledge.setKnowledgeStatus(KnowledgeStatus.ACTIVE);
        knowledge.setViewCount(0);
        knowledge.setRating(0.0);
        knowledge.setRatingCount(0);
        
        knowledge = auditKnowledgeRepository.save(knowledge);
        
        // 2. 关联相关审核
        associateWithAudits(knowledge);
        
        // 3. 索引知识内容
        indexKnowledgeContent(knowledge);
        
        log.info("审核知识创建成功,知识ID: {}", knowledge.getKnowledgeId());
        
        return convertToKnowledgeDTO(knowledge);
    }
    
    /**
     * 内部知识推荐
     */
    @Override
    public List<AuditKnowledgeDTO> recommendAuditKnowledge(Long userId, String context) {
        log.info("推荐审核知识,用户ID: {}, 上下文: {}", userId, context);
        
        List<AuditKnowledgeDTO> recommendations = new ArrayList<>();
        
        // 1. 基于用户历史推荐
        List<AuditKnowledge> userHistoryBased = recommendByUserHistory(userId);
        recommendations.addAll(convertToKnowledgeDTOList(userHistoryBased));
        
        // 2. 基于当前审核场景推荐
        List<AuditKnowledge> auditContextBased = recommendByAuditContext(context);
        recommendations.addAll(convertToKnowledgeDTOList(auditContextBased));
        
        // 3. 基于热门内容推荐
        List<AuditKnowledge> popularBased = recommendByPopularity();
        recommendations.addAll(convertToKnowledgeDTOList(popularBased));
        
        // 4. 去重并按相关性排序
        return deduplicateAndSort(recommendations);
    }
    
    /**
     * 审核技能评估
     */
    @Override
    public AuditSkillAssessmentDTO assessAuditSkills(Long auditorId) {
        log.info("评估审核技能,审核员ID: {}", auditorId);
        
        AuditSkillAssessmentDTO assessment = new AuditSkillAssessmentDTO();
        
        // 1. 收集审核员参与记录
        List<AuditRecord> auditorAudits = auditRecordRepository.findByLeadAuditorId(auditorId);
        
        // 2. 评估审核技能
        List<SkillScore> skillScores = assessSkills(auditorAudits);
        assessment.setSkillScores(skillScores);
        
        // 3. 计算综合评分
        double overallScore = calculateOverallSkillScore(skillScores);
        assessment.setOverallScore(overallScore);
        
        // 4. 确定技能等级
        SkillLevel skillLevel = determineSkillLevel(overallScore);
        assessment.setSkillLevel(skillLevel);
        
        // 5. 生成改进建议
        List<ImprovementSuggestion> suggestions = generateSkillImprovementSuggestions(skillScores);
        assessment.setImprovementSuggestions(suggestions);
        
        return assessment;
    }
}
\`\`\`

---

## 总结

本详细实现规范为舜富QMS系统的审核管理模块提供了:

1. **内部审核**: 完整的审核计划、执行、发现处理、报告生成流程
2. **分层审核(LPA)**: 四层审核体系、智能评分、趋势分析、自动提醒
3. **外部审核**: 客户审核、认证审核、审核准备、过程跟踪、改进管理
4. **文档管理**: 文档上传、版本控制、智能检索、质量分析
5. **培训知识**: 审核培训计划、知识库管理、智能推荐、技能评估

所有实现遵循IATF16949审核要求,支持压铸行业特殊审核需求,提供智能化的审核管理解决方案。
`,ne=`# 舜富QMS系统 - 报表分析与决策支持模块详细实现

## 1. 报表分析模块总览

### 1.1 模块架构设计

\`\`\`
┌─────────────────────────────────────────────────────────────┐
│               报表分析模块 - 微服务架构                       │
├─────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                业务分析层                                │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 质量分析     │ │ 过程分析     │ │ 成本分析     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                数据处理层                                │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 数据聚合     │ │ 统计分析     │ │ 趋势分析     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                报表生成层                                │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 图表生成     │ │ 报表模板     │ │ 数据导出     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                数据存储层                                │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ 关系型数据   │ │ 时序数据     │ │ 文档存储     │       │  │
│  │  │PostgreSQL  │ │InfluxDB     │ │MongoDB     │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2 报表分类体系

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                        报表分类体系                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                   报表体系                              │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │
│  │ 质量报表  │ │ 过程报表  │ │ 成本报表  │ │ 管理报表  │           │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │
│       │                │                    │                   │
│  ┌────┴────┐    ┌──────┴──────┐    ┌────────┴────────┐       │
│  │检验报告  │    │SPC报表     │    │质量成本        │       │
│  │审核报告  │    │过程能力    │    │不良品成本      │       │
│  │客户投诉  │    │设备可用性  │    │质量改进收益    │       │
│  │供应商评价│    │生产效率    │    │管理成本        │       │
│  └─────────┘    └──────────┬──┘    └──────────┬─────┘       │
│                          ↓                  ↓                │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                   报表频率                              │     │
│  │ 实时报表: 分钟级响应 日报: 每日生成                     │     │
│  │ 周报: 每周生成 月报: 每月生成 年报: 每年生成             │     │
│  └─────────────────────────────────────────────────────────┘     │
│                              ↓                                  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │
│  │实时看板  │ │质量日报   │ │质量周报   │ │质量月报   │           │
│  │异常警报  │ │生产日报   │ │过程分析   │ │成本分析   │           │
│  │设备监控  │ │检验日报   │ │审核报告   │ │管理报告   │           │
│  │工艺参数  │ │成本日报   │ │改进追踪   │ │年度总结   │           │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

---

## 2. 质量分析报表详细实现

### 2.1 质量数据分析服务

\`\`\`java
/**
 * 质量数据分析服务
 */
@Service
@Slf4j
public class QualityAnalysisServiceImpl implements QualityAnalysisService {
    
    @Autowired
    private IQCInspectionRecordRepository iqcInspectionRecordRepository;
    
    @Autowired
    private FQCInspectionRecordRepository fqcInspectionRecordRepository;
    
    @Autowired
    private CustomerComplaintRepository customerComplaintRepository;
    
    @Autowired
    private CAPARepository capaRepository;
    
    @Autowired
    private AnalysisService analysisService;
    
    /**
     * 生成质量日报
     */
    @Override
    public QualityDailyReportDTO generateDailyReport(LocalDate date) {
        log.info("生成质量日报,日期: {}", date);
        
        QualityDailyReportDTO report = new QualityDailyReportDTO();
        report.setReportDate(date);
        report.setReportType("DAILY");
        
        // 1. IQC数据分析
        IQCDailyStats iqcStats = analyzeIQCDailyStats(date);
        report.setIqcStats(iqcStats);
        
        // 2. FQC数据分析
        FQCDailyStats fqcStats = analyzeFQCDailyStats(date);
        report.setFqcStats(fqcStats);
        
        // 3. 不良品分析
        DefectDailyStats defectStats = analyzeDefectDailyStats(date);
        report.setDefectStats(defectStats);
        
        // 4. 客户投诉分析
        ComplaintDailyStats complaintStats = analyzeComplaintDailyStats(date);
        report.setComplaintStats(complaintStats);
        
        // 5. CAPA分析
        CAPADailyStats capaStats = analyzeCAPADailyStats(date);
        report.setCapaStats(capaStats);
        
        // 6. 质量趋势分析
        QualityTrendDTO trend = analyzeQualityTrend(date);
        report.setQualityTrend(trend);
        
        // 7. 质量预警
        List<QualityAlertDTO> alerts = generateQualityAlerts(date);
        report.setQualityAlerts(alerts);
        
        return report;
    }
    
    /**
     * IQC日统计
     */
    private IQCDailyStats analyzeIQCDailyStats(LocalDate date) {
        log.debug("分析IQC日统计,日期: {}", date);
        
        IQCDailyStats stats = new IQCDailyStats();
        
        // 1. 统计检验批次
        long totalBatches = iqcInspectionRecordRepository
            .countByInspectionDate(date);
        stats.setTotalBatches(totalBatches);
        
        // 2. 统计供应商数量
        long supplierCount = iqcInspectionRecordRepository
            .countDistinctSuppliersByInspectionDate(date);
        stats.setSupplierCount(supplierCount);
        
        // 3. 统计合格率
        double acceptanceRate = calculateIQCAcceptanceRate(date);
        stats.setAcceptanceRate(acceptanceRate);
        
        // 4. 统计批次合格率
        double batchAcceptanceRate = calculateBatchAcceptanceRate(date);
        stats.setBatchAcceptanceRate(batchAcceptanceRate);
        
        // 5. 不合格品统计
        NonconformingStats nonconformingStats = calculateNonconformingStats(date, "IQC");
        stats.setNonconformingStats(nonconformingStats);
        
        // 6. 主要缺陷分析
        List<MainDefectDTO> mainDefects = analyzeMainDefects(date, "IQC");
        stats.setMainDefects(mainDefects);
        
        return stats;
    }
    
    /**
     * IQC合格率计算
     */
    private double calculateIQCAcceptanceRate(LocalDate date) {
        // 查询当天的IQC检验记录
        List<IQCInspectionRecord> records = iqcInspectionRecordRepository
            .findByInspectionDate(date);
        
        if (records.isEmpty()) {
            return 100.0; // 无数据默认100%合格
        }
        
        long acceptedCount = records.stream()
            .filter(r -> InspectionResult.ACCEPT == r.getInspectionResult())
            .count();
        
        return (double) acceptedCount / records.size() * 100;
    }
    
    /**
     * 批次合格率计算
     */
    private double calculateBatchAcceptanceRate(LocalDate date) {
        // 查询当天所有批次
        List<String> batchNumbers = iqcInspectionRecordRepository
            .findDistinctBatchNumbersByInspectionDate(date);
        
        if (batchNumbers.isEmpty()) {
            return 100.0;
        }
        
        long acceptedBatches = batchNumbers.stream()
            .filter(batch -> isBatchAccepted(batch, date))
            .count();
        
        return (double) acceptedBatches / batchNumbers.size() * 100;
    }
    
    /**
     * 判断批次是否合格
     */
    private boolean isBatchAccepted(String batchNumber, LocalDate date) {
        List<IQCInspectionRecord> batchRecords = iqcInspectionRecordRepository
            .findByBatchNumberAndInspectionDate(batchNumber, date);
        
        return batchRecords.stream()
            .allMatch(r -> InspectionResult.ACCEPT == r.getInspectionResult());
    }
    
    /**
     * FQC日统计
     */
    private FQCDailyStats analyzeFQCDailyStats(LocalDate date) {
        log.debug("分析FQC日统计,日期: {}", date);
        
        FQCDailyStats stats = new FQCDailyStats();
        
        // 1. 统计检验批次
        long totalBatches = fqcInspectionRecordRepository
            .countByInspectionDate(date);
        stats.setTotalBatches(totalBatches);
        
        // 2. 统计合格率
        double acceptanceRate = calculateFQCAcceptanceRate(date);
        stats.setAcceptanceRate(acceptanceRate);
        
        // 3. 不良品率分析
        double nonconformingRate = calculateFQCLotAcceptanceRate(date);
        stats.setLotAcceptanceRate(nonconformingRate);
        
        // 4. 产品质量分析
        List<ProductQualityDTO> productQualities = analyzeProductQualities(date);
        stats.setProductQualities(productQualities);
        
        return stats;
    }
    
    /**
     * 质量趋势分析
     */
    private QualityTrendDTO analyzeQualityTrend(LocalDate date) {
        log.debug("分析质量趋势,日期: {}", date);
        
        QualityTrendDTO trend = new QualityTrendDTO();
        trend.setCurrentDate(date);
        
        // 1. 计算7天趋势
        List<QualityMetricDTO> weeklyTrend = calculateWeeklyTrend(date);
        trend.setWeeklyTrend(weeklyTrend);
        
        // 2. 计算30天趋势
        List<QualityMetricDTO> monthlyTrend = calculateMonthlyTrend(date);
        trend.setMonthlyTrend(monthlyTrend);
        
        // 3. 计算年度趋势
        List<QualityMetricDTO> yearlyTrend = calculateYearlyTrend(date);
        trend.setYearlyTrend(yearlyTrend);
        
        // 4. 趋势预警
        List<TrendAlertDTO> trendAlerts = generateTrendAlerts(weeklyTrend, monthlyTrend);
        trend.setTrendAlerts(trendAlerts);
        
        return trend;
    }
    
    /**
     * 周趋势计算
     */
    private List<QualityMetricDTO> calculateWeeklyTrend(LocalDate endDate) {
        LocalDate startDate = endDate.minusDays(6);
        List<QualityMetricDTO> weeklyData = new ArrayList<>();
        
        for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
            QualityMetricDTO metric = new QualityMetricDTO();
            metric.setDate(date);
            metric.setMetricDate(date);
            
            // 获取当天的质量指标
            double iqcRate = calculateIQCAcceptanceRate(date);
            double fqcRate = calculateFQCAcceptanceRate(date);
            double complaintCount = getComplaintCountByDate(date);
            
            metric.setIqcAcceptanceRate(iqcRate);
            metric.setFqcAcceptanceRate(fqcRate);
            metric.setComplaintCount(complaintCount);
            
            weeklyData.add(metric);
        }
        
        return weeklyData;
    }
    
    /**
     * 生成质量预警
     */
    private List<QualityAlertDTO> generateQualityAlerts(LocalDate date) {
        List<QualityAlertDTO> alerts = new ArrayList<>();
        
        // 1. 合格率预警
        double iqcRate = calculateIQCAcceptanceRate(date);
        if (iqcRate < 95.0) {
            QualityAlertDTO alert = createQualityAlert(
                "IQC合格率过低", 
                "IQC合格率低于95%,当前:" + iqcRate + "%", 
                AlertLevel.WARNING
            );
            alerts.add(alert);
        }
        
        // 2. 不良品率预警
        double defectRate = calculateDefectRate(date);
        if (defectRate > 2.0) {
            QualityAlertDTO alert = createQualityAlert(
                "不良品率过高", 
                "不良品率高于2%,当前:" + defectRate + "%", 
                AlertLevel.CRITICAL
            );
            alerts.add(alert);
        }
        
        // 3. 客户投诉预警
        long complaintCount = getComplaintCountByDate(date);
        if (complaintCount > 5) {
            QualityAlertDTO alert = createQualityAlert(
                "客户投诉过多", 
                "当天客户投诉数量超过5件,当前:" + complaintCount + "件", 
                AlertLevel.WARNING
            );
            alerts.add(alert);
        }
        
        // 4. CAPA超期预警
        List<CAPA> overdueCAPAs = findOverdueCAPAs(date);
        if (!overdueCAPAs.isEmpty()) {
            QualityAlertDTO alert = createQualityAlert(
                "CAPA措施超期", 
                "有" + overdueCAPAs.size() + "项CAPA措施超期未完成", 
                AlertLevel.WARNING
            );
            alerts.add(alert);
        }
        
        return alerts;
    }
    
    /**
     * 生成质量周报
     */
    @Override
    public QualityWeeklyReportDTO generateWeeklyReport(LocalDate weekDate) {
        log.info("生成质量周报,日期: {}", weekDate);
        
        QualityWeeklyReportDTO report = new QualityWeeklyReportDTO();
        report.setReportDate(weekDate);
        report.setReportType("WEEKLY");
        
        // 1. 本周统计汇总
        WeeklyQualitySummary summary = analyzeWeeklySummary(weekDate);
        report.setWeeklySummary(summary);
        
        // 2. 质量趋势分析
        WeeklyTrendAnalysis trendAnalysis = analyzeWeeklyTrend(weekDate);
        report.setTrendAnalysis(trendAnalysis);
        
        // 3. 不良品分析
        WeeklyDefectAnalysis defectAnalysis = analyzeWeeklyDefects(weekDate);
        report.setDefectAnalysis(defectAnalysis);
        
        // 4. 供应商质量分析
        WeeklySupplierAnalysis supplierAnalysis = analyzeWeeklySuppliers(weekDate);
        report.setSupplierAnalysis(supplierAnalysis);
        
        // 5. 改进项目分析
        WeeklyImprovementAnalysis improvementAnalysis = analyzeWeeklyImprovements(weekDate);
        report.setImprovementAnalysis(improvementAnalysis);
        
        return report;
    }
    
    /**
     * 分析周质量总结
     */
    private WeeklyQualitySummary analyzeWeeklySummary(LocalDate weekDate) {
        WeeklyQualitySummary summary = new WeeklyQualitySummary();
        
        // 1. 时间范围
        LocalDate startDate = weekDate.minusDays(6);
        LocalDate endDate = weekDate;
        summary.setStartDate(startDate);
        summary.setEndDate(endDate);
        
        // 2. IQC统计
        WeeklyIQCStats iqcStats = calculateWeeklyIQCStats(startDate, endDate);
        summary.setIqcStats(iqcStats);
        
        // 3. FQC统计
        WeeklyFQCStats fqcStats = calculateWeeklyFQCStats(startDate, endDate);
        summary.setFqcStats(fqcStats);
        
        // 4. 投诉统计
        WeeklyComplaintStats complaintStats = calculateWeeklyComplaintStats(startDate, endDate);
        summary.setComplaintStats(complaintStats);
        
        // 5. CAPA统计
        WeeklyCAPAStats capaStats = calculateWeeklyCAPAStats(startDate, endDate);
        summary.setCapaStats(capaStats);
        
        return summary;
    }
    
    /**
     * 计算周IQC统计
     */
    private WeeklyIQCStats calculateWeeklyIQCStats(LocalDate startDate, LocalDate endDate) {
        WeeklyIQCStats stats = new WeeklyIQCStats();
        
        // 1. 查询本周数据
        List<IQCInspectionRecord> weeklyRecords = iqcInspectionRecordRepository
            .findByInspectionDateBetween(startDate, endDate);
        
        // 2. 计算总数
        stats.setTotalBatches(weeklyRecords.size());
        
        // 3. 计算接受率
        long acceptedCount = weeklyRecords.stream()
            .filter(r -> InspectionResult.ACCEPT == r.getInspectionResult())
            .count();
        stats.setAcceptanceRate((double) acceptedCount / weeklyRecords.size() * 100);
        
        // 4. 计算不合格品率
        long nonconformingCount = weeklyRecords.stream()
            .filter(r -> InspectionResult.REJECT == r.getInspectionResult())
            .count();
        stats.setNonconformingRate((double) nonconformingCount / weeklyRecords.size() * 100);
        
        // 5. 供应商分布
        Map<String, Long> supplierDistribution = weeklyRecords.stream()
            .collect(Collectors.groupingBy(IQCInspectionRecord::getSupplierName, Collectors.counting()));
        stats.setSupplierDistribution(supplierDistribution);
        
        return stats;
    }
}
\`\`\`

### 2.2 SPC过程能力分析

\`\`\`java
/**
 * SPC过程能力分析服务
 */
@Service
@Slf4j
public class SPCProcessCapabilityServiceImpl implements SPCProcessCapabilityService {
    
    @Autowired
    private SPCControlPointRepository spcControlPointRepository;
    
    @Autowired
    private ProcessCapabilityRepository processCapabilityRepository;
    
    /**
     * 计算过程能力
     */
    @Override
    public ProcessCapabilityDTO calculateProcessCapability(Long characteristicId, LocalDate dateRange) {
        log.info("计算过程能力,特性ID: {}, 日期: {}", characteristicId, dateRange);
        
        // 1. 获取SPC数据
        List<SPCControlPoint> dataPoints = getSPCDataForAnalysis(characteristicId, dateRange);
        
        // 2. 计算过程能力指数
        ProcessCapabilityIndices indices = calculateProcessCapabilityIndices(dataPoints);
        
        // 3. 计算过程性能指数
        ProcessPerformanceIndices performanceIndices = calculateProcessPerformanceIndices(dataPoints);
        
        // 4. 创建过程能力记录
        ProcessCapability capability = createProcessCapabilityRecord(
            characteristicId, indices, performanceIndices
        );
        
        // 5. 分析过程能力等级
        ProcessCapabilityLevel level = determineProcessCapabilityLevel(indices);
        
        // 6. 生成分析报告
        ProcessCapabilityReportDTO report = generateCapabilityReport(
            capability, indices, performanceIndices, level
        );
        
        return report;
    }
    
    /**
     * 计算过程能力指数
     */
    private ProcessCapabilityIndices calculateProcessCapabilityIndices(List<SPCControlPoint> dataPoints) {
        ProcessCapabilityIndices indices = new ProcessCapabilityIndices();
        
        if (dataPoints.isEmpty()) {
            return indices;
        }
        
        // 1. 计算样本均值
        double processMean = calculateProcessMean(dataPoints);
        indices.setProcessMean(processMean);
        
        // 2. 计算样本标准差
        double processStdDev = calculateProcessStandardDeviation(dataPoints);
        indices.setProcessStdDev(processStdDev);
        
        // 3. 获取规格限
        double upperSpecLimit = getUpperSpecificationLimit(dataPoints.get(0));
        double lowerSpecLimit = getLowerSpecificationLimit(dataPoints.get(0));
        
        // 4. 计算Cp
        double cp = calculateCp(upperSpecLimit, lowerSpecLimit, processStdDev);
        indices.setCp(cp);
        
        // 5. 计算Cpk
        double cpk = calculateCpk(upperSpecLimit, lowerSpecLimit, processMean, processStdDev);
        indices.setCpk(cpk);
        
        // 6. 计算Pp
        double pp = calculatePp(upperSpecLimit, lowerSpecLimit, processStdDev);
        indices.setPp(pp);
        
        // 7. 计算Ppk
        double ppk = calculatePpk(upperSpecLimit, lowerSpecLimit, processMean, processStdDev);
        indices.setPpk(ppk);
        
        // 8. 计算过程绩效
        double ppm = calculatePPM(upperSpecLimit, lowerSpecLimit, processMean, processStdDev);
        indices.setPpm(ppm);
        
        return indices;
    }
    
    /**
     * 计算过程均值
     */
    private double calculateProcessMean(List<SPCControlPoint> dataPoints) {
        return dataPoints.stream()
            .mapToDouble(SPCControlPoint::getMeasurementValue)
            .average()
            .orElse(0.0);
    }
    
    /**
     * 计算过程标准差
     */
    private double calculateProcessStandardDeviation(List<SPCControlPoint> dataPoints) {
        double[] values = dataPoints.stream()
            .mapToDouble(SPCControlPoint::getMeasurementValue)
            .toArray();
        
        return calculateSampleStandardDeviation(values);
    }
    
    /**
     * 计算Cp
     */
    private double calculateCp(double usl, double lsl, double sigma) {
        if (sigma == 0) {
            return 0;
        }
        
        double tolerance = usl - lsl;
        return tolerance / (6 * sigma);
    }
    
    /**
     * 计算Cpk
     */
    private double calculateCpk(double usl, double lsl, double mean, double sigma) {
        if (sigma == 0) {
            return 0;
        }
        
        double cpkUpper = (usl - mean) / (3 * sigma);
        double cpkLower = (mean - lsl) / (3 * sigma);
        
        return Math.min(cpkUpper, cpkLower);
    }
    
    /**
     * 确定过程能力等级
     */
    private ProcessCapabilityLevel determineProcessCapabilityLevel(ProcessCapabilityIndices indices) {
        double cpk = indices.getCpk();
        
        if (cpk >= 2.0) {
            return ProcessCapabilityLevel.EXCELLENT;
        } else if (cpk >= 1.67) {
            return ProcessCapabilityLevel.GOOD;
        } else if (cpk >= 1.33) {
            return ProcessCapabilityLevel.ADEQUATE;
        } else if (cpk >= 1.0) {
            return ProcessCapabilityLevel.MARGINAL;
        } else {
            return ProcessCapabilityLevel.INADEQUATE;
        }
    }
    
    /**
     * 生成过程能力报告
     */
    private ProcessCapabilityReportDTO generateCapabilityReport(
        ProcessCapability capability,
        ProcessCapabilityIndices indices,
        ProcessPerformanceIndices performanceIndices,
        ProcessCapabilityLevel level
    ) {
        ProcessCapabilityReportDTO report = new ProcessCapabilityReportDTO();
        
        // 1. 基本信息
        report.setCapabilityId(capability.getCapabilityId());
        report.setCharacteristicId(capability.getCharacteristicId());
        report.setProcessDate(capability.getProcessDate());
        report.setAnalysisDate(LocalDateTime.now());
        
        // 2. 过程能力指标
        report.setCapabilityIndices(indices);
        
        // 3. 过程性能指标
        report.setPerformanceIndices(performanceIndices);
        
        // 4. 能力等级
        report.setCapabilityLevel(level);
        report.setLevelDescription(getCapabilityLevelDescription(level));
        
        // 5. 性能评估
        PerformanceEvaluation evaluation = evaluatePerformance(indices, level);
        report.setPerformanceEvaluation(evaluation);
        
        // 6. 改进建议
        List<ImprovementSuggestionDTO> suggestions = generateCapabilityImprovementSuggestions(
            indices, level
        );
        report.setImprovementSuggestions(suggestions);
        
        // 7. 趋势分析
        CapabilityTrendDTO trend = analyzeCapabilityTrend(capability.getCharacteristicId());
        report.setCapabilityTrend(trend);
        
        return report;
    }
    
    /**
     * 过程能力趋势分析
     */
    private CapabilityTrendDTO analyzeCapabilityTrend(Long characteristicId) {
        CapabilityTrendDTO trend = new CapabilityTrendDTO();
        
        // 1. 获取历史过程能力数据
        List<ProcessCapability> historyCapabilities = processCapabilityRepository
            .findByCharacteristicIdOrderByProcessDateDesc(characteristicId, 12);
        
        // 2. 转换为趋势数据
        List<CapabilityTrendData> trendData = historyCapabilities.stream()
            .map(this::convertToTrendData)
            .sorted(Comparator.comparing(CapabilityTrendData::getDate))
            .collect(Collectors.toList());
        
        trend.setTrendData(trendData);
        
        // 3. 计算趋势指标
        if (trendData.size() >= 3) {
            TrendDirection cpkTrend = calculateTrendDirection(
                trendData.stream()
                    .map(CapabilityTrendData::getCpk)
                    .mapToDouble(Double::doubleValue)
                    .toArray()
            );
            trend.setCpkTrend(cpkTrend);
            
            TrendDirection cpTrend = calculateTrendDirection(
                trendData.stream()
                    .map(CapabilityTrendData::getCp)
                    .mapToDouble(Double::doubleValue)
                    .toArray()
            );
            trend.setCpTrend(cpTrend);
        }
        
        return trend;
    }
    
    /**
     * 过程性能评估
     */
    private PerformanceEvaluation evaluatePerformance(ProcessCapabilityIndices indices, 
                                                    ProcessCapabilityLevel level) {
        PerformanceEvaluation evaluation = new PerformanceEvaluation();
        
        // 1. 评分
        int score = calculatePerformanceScore(indices, level);
        evaluation.setScore(score);
        evaluation.setScoreDescription(getScoreDescription(score));
        
        // 2. 强项分析
        List<PerformanceStrength> strengths = identifyStrengths(indices);
        evaluation.setStrengths(strengths);
        
        // 3. 弱项分析
        List<PerformanceWeakness> weaknesses = identifyWeaknesses(indices);
        evaluation.setWeaknesses(weaknesses);
        
        // 4. 总体评价
        String overallEvaluation = generateOverallEvaluation(indices, level);
        evaluation.setOverallEvaluation(overallEvaluation);
        
        return evaluation;
    }
    
    /**
     * 生成改进建议
     */
    private List<ImprovementSuggestionDTO> generateCapabilityImprovementSuggestions(
        ProcessCapabilityIndices indices, 
        ProcessCapabilityLevel level
    ) {
        List<ImprovementSuggestionDTO> suggestions = new ArrayList<>();
        
        // 1. 基于Cpk的建议
        if (indices.getCpk() < 1.33) {
            suggestions.add(createImprovementSuggestion(
                "提高过程能力",
                "当前Cpk为" + String.format("%.2f", indices.getCpk()) + 
                ",建议通过优化工艺参数来提高过程能力",
                "工艺优化"
            ));
        }
        
        // 2. 基于Cp的建议
        if (indices.getCp() < 1.67) {
            suggestions.add(createImprovementSuggestion(
                "减少过程变异",
                "当前Cp为" + String.format("%.2f", indices.getCp()) + 
                ",建议减少过程变异提高能力",
                "变异减少"
            ));
        }
        
        // 3. 基于PPM的建议
        if (indices.getPpm() > 1000) {
            suggestions.add(createImprovementSuggestion(
                "降低不良品率",
                "当前不良品率为" + String.format("%.2f", indices.getPpm()) + " ppm",
                "质量改进"
            ));
        }
        
        return suggestions;
    }
}
\`\`\`

---

## 3. 质量成本分析详细实现

### 3.1 质量成本核算体系

\`\`\`java
/**
 * 质量成本服务
 */
@Service
@Slf4j
public class QualityCostServiceImpl implements QualityCostService {
    
    @Autowired
    private QualityCostRepository qualityCostRepository;
    
    @Autowired
    private DefectRepository defectRepository;
    
    @Autowired
    private CAPARepository capaRepository;
    
    @Autowired
    private TrainingRepository trainingRepository;
    
    /**
     * 质量成本分类
     */
    public enum QualityCostCategory {
        PREVENTION_COSTS,    // 预防成本
        APPRAISAL_COSTS,     // 鉴定成本
        FAILURE_COSTS,       // 失败成本
        EXTERNAL_FAILURE_COSTS  // 外部失败成本
    }
    
    /**
     * 计算月度质量成本
     */
    @Override
    public QualityCostReportDTO calculateMonthlyQualityCosts(LocalDate month) {
        log.info("计算月度质量成本,月份: {}", month);
        
        QualityCostReportDTO report = new QualityCostReportDTO();
        report.setReportDate(month);
        report.setReportType("MONTHLY");
        
        // 1. 计算预防成本
        QualityCostCategoryDTO preventionCosts = calculatePreventionCosts(month);
        report.setPreventionCosts(preventionCosts);
        
        // 2. 计算鉴定成本
        QualityCostCategoryDTO appraisalCosts = calculateAppraisalCosts(month);
        report.setAppraisalCosts(appraisalCosts);
        
        // 3. 计算失败成本
        QualityCostCategoryDTO failureCosts = calculateFailureCosts(month);
        report.setFailureCosts(failureCosts);
        
        // 4. 计算外部失败成本
        QualityCostCategoryDTO externalFailureCosts = calculateExternalFailureCosts(month);
        report.setExternalFailureCosts(externalFailureCosts);
        
        // 5. 总计
        QualityCostSummaryDTO summary = calculateTotalCosts(report);
        report.setSummary(summary);
        
        // 6. 质量成本分析
        QualityCostAnalysisDTO analysis = analyzeQualityCosts(report);
        report.setAnalysis(analysis);
        
        // 7. 成本趋势
        QualityCostTrendDTO trend = analyzeCostTrend(month);
        report.setCostTrend(trend);
        
        return report;
    }
    
    /**
     * 计算预防成本
     */
    private QualityCostCategoryDTO calculatePreventionCosts(LocalDate month) {
        QualityCostCategoryDTO costs = new QualityCostCategoryDTO();
        costs.setCategory(QualityCostCategory.PREVENTION_COSTS);
        costs.setCategoryName("预防成本");
        
        List<QualityCostItemDTO> costItems = new ArrayList<>();
        
        // 1. 质量规划成本
        double planningCost = calculateQualityPlanningCost(month);
        costItems.add(createCostItem(
            "质量规划", planningCost, "质量体系设计和维护费用"
        ));
        
        // 2. 质量培训成本
        double trainingCost = calculateQualityTrainingCost(month);
        costItems.add(createCostItem(
            "质量培训", trainingCost, "员工质量意识和技能培训费用"
        ));
        
        // 3. 过程控制成本
        double processControlCost = calculateProcessControlCost(month);
        costItems.add(createCostItem(
            "过程控制", processControlCost, "SPC控制图和统计过程控制费用"
        ));
        
        // 4. 供应商质量保证成本
        double supplierCost = calculateSupplierQualityCost(month);
        costItems.add(createCostItem(
            "供应商质量保证", supplierCost, "供应商审核和质量保证费用"
        ));
        
        costs.setCostItems(costItems);
        costs.setTotalCost(costItems.stream()
            .mapToDouble(QualityCostItemDTO::getCost)
            .sum());
        
        return costs;
    }
    
    /**
     * 计算质量培训成本
     */
    private double calculateQualityTrainingCost(LocalDate month) {
        // 1. 培训讲师费用
        double trainerCost = trainingRepository
            .calculateTrainerCost(month);
        
        // 2. 培训材料费用
        double materialCost = trainingRepository
            .calculateTrainingMaterialCost(month);
        
        // 3. 设施和设备费用
        double facilityCost = trainingRepository
            .calculateFacilityCost(month);
        
        // 4. 参训人员时间成本
        double timeCost = trainingRepository
            .calculateTrainingTimeCost(month);
        
        return trainerCost + materialCost + facilityCost + timeCost;
    }
    
    /**
     * 计算失败成本
     */
    private QualityCostCategoryDTO calculateFailureCosts(LocalDate month) {
        QualityCostCategoryDTO costs = new QualityCostCategoryDTO();
        costs.setCategory(QualityCostCategory.FAILURE_COSTS);
        costs.setCategoryName("失败成本");
        
        List<QualityCostItemDTO> costItems = new ArrayList<>();
        
        // 1. 内部失败成本
        double internalFailureCost = calculateInternalFailureCost(month);
        costItems.add(createCostItem(
            "内部失败成本", internalFailureCost, "内部发现的质量问题处理费用"
        ));
        
        // 2. 外部失败成本
        double externalFailureCost = calculateExternalFailureCost(month);
        costItems.add(createCostItem(
            "外部失败成本", externalFailureCost, "外部发现的质量问题处理费用"
        ));
        
        costs.setCostItems(costItems);
        costs.setTotalCost(costItems.stream()
            .mapToDouble(QualityCostItemDTO::getCost)
            .sum());
        
        return costs;
    }
    
    /**
     * 计算内部失败成本
     */
    private double calculateInternalFailureCost(LocalDate month) {
        double totalCost = 0;
        
        // 1. 废品成本
        double scrapCost = defectRepository
            .calculateScrapCost(month);
        totalCost += scrapCost;
        
        // 2. 返工成本
        double reworkCost = defectRepository
            .calculateReworkCost(month);
        totalCost += reworkCost;
        
        // 3. 降级处理成本
        double downgradeCost = defectRepository
            .calculateDowngradeCost(month);
        totalCost += downgradeCost;
        
        // 4. CAPA实施成本
        double capaCost = capaRepository
            .calculateCAPACost(month);
        totalCost += capaCost;
        
        return totalCost;
    }
    
    /**
     * 计算不良品成本
     */
    private double calculateDefectCost(LocalDate month, Defect defect) {
        double totalCost = 0;
        
        // 1. 材料成本
        double materialCost = defect.getQuantity() * getMaterialCostPerUnit(defect);
        
        // 2. 加工成本
        double processingCost = defect.getQuantity() * getProcessingCostPerUnit(defect);
        
        // 3. 设备使用成本
        double equipmentCost = defect.getQuantity() * getEquipmentCostPerUnit(defect);
        
        // 4. 人工成本
        double laborCost = defect.getQuantity() * getLaborCostPerUnit(defect);
        
        // 5. 管理成本分摊
        double overheadCost = (materialCost + processingCost + equipmentCost + laborCost) * 
                              getOverheadRate(defect);
        
        totalCost = materialCost + processingCost + equipmentCost + laborCost + overheadCost;
        
        // 6. 返工/修复成本
        if (defect.isReworkable()) {
            totalCost += calculateReworkCost(defect);
        }
        
        return totalCost;
    }
    
    /**
     * 质量成本分析
     */
    private QualityCostAnalysisDTO analyzeQualityCosts(QualityCostReportDTO report) {
        QualityCostAnalysisDTO analysis = new QualityCostAnalysisDTO();
        
        // 1. 计算各成本类别占比
        Map<QualityCostCategory, Double> costRatios = calculateCostRatios(report);
        analysis.setCostRatios(costRatios);
        
        // 2. 计算质量成本率
        double qualityCostRate = calculateQualityCostRate(report);
        analysis.setQualityCostRate(qualityCostRate);
        
        // 3. 计算预防成本占比
        double preventionRatio = calculatePreventionRatio(report);
        analysis.setPreventionRatio(preventionRatio);
        
        // 4. 计算鉴定成本占比
        double appraisalRatio = calculateAppraisalRatio(report);
        analysis.setAppraisalRatio(appraisalRatio);
        
        // 5. 计算失败成本占比
        double failureRatio = calculateFailureRatio(report);
        analysis.setFailureRatio(failureRatio);
        
        // 6. 质量成本优化建议
        List<CostOptimizationDTO> optimizationSuggestions = 
            generateCostOptimizationSuggestions(analysis);
        analysis.setOptimizationSuggestions(optimizationSuggestions);
        
        return analysis;
    }
    
    /**
     * 计算质量成本率
     */
    private double calculateQualityCostRate(QualityCostReportDTO report) {
        // 获取月度总收入
        double totalRevenue = getMonthlyRevenue(report.getReportDate());
        
        if (totalRevenue == 0) {
            return 0;
        }
        
        double totalCost = report.getSummary().getTotalCost();
        return totalCost / totalRevenue * 100;
    }
    
    /**
     * 生成成本优化建议
     */
    private List<CostOptimizationDTO> generateCostOptimizationSuggestions(
        QualityCostAnalysisDTO analysis
    ) {
        List<CostOptimizationDTO> suggestions = new ArrayList<>();
        
        // 1. 失败成本过高建议
        if (analysis.getFailureRatio() > 30) {
            suggestions.add(createCostOptimization(
                "减少失败成本",
                "失败成本占比过高(" + String.format("%.1f", analysis.getFailureRatio()) + 
                "%),建议加强过程控制和预防措施",
                "PROCESS_IMPROVEMENT"
            ));
        }
        
        // 2. 预防成本过低建议
        if (analysis.getPreventionRatio() < 5) {
            suggestions.add(createCostOptimization(
                "增加预防投入",
                "预防成本占比过低(" + String.format("%.1f", analysis.getPreventionRatio()) + 
                "%),建议增加质量培训和技术改进投入",
                "PREVENTION_INVESTMENT"
            ));
        }
        
        // 3. 鉴定成本优化建议
        if (analysis.getAppraisalRatio() > 25) {
            suggestions.add(createCostOptimization(
                "优化鉴定成本",
                "鉴定成本占比较高(" + String.format("%.1f", analysis.getAppraisalRatio()) + 
                "%),建议自动化检测和抽样优化",
                "APPRAISAL_OPTIMIZATION"
            ));
        }
        
        return suggestions;
    }
    
    /**
     * 质量成本趋势分析
     */
    private QualityCostTrendDTO analyzeCostTrend(LocalDate endDate) {
        QualityCostTrendDTO trend = new QualityCostTrendDTO();
        trend.setCurrentMonth(endDate);
        
        // 1. 计算12个月趋势数据
        List<MonthlyCostTrend> monthlyData = new ArrayList<>();
        for (int i = 11; i >= 0; i--) {
            LocalDate month = endDate.minusMonths(i);
            MonthlyCostTrend monthlyCost = calculateMonthlyCostTrend(month);
            monthlyData.add(monthlyCost);
        }
        trend.setMonthlyTrend(monthlyData);
        
        // 2. 计算趋势指标
        CostTrendMetrics metrics = calculateTrendMetrics(monthlyData);
        trend.setTrendMetrics(metrics);
        
        // 3. 成本预警
        List<CostAlertDTO> alerts = generateCostAlerts(monthlyData);
        trend.setCostAlerts(alerts);
        
        return trend;
    }
    
    /**
     * 计算月度成本趋势
     */
    private MonthlyCostTrend calculateMonthlyCostTrend(LocalDate month) {
        MonthlyCostTrend trend = new MonthlyCostTrend();
        trend.setMonth(month);
        
        // 1. 计算各类成本
        QualityCostReportDTO report = calculateMonthlyQualityCosts(month);
        
        trend.setTotalCost(report.getSummary().getTotalCost());
        trend.setPreventionCost(report.getPreventionCosts().getTotalCost());
        trend.setAppraisalCost(report.getAppraisalCosts().getTotalCost());
        trend.setFailureCost(report.getFailureCosts().getTotalCost());
        trend.setExternalFailureCost(report.getExternalFailureCosts().getTotalCost());
        
        // 2. 计算质量成本率
        double revenue = getMonthlyRevenue(month);
        trend.setCostRate(revenue > 0 ? trend.getTotalCost() / revenue * 100 : 0);
        
        return trend;
    }
    
    /**
     * 计算成本趋势指标
     */
    private CostTrendMetrics calculateTrendMetrics(List<MonthlyCostTrend> monthlyData) {
        CostTrendMetrics metrics = new CostTrendMetrics();
        
        if (monthlyData.size() < 3) {
            return metrics;
        }
        
        // 1. 成本总额趋势
        double[] totalCosts = monthlyData.stream()
            .mapToDouble(MonthlyCostTrend::getTotalCost)
            .toArray();
        
        metrics.setTotalCostTrend(calculateTrendDirection(totalCosts));
        metrics.setTotalCostSlope(calculateTrendSlope(totalCosts));
        
        // 2. 失败成本趋势
        double[] failureCosts = monthlyData.stream()
            .mapToDouble(MonthlyCostTrend::getFailureCost)
            .toArray();
        
        metrics.setFailureCostTrend(calculateTrendDirection(failureCosts));
        metrics.setFailureCostSlope(calculateTrendSlope(failureCosts));
        
        // 3. 成本率趋势
        double[] costRates = monthlyData.stream()
            .mapToDouble(MonthlyCostTrend::getCostRate)
            .toArray();
        
        metrics.setCostRateTrend(calculateTrendDirection(costRates));
        metrics.setCostRateSlope(calculateTrendSlope(costRates));
        
        return metrics;
    }
    
    /**
     * 生成成本预警
     */
    private List<CostAlertDTO> generateCostAlerts(List<MonthlyCostTrend> monthlyData) {
        List<CostAlertDTO> alerts = new ArrayList<>();
        
        // 1. 成本增长预警
        if (monthlyData.size() >= 3) {
            double recentGrowth = calculateRecentCostGrowth(monthlyData);
            if (recentGrowth > 10) {
                CostAlertDTO alert = createCostAlert(
                    "成本快速增长",
                    "最近3个月成本增长" + String.format("%.1f", recentGrowth) + "%",
                    AlertLevel.WARNING
                );
                alerts.add(alert);
            }
        }
        
        // 2. 失败成本预警
        double failureRatio = calculateCurrentFailureRatio(monthlyData);
        if (failureRatio > 40) {
            CostAlertDTO alert = createCostAlert(
                "失败成本过高",
                "失败成本占比" + String.format("%.1f", failureRatio) + "%",
                AlertLevel.CRITICAL
            );
            alerts.add(alert);
        }
        
        return alerts;
    }
}
\`\`\`

---

## 4. 决策支持模块详细实现

### 4.1 智能决策支持系统

\`\`\`java
/**
 * 智能决策支持服务
 */
@Service
@Slf4j
public class IntelligentDecisionSupportServiceImpl implements IntelligentDecisionSupportService {
    
    @Autowired
    private MachineLearningService mlService;
    
    @Autowired
    private AnalysisService analysisService;
    
    @Autowired
    private RiskAssessmentService riskAssessmentService;
    
    /**
     * 质量决策建议生成
     */
    @Override
    public QualityDecisionAdviceDTO generateQualityDecisionAdvice(QualityDecisionInputDTO input) {
        log.info("生成质量决策建议,输入: {}", input.getInputContext());
        
        QualityDecisionAdviceDTO advice = new QualityDecisionAdviceDTO();
        
        // 1. 情境分析
        DecisionContext context = analyzeDecisionContext(input);
        advice.setDecisionContext(context);
        
        // 2. 问题识别
        DecisionIssue issue = identifyDecisionIssue(input, context);
        advice.setDecisionIssue(issue);
        
        // 3. 方案生成
        List<DecisionOption> options = generateDecisionOptions(issue);
        advice.setDecisionOptions(options);
        
        // 4. 方案评估
        DecisionEvaluation evaluation = evaluateDecisionOptions(options);
        advice.setEvaluation(evaluation);
        
        // 5. 推荐方案
        DecisionRecommendation recommendation = generateRecommendation(evaluation);
        advice.setRecommendation(recommendation);
        
        // 6. 风险评估
        DecisionRiskAssessment riskAssessment = assessDecisionRisks(recommendation);
        advice.setRiskAssessment(riskAssessment);
        
        // 7. 实施计划
        DecisionImplementationPlan implementationPlan = createImplementationPlan(recommendation);
        advice.setImplementationPlan(implementationPlan);
        
        // 8. 监控指标
        List<DecisionMonitorMetric> monitorMetrics = generateMonitorMetrics(recommendation);
        advice.setMonitorMetrics(monitorMetrics);
        
        return advice;
    }
    
    /**
     * 分析决策情境
     */
    private DecisionContext analyzeDecisionContext(QualityDecisionInputDTO input) {
        DecisionContext context = new DecisionContext();
        
        // 1. 当前质量状况
        QualityStatusDTO qualityStatus = analyzeCurrentQualityStatus();
        context.setQualityStatus(qualityStatus);
        
        // 2. 历史趋势分析
        QualityTrendDTO historicalTrend = analyzeHistoricalTrend();
        context.setHistoricalTrend(historicalTrend);
        
        // 3. 环境因素
        EnvironmentalFactorsDTO environmentalFactors = analyzeEnvironmentalFactors(input);
        context.setEnvironmentalFactors(environmentalFactors);
        
        // 4. 约束条件
        DecisionConstraints constraints = identifyConstraints(input);
        context.setConstraints(constraints);
        
        // 5. 利益相关方
        List<Stakeholder> stakeholders = identifyStakeholders(input);
        context.setStakeholders(stakeholders);
        
        return context;
    }
    
    /**
     * 识别决策问题
     */
    private DecisionIssue identifyDecisionIssue(QualityDecisionInputDTO input, DecisionContext context) {
        DecisionIssue issue = new DecisionIssue();
        
        // 1. 问题类型识别
        DecisionIssueType issueType = determineIssueType(input);
        issue.setIssueType(issueType);
        
        // 2. 问题严重程度
        DecisionPriority priority = determineIssuePriority(issueType, context);
        issue.setPriority(priority);
        
        // 3. 问题根因分析
        DecisionRootCause rootCause = analyzeRootCause(input, context);
        issue.setRootCause(rootCause);
        
        // 4. 影响范围评估
        DecisionImpact impact = assessImpact(issueType, context);
        issue.setImpact(impact);
        
        // 5. 紧急程度
        UrgencyLevel urgency = determineUrgency(issueType, priority, context);
        issue.setUrgency(urgency);
        
        return issue;
    }
    
    /**
     * 生成决策选项
     */
    private List<DecisionOption> generateDecisionOptions(DecisionIssue issue) {
        List<DecisionOption> options = new ArrayList<>();
        
        // 1. 基于问题类型生成方案
        switch (issue.getIssueType()) {
            case QUALITY_DEGRADATION:
                options.addAll(generateQualityDegradationOptions(issue));
                break;
            case PROCESS_INSTABILITY:
                options.addAll(generateProcessInstabilityOptions(issue));
                break;
            case SUPPLIER_ISSUES:
                options.addAll(generateSupplierIssueOptions(issue));
                break;
            case CUSTOMER_COMPLAINTS:
                options.addAll(generateCustomerComplaintOptions(issue));
                break;
            case REGULATORY_COMPLIANCE:
                options.addAll(generateComplianceOptions(issue));
                break;
        }
        
        // 2. 基于机器学习推荐
        List<DecisionOption> mlRecommendations = 
            generateMLRecommendations(issue);
        options.addAll(mlRecommendations);
        
        // 3. 历史经验建议
        List<DecisionOption> historicalOptions = 
            generateHistoricalOptions(issue);
        options.addAll(historicalOptions);
        
        // 4. 去重和排序
        options = deduplicateAndRankOptions(options);
        
        return options;
    }
    
    /**
     * 质量退化决策选项
     */
    private List<DecisionOption> generateQualityDegradationOptions(DecisionIssue issue) {
        List<DecisionOption> options = new ArrayList<>();
        
        // 1. 工艺参数优化
        DecisionOption processOptimization = new DecisionOption();
        processOptimization.setOptionId("PROCESS_OPTIMIZATION");
        processOptimization.setOptionName("工艺参数优化");
        processOptimization.setOptionDescription("优化压铸工艺参数以提高产品质量");
        processOptimization.setEstimatedCost(calculateOptimizationCost());
        processOptimization.setImplementationTime("2-4周");
        processOptimization.setEffectivenessScore(85);
        processOptimization.setRiskLevel(RiskLevel.LOW);
        processOptimization.setResourcesRequired("工艺工程师,设备调试");
        options.add(processOptimization);
        
        // 2. 设备升级
        DecisionOption equipmentUpgrade = new DecisionOption();
        equipmentUpgrade.setOptionId("EQUIPMENT_UPGRADE");
        equipmentUpgrade.setOptionName("设备升级");
        equipmentUpgrade.setOptionDescription("升级老化设备以提高产品质量稳定性");
        equipmentUpgrade.setEstimatedCost(calculateUpgradeCost());
        equipmentUpgrade.setImplementationTime("3-6个月");
        equipmentUpgrade.setEffectivenessScore(95);
        equipmentUpgrade.setRiskLevel(RiskLevel.HIGH);
        equipmentUpgrade.setResourcesRequired("投资预算,设备供应商");
        options.add(equipmentUpgrade);
        
        // 3. 员工培训
        DecisionOption staffTraining = new DecisionOption();
        staffTraining.setOptionId("STAFF_TRAINING");
        staffTraining.setOptionName("员工技能培训");
        staffTraining.setOptionDescription("加强员工质量意识和操作技能培训");
        staffTraining.setEstimatedCost(calculateTrainingCost());
        staffTraining.setImplementationTime("1-2周");
        staffTraining.setEffectivenessScore(70);
        staffTraining.setRiskLevel(RiskLevel.LOW);
        staffTraining.setResourcesRequired("培训讲师,培训材料");
        options.add(staffTraining);
        
        return options;
    }
    
    /**
     * 评估决策选项
     */
    private DecisionEvaluation evaluateDecisionOptions(List<DecisionOption> options) {
        DecisionEvaluation evaluation = new DecisionEvaluation();
        
        // 1. 多维度评估
        List<OptionEvaluation> evaluations = new ArrayList<>();
        for (DecisionOption option : options) {
            OptionEvaluation optionEval = new OptionEvaluation();
            optionEval.setOptionId(option.getOptionId());
            optionEval.setOptionName(option.getOptionName());
            
            // 1.1 成本效益分析
            double costBenefitRatio = calculateCostBenefitRatio(option);
            optionEval.setCostBenefitRatio(costBenefitRatio);
            
            // 1.2 实施难度评估
            double implementationDifficulty = calculateImplementationDifficulty(option);
            optionEval.setImplementationDifficulty(implementationDifficulty);
            
            // 1.3 风险评估
            double riskScore = calculateRiskScore(option);
            optionEval.setRiskScore(riskScore);
            
            // 1.4 时间价值评估
            double timeValue = calculateTimeValue(option);
            optionEval.setTimeValue(timeValue);
            
            // 1.5 综合评分
            double overallScore = calculateOverallScore(optionEval);
            optionEval.setOverallScore(overallScore);
            
            evaluations.add(optionEval);
        }
        evaluation.setOptionEvaluations(evaluations);
        
        // 2. 最佳选项推荐
        EvaluationResult result = determineBestOption(evaluations);
        evaluation.setRecommendedOption(result);
        
        return evaluation;
    }
    
    /**
     * 生成推荐方案
     */
    private DecisionRecommendation generateRecommendation(DecisionEvaluation evaluation) {
        DecisionRecommendation recommendation = new DecisionRecommendation();
        
        // 1. 推荐方案
        OptionEvaluation bestOption = evaluation.getRecommendedOption();
        recommendation.setRecommendedOption(bestOption);
        
        // 2. 推荐理由
        String recommendationReason = generateRecommendationReason(bestOption);
        recommendation.setRecommendationReason(recommendationReason);
        
        // 3. 备选方案
        List<OptionEvaluation> alternatives = generateAlternatives(bestOption, evaluation);
        recommendation.setAlternativeOptions(alternatives);
        
        // 4. 实施优先级
        ImplementationPriority priority = determineImplementationPriority(bestOption);
        recommendation.setImplementationPriority(priority);
        
        // 5. 关键成功因素
        List<String> successFactors = identifySuccessFactors(bestOption);
        recommendation.setSuccessFactors(successFactors);
        
        return recommendation;
    }
    
    /**
     * 风险评估
     */
    private DecisionRiskAssessment assessDecisionRisks(DecisionRecommendation recommendation) {
        DecisionRiskAssessment assessment = new DecisionRiskAssessment();
        
        // 1. 识别风险
        List<DecisionRisk> risks = identifyDecisionRisks(recommendation);
        assessment.setRisks(risks);
        
        // 2. 风险评估
        List<RiskAssessmentDetail> assessments = assessRiskLevels(risks);
        assessment.setRiskAssessments(assessments);
        
        // 3. 缓解措施
        List<RiskMitigation> mitigations = generateRiskMitigations(risks);
        assessment.setRiskMitigations(mitigations);
        
        // 4. 风险监控计划
        RiskMonitoringPlan monitoringPlan = createRiskMonitoringPlan(risks);
        assessment.setMonitoringPlan(monitoringPlan);
        
        return assessment;
    }
    
    /**
     * 创建实施计划
     */
    private DecisionImplementationPlan createImplementationPlan(DecisionRecommendation recommendation) {
        DecisionImplementationPlan plan = new DecisionImplementationPlan();
        
        // 1. 阶段划分
        List<ImplementationPhase> phases = divideIntoPhases(recommendation);
        plan.setPhases(phases);
        
        // 2. 任务分解
        List<ImplementationTask> tasks = createTasks(phases);
        plan.setTasks(tasks);
        
        // 3. 资源分配
        ResourceAllocation allocation = allocateResources(tasks);
        plan.setResourceAllocation(allocation);
        
        // 4. 时间计划
        Timeline timeline = createTimeline(tasks);
        plan.setTimeline(timeline);
        
        // 5. 责任分配
        ResponsibilityMatrix responsibility = createResponsibilityMatrix(tasks);
        plan.setResponsibilityMatrix(responsibility);
        
        return plan;
    }
    
    /**
     * 决策执行跟踪
     */
    @Override
    public DecisionExecutionDTO trackDecisionExecution(Long decisionId) {
        log.info("跟踪决策执行,决策ID: {}", decisionId);
        
        DecisionExecutionDTO execution = new DecisionExecutionDTO();
        
        // 1. 决策基本信息
        DecisionBasicInfo basicInfo = getDecisionBasicInfo(decisionId);
        execution.setBasicInfo(basicInfo);
        
        // 2. 执行进度
        ExecutionProgress progress = calculateExecutionProgress(decisionId);
        execution.setProgress(progress);
        
        // 3. 任务状态
        List<TaskStatus> taskStatuses = getTaskStatuses(decisionId);
        execution.setTaskStatuses(taskStatuses);
        
        // 4. 偏差分析
        List<ExecutionDeviation> deviations = analyzeDeviations(decisionId);
        execution.setDeviations(deviations);
        
        // 5. 成果评估
        ExecutionAssessment assessment = assessExecutionResults(decisionId);
        execution.setAssessment(assessment);
        
        return execution;
    }
    
    /**
     * 决策效果评估
     */
    @Override
    public DecisionEffectivenessDTO evaluateDecisionEffectiveness(Long decisionId) {
        log.info("评估决策效果,决策ID: {}", decisionId);
        
        DecisionEffectivenessDTO effectiveness = new DecisionEffectivenessDTO();
        
        // 1. 目标达成度
        GoalAchievement achievement = evaluateGoalAchievement(decisionId);
        effectiveness.setGoalAchievement(achievement);
        
        // 2. 成本效益分析
        CostBenefitAnalysis costBenefit = analyzeCostBenefit(decisionId);
        effectiveness.setCostBenefitAnalysis(costBenefit);
        
        // 3. 质量影响评估
        QualityImpact impact = assessQualityImpact(decisionId);
        effectiveness.setQualityImpact(impact);
        
        // 4. 长期效果预测
        LongTermEffectiveness longTerm = predictLongTermEffectiveness(decisionId);
        effectiveness.setLongTermEffectiveness(longTerm);
        
        // 5. 经验总结
        DecisionExperience experience = summarizeDecisionExperience(decisionId);
        effectiveness.setDecisionExperience(experience);
        
        return effectiveness;
    }
}
\`\`\`

---

## 5. 实时监控与预警系统

### 5.1 实时质量监控

\`\`\`java
/**
 * 实时质量监控服务
 */
@Service
@Slf4j
public class RealTimeQualityMonitoringServiceImpl implements RealTimeQualityMonitoringService {
    
    @Autowired
    private RealTimeQualityEventRepository eventRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AlertRuleService alertRuleService;
    
    /**
     * 实时质量事件处理
     */
    @Scheduled(fixedDelay = 1000) // 每秒执行
    public void processRealTimeQualityEvents() {
        log.debug("开始处理实时质量事件");
        
        // 1. 获取新事件
        List<RawQualityEvent> newEvents = getNewRawEvents();
        
        for (RawQualityEvent rawEvent : newEvents) {
            try {
                // 2. 处理事件
                QualityEvent processedEvent = processRawEvent(rawEvent);
                
                // 3. 验证事件
                if (validateEvent(processedEvent)) {
                    // 4. 检查预警规则
                    checkAlertRules(processedEvent);
                    
                    // 5. 保存事件
                    eventRepository.save(processedEvent);
                    
                    // 6. 更新实时看板
                    updateRealTimeDashboard(processedEvent);
                }
                
            } catch (Exception e) {
                log.error("处理实时质量事件异常,事件ID: {}", rawEvent.getEventId(), e);
                markEventAsFailed(rawEvent);
            }
        }
        
        // 7. 清理过期事件
        cleanupExpiredEvents();
        
        log.debug("实时质量事件处理完成,处理数量: {}", newEvents.size());
    }
    
    /**
     * 处理原始事件
     */
    private QualityEvent processRawEvent(RawQualityEvent rawEvent) {
        QualityEvent event = new QualityEvent();
        
        // 1. 基础信息
        event.setEventId(rawEvent.getEventId());
        event.setEventType(rawEvent.getEventType());
        event.setEventTime(rawEvent.getEventTime());
        event.setSeverity(rawEvent.getSeverity());
        
        // 2. 相关信息
        event.setProductId(rawEvent.getProductId());
        event.setBatchNumber(rawEvent.getBatchNumber());
        event.setWorkOrderId(rawEvent.getWorkOrderId());
        event.setProcessStep(rawEvent.getProcessStep());
        
        // 3. 事件详情
        event.setEventDescription(rawEvent.getEventDescription());
        event.setEventData(rawEvent.getEventData());
        
        // 4. 位置信息
        event.setProductionLine(rawEvent.getProductionLine());
        event.setWorkstation(rawEvent.getWorkstation());
        
        // 5. 责任人
        event.setOperatorId(rawEvent.getOperatorId());
        event.setSupervisorId(rawEvent.getSupervisorId());
        
        // 6. 事件状态
        event.setEventStatus(EventStatus.PROCESSED);
        event.setProcessedTime(LocalDateTime.now());
        event.setProcessor(SecurityUtils.getCurrentUserId());
        
        return event;
    }
    
    /**
     * 检查预警规则
     */
    private void checkAlertRules(QualityEvent event) {
        // 1. 获取相关的预警规则
        List<AlertRule> rules = alertRuleService.getRelevantRules(event);
        
        for (AlertRule rule : rules) {
            // 2. 检查规则条件
            if (rule.evaluate(event)) {
                // 3. 触发预警
                triggerAlert(rule, event);
            }
        }
    }
    
    /**
     * 触发预警
     */
    private void triggerAlert(AlertRule rule, QualityEvent event) {
        log.info("触发质量预警,规则ID: {}, 事件ID: {}", rule.getRuleId(), event.getEventId());
        
        // 1. 创建预警记录
        QualityAlert alert = new QualityAlert();
        alert.setAlertId(generateAlertId());
        alert.setRuleId(rule.getRuleId());
        alert.setRuleName(rule.getRuleName());
        alert.setEventId(event.getEventId());
        alert.setAlertLevel(rule.getAlertLevel());
        alert.setAlertMessage(generateAlertMessage(rule, event));
        alert.setAlertTime(LocalDateTime.now());
        alert.setStatus(AlertStatus.ACTIVE);
        
        // 2. 保存预警
        alertRepository.save(alert);
        
        // 3. 发送通知
        sendAlertNotification(alert, rule);
        
        // 4. 记录预警历史
        logAlertHistory(alert, rule, event);
    }
    
    /**
     * 实时质量看板更新
     */
    @Override
    public RealTimeQualityDashboardDTO getRealTimeDashboard() {
        RealTimeQualityDashboardDTO dashboard = new RealTimeQualityDashboardDTO();
        
        // 1. 关键指标
        List<CoreMetricDTO> coreMetrics = calculateCoreMetrics();
        dashboard.setCoreMetrics(coreMetrics);
        
        // 2. 实时事件
        List<LiveQualityEvent> liveEvents = getLiveQualityEvents();
        dashboard.setLiveEvents(liveEvents);
        
        // 3. 质量趋势
        RealTimeTrendDTO trend = calculateRealTimeTrend();
        dashboard.setTrend(trend);
        
        // 4. 异常分布
        AnomalyDistributionDTO distribution = calculateAnomalyDistribution();
        dashboard.setAnomalyDistribution(distribution);
        
        // 5. 生产线状态
        LineStatusDTO lineStatus = getLineStatus();
        dashboard.setLineStatus(lineStatus);
        
        return dashboard;
    }
    
    /**
     * 关键指标计算
     */
    private List<CoreMetricDTO> calculateCoreMetrics() {
        List<CoreMetricDTO> metrics = new ArrayList<>();
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startOfDay = now.toLocalDate().atStartOfDay();
        
        // 1. 今日合格率
        double dailyAcceptanceRate = calculateTodayAcceptanceRate();
        metrics.add(createCoreMetric("今日合格率", dailyAcceptanceRate, "%"));
        
        // 2. 不良品率
        double defectRate = calculateDefectRate();
        metrics.add(createCoreMetric("不良品率", defectRate, "%"));
        
        // 3. 客户投诉数
        long complaintCount = getTodayComplaintCount();
        metrics.add(createCoreMetric("客户投诉", complaintCount, "件"));
        
        // 4. 审核发现数
        long findingCount = getTodayFindingCount();
        metrics.add(createCoreMetric("审核发现", findingCount, "项"));
        
        // 5. CAPA完成率
        double capaCompletionRate = calculateCAPACompletionRate();
        metrics.add(createCoreMetric("CAPA完成率", capaCompletionRate, "%"));
        
        return metrics;
    }
    
    /**
     * 获取实时事件
     */
    private List<LiveQualityEvent> getLiveQualityEvents() {
        List<LiveQualityEvent> events = new ArrayList<>();
        
        // 1. 获取最近5分钟的事件
        LocalDateTime fiveMinutesAgo = LocalDateTime.now().minusMinutes(5);
        List<QualityEvent> recentEvents = eventRepository
            .findByEventTimeAfterOrderByEventTimeDesc(fiveMinutesAgo);
        
        for (QualityEvent event : recentEvents) {
            LiveQualityEvent liveEvent = new LiveQualityEvent();
            BeanUtils.copyProperties(event, liveEvent);
            events.add(liveEvent);
        }
        
        // 2. 按严重程度排序
        events.sort((e1, e2) -> {
            int severity1 = getSeverityScore(e1.getSeverity());
            int severity2 = getSeverityScore(e2.getSeverity());
            return Integer.compare(severity2, severity1);
        });
        
        return events;
    }
    
    /**
     * 实时趋势计算
     */
    private RealTimeTrendDTO calculateRealTimeTrend() {
        RealTimeTrendDTO trend = new RealTimeTrendDTO();
        
        // 1. 获取过去24小时的数据
        LocalDateTime startTime = LocalDateTime.now().minusHours(24);
        List<QualityEvent> events = eventRepository
            .findByEventTimeAfter(startTime);
        
        // 2. 按小时聚合
        Map<Integer, HourlyStats> hourlyStats = aggregateByHour(events);
        
        // 3. 计算趋势
        List<TrendPointDTO> trendPoints = calculateTrendPoints(hourlyStats);
        trend.setTrendPoints(trendPoints);
        
        // 4. 计算趋势方向
        TrendDirection direction = calculateTrendDirection(trendPoints);
        trend.setTrendDirection(direction);
        
        return trend;
    }
    
    /**
     * 异常分布计算
     */
    private AnomalyDistributionDTO calculateAnomalyDistribution() {
        AnomalyDistributionDTO distribution = new AnomalyDistributionDTO();
        
        // 1. 按生产线条目分布
        Map<String, Long> lineDistribution = getLineDistribution();
        distribution.setLineDistribution(lineDistribution);
        
        // 2. 按工序分布
        Map<String, Long> processDistribution = getProcessDistribution();
        distribution.setProcessDistribution(processDistribution);
        
        // 3. 按缺陷类型分布
        Map<String, Long> defectDistribution = getDefectDistribution();
        distribution.setDefectDistribution(defectDistribution);
        
        // 4. 按严重程度分布
        Map<String, Long> severityDistribution = getSeverityDistribution();
        distribution.setSeverityDistribution(severityDistribution);
        
        return distribution;
    }
}
\`\`\`

---

## 总结

本详细实现规范为舜富QMS系统的报表分析与决策支持模块提供了:

1. **质量分析报表**: 质量日报/周报/月报、SPC过程能力分析、不良品分析
2. **质量成本分析**: 预防成本、鉴定成本、失败成本、外部失败成本核算与分析
3. **智能决策支持**: 智能问题识别、方案生成、风险评估、实施计划
4. **实时监控预警**: 实时质量事件处理、智能预警、实时看板
5. **趋势预测分析**: 历史趋势分析、未来预测、异常检测

所有实现采用微服务架构,支持大数据处理、机器学习、实时监控,为舜富压铸行业提供全方位的决策支持解决方案。
`,ee=`# 舜富QMS系统 - 数据库设计规范

## 1. 数据库架构总览

### 1.1 多数据库架构设计

根据QMS系统的业务特点，采用多数据库组合策略：

\`\`\`
┌─────────────────────────────────────────────────────────────┐
│                     数据库架构层                              │
├─────────────────────────────────────────────────────────────┤
│  PostgreSQL (主业务数据)                                       │
│  ├─ 用户权限管理                                               │
│  ├─ 基础主数据 (客户/供应商/物料)                               │
│  ├─ 业务流程数据 (APQP/PPAP/CAPA)                             │
│  ├─ 质量记录 (检验/审核/不合格品)                              │
│  └─ 系统配置与审计                                             │
├─────────────────────────────────────────────────────────────┤
│  MongoDB (文档存储)                                            │
│  ├─ 知识库文档 (经验/案例/标准)                                │
│  ├─ 审核记录与附件                                             │
│  ├─ 8D报告详细内容                                            │
│  └─ 非结构化数据 (图片/视频/图纸)                              │
├─────────────────────────────────────────────────────────────┤
│  InfluxDB (时序数据)                                           │
│  ├─ 生产过程参数 (压力/温度/速度)                              │
│  ├─ SPC控制点数据                                             │
│  ├─ 设备实时监测数据                                           │
│  └─ MSA测量分析数据                                            │
└─────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2 数据库命名规范

#### 1.2.1 PostgreSQL表命名
- 格式: \`{模块}_{功能}_{实体}\`
- 全部小写,使用下划线分隔
- 示例: \`apqp_phase\`, \`ppap_approve_record\`, \`capa_root_cause\`

#### 1.2.2 MongoDB集合命名
- 格式: \`{模块}_{实体集合}\`
- 驼峰命名法
- 示例: \`KnowledgeBaseArticles\`, \`AuditRecords\`, \`EightDReports\`

#### 1.2.3 InfluxDB命名
- 格式: \`{模块}_{指标}\`
- 示例: \`production_process_params\`, \`spc_control_points\`, \`msa_gage_rr_results\`

#### 1.2.4 字段命名规范
- PostgreSQL: snake_case
- MongoDB: camelCase
- InfluxDB: snake_case (tag/field区分)

---

## 2. PostgreSQL 数据库设计

### 2.1 核心表结构

#### 2.1.1 用户权限模块

\`\`\`sql
-- 用户表
CREATE TABLE sys_user (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    real_name VARCHAR(100) NOT NULL,
    employee_code VARCHAR(50) UNIQUE,
    department_id BIGINT,
    position VARCHAR(100),
    mobile_phone VARCHAR(20),
    email VARCHAR(100),
    avatar_url VARCHAR(255),
    status VARCHAR(20) DEFAULT 'ACTIVE', -- ACTIVE, INACTIVE, LOCKED
    last_login_time TIMESTAMP,
    last_login_ip VARCHAR(50),
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_user_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'LOCKED'))
);

-- 部门表
CREATE TABLE sys_department (
    department_id BIGSERIAL PRIMARY KEY,
    department_code VARCHAR(50) UNIQUE NOT NULL,
    department_name VARCHAR(200) NOT NULL,
    parent_id BIGINT,
    level INTEGER DEFAULT 1,
    path VARCHAR(500),
    leader_id BIGINT,
    sort_order INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 角色表
CREATE TABLE sys_role (
    role_id BIGSERIAL PRIMARY KEY,
    role_code VARCHAR(50) UNIQUE NOT NULL,
    role_name VARCHAR(100) NOT NULL,
    role_type VARCHAR(50), -- SYSTEM, BUSINESS, PROJECT
    description TEXT,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 权限表
CREATE TABLE sys_permission (
    permission_id BIGSERIAL PRIMARY KEY,
    permission_code VARCHAR(100) UNIQUE NOT NULL,
    permission_name VARCHAR(200) NOT NULL,
    resource_type VARCHAR(50), -- MENU, BUTTON, API, DATA
    resource_path VARCHAR(255),
    parent_id BIGINT,
    sort_order INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户角色关联表
CREATE TABLE sys_user_role (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    assigned_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    CONSTRAINT uq_user_role UNIQUE (user_id, role_id)
);

-- 角色权限关联表
CREATE TABLE sys_role_permission (
    id BIGSERIAL PRIMARY KEY,
    role_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    assigned_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    CONSTRAINT uq_role_permission UNIQUE (role_id, permission_id)
);

-- 数据权限规则表
CREATE TABLE sys_data_permission (
    rule_id BIGSERIAL PRIMARY KEY,
    rule_code VARCHAR(100) UNIQUE NOT NULL,
    rule_name VARCHAR(200) NOT NULL,
    scope_type VARCHAR(50), -- ALL, DEPT, DEPT_AND_CHILD, SELF, CUSTOM
    scope_config JSONB,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 数据权限分配表
CREATE TABLE sys_role_data_permission (
    id BIGSERIAL PRIMARY KEY,
    role_id BIGINT NOT NULL,
    rule_id BIGINT NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    assigned_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户会话表
CREATE TABLE sys_user_session (
    session_id VARCHAR(100) PRIMARY KEY,
    user_id BIGINT NOT NULL,
    client_ip VARCHAR(50),
    user_agent TEXT,
    login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_active_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expire_time TIMESTAMP NOT NULL
);

-- 操作审计表
CREATE TABLE sys_audit_log (
    log_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    username VARCHAR(50),
    operation VARCHAR(100) NOT NULL,
    module VARCHAR(50) NOT NULL,
    business_key VARCHAR(100),
    request_url TEXT,
    request_method VARCHAR(10),
    request_params JSONB,
    response_data JSONB,
    execute_time INTEGER, -- 执行时长(毫秒)
    client_ip VARCHAR(50),
    status VARCHAR(20), -- SUCCESS, FAILURE
    error_message TEXT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
\`\`\`

#### 2.1.2 基础主数据模块

\`\`\`sql
-- 客户主表
CREATE TABLE md_customer (
    customer_id BIGSERIAL PRIMARY KEY,
    customer_code VARCHAR(50) UNIQUE NOT NULL,
    customer_name VARCHAR(200) NOT NULL,
    customer_type VARCHAR(50), -- AUTOMOTIVE, ELECTRONIC, MECHANICAL
    industry VARCHAR(100),
    region VARCHAR(100),
    country VARCHAR(100),
    address TEXT,
    contact_person VARCHAR(100),
    contact_phone VARCHAR(20),
    contact_email VARCHAR(100),
    tax_number VARCHAR(50),
    credit_level VARCHAR(20), -- A, B, C, D
    status VARCHAR(20) DEFAULT 'ACTIVE',
    sync_status VARCHAR(20) DEFAULT 'UNSYNCED', -- UNSYNCED, SYNCED, FAILED
    sync_time TIMESTAMP,
    erp_customer_id VARCHAR(50),
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 供应商主表
CREATE TABLE md_supplier (
    supplier_id BIGSERIAL PRIMARY KEY,
    supplier_code VARCHAR(50) UNIQUE NOT NULL,
    supplier_name VARCHAR(200) NOT NULL,
    supplier_type VARCHAR(50), -- MATERIAL, SERVICE, BOTH
    qualification_level VARCHAR(50), -- A, B, C
    region VARCHAR(100),
    address TEXT,
    contact_person VARCHAR(100),
    contact_phone VARCHAR(20),
    contact_email VARCHAR(100),
    business_license VARCHAR(100),
    quality_system VARCHAR(50), -- ISO9001, IATF16949, ISO14001
    status VARCHAR(20) DEFAULT 'ACTIVE',
    sync_status VARCHAR(20) DEFAULT 'UNSYNCED',
    sync_time TIMESTAMP,
    erp_supplier_id VARCHAR(50),
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 物料分类表
CREATE TABLE md_material_category (
    category_id BIGSERIAL PRIMARY KEY,
    category_code VARCHAR(50) UNIQUE NOT NULL,
    category_name VARCHAR(200) NOT NULL,
    parent_id BIGINT,
    level INTEGER DEFAULT 1,
    path VARCHAR(500),
    description TEXT,
    sort_order INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 物料主表
CREATE TABLE md_material (
    material_id BIGSERIAL PRIMARY KEY,
    material_code VARCHAR(50) UNIQUE NOT NULL,
    material_name VARCHAR(200) NOT NULL,
    material_type VARCHAR(50), -- RAW, SEMI, FINISHED, AUXILIARY
    category_id BIGINT,
    specification VARCHAR(500),
    base_unit VARCHAR(20),
    material_group VARCHAR(50), -- ALUMINUM, ZINC, MAGNESIUM, STEEL
    grade VARCHAR(100),
    drawing_number VARCHAR(100),
    safety_stock NUMERIC(15,3),
    min_order_qty NUMERIC(15,3),
    inspection_level VARCHAR(20), -- NORMAL, TIGHTENED, RELAXED
    inspection_method VARCHAR(50), -- FULL, SAMPLING, SKIP
    aql_value VARCHAR(20),
    inspection_standard VARCHAR(100), -- MIL-STD-105E, ISO2859-1, GB/T2828.1
    critical CHARACTER(1), -- Y, N
    status VARCHAR(20) DEFAULT 'ACTIVE',
    sync_status VARCHAR(20) DEFAULT 'UNSYNCED',
    sync_time TIMESTAMP,
    erp_material_id VARCHAR(50),
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 供应商物料关联表
CREATE TABLE md_supplier_material (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    material_id BIGINT NOT NULL,
    supplier_material_code VARCHAR(100),
    supplier_material_name VARCHAR(200),
    lead_time INTEGER, -- 交货周期(天)
    min_order_qty NUMERIC(15,3),
    quality_rating VARCHAR(20), -- A, B, C, D
    is_primary BOOLEAN DEFAULT FALSE,
    approval_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, APPROVED, REJECTED
    approval_date TIMESTAMP,
    approval_by BIGINT,
    contract_start_date DATE,
    contract_end_date DATE,
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uq_supplier_material UNIQUE (supplier_id, material_id)
);

-- 客户物料关联表
CREATE TABLE md_customer_material (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    material_id BIGINT NOT NULL,
    customer_material_code VARCHAR(100),
    customer_material_name VARCHAR(200),
    project_code VARCHAR(50),
    drawing_number VARCHAR(100),
    revision VARCHAR(20),
    delivery_requirement VARCHAR(200),
    packaging_requirement TEXT,
    quality_requirement TEXT,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uq_customer_material UNIQUE (customer_id, material_id)
);
\`\`\`

#### 2.1.3 变化点管理模块

\`\`\`sql
-- 变化点主表
CREATE TABLE cp_change_point (
    change_id BIGSERIAL PRIMARY KEY,
    change_number VARCHAR(50) UNIQUE NOT NULL,
    change_title VARCHAR(500) NOT NULL,
    change_type VARCHAR(50) NOT NULL, -- MAN, MACHINE, MATERIAL, METHOD, ENV
    change_sub_type VARCHAR(100), -- 具体的变化子类型
    change_source VARCHAR(50), -- CUSTOMER_REQUEST, INTERNAL_IMPROVEMENT, SUPPLIER_CHANGE, CORRECTIVE_ACTION
    department_id BIGINT,
    requester_id BIGINT NOT NULL,
    request_date TIMESTAMP NOT NULL,
    planned_change_date DATE,
    change_category VARCHAR(50), -- MINOR, MODERATE, MAJOR, CRITICAL
    risk_level VARCHAR(20), -- LOW, MEDIUM, HIGH, CRITICAL
    business_impact TEXT,
    quality_impact TEXT,
    safety_impact TEXT,
    cost_impact NUMERIC(18,2),
    affected_products JSONB, -- 受影响的产品列表
    affected_processes JSONB, -- 受影响的工序列表
    affected_customers JSONB, -- 受影响的客户列表
    affected_suppliers JSONB, -- 受影响的供应商列表
    change_description TEXT NOT NULL,
    change_reason TEXT,
    change_plan TEXT,
    verification_plan TEXT,
    change_status VARCHAR(20) DEFAULT 'DRAFT', -- DRAFT, PENDING_APPROVAL, APPROVED, REJECTED, IMPLEMENTED, CANCELLED
    approval_level VARCHAR(50), -- DEPT_MANAGER, QUALITY_MANAGER, DIRECTOR
    rejection_reason TEXT,
    implemented_date TIMESTAMP,
    verified_date TIMESTAMP,
    verification_result VARCHAR(20), -- PASS, FAIL, CONDITIONAL_PASS
    effectiveness_date DATE,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 变化点附件表
CREATE TABLE cp_change_attachment (
    attachment_id BIGSERIAL PRIMARY KEY,
    change_id BIGINT NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_type VARCHAR(50),
    file_size BIGINT,
    upload_by BIGINT,
    upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    description TEXT
);

-- 变化点影响分析表
CREATE TABLE cp_impact_analysis (
    analysis_id BIGSERIAL PRIMARY KEY,
    change_id BIGINT NOT NULL,
    impact_type VARCHAR(50) NOT NULL, -- QUALITY, COST, DELIVERY, SAFETY, ENVIRONMENT
    impact_description TEXT,
    severity VARCHAR(20), -- LOW, MEDIUM, HIGH, CRITICAL
    probability VARCHAR(20), -- RARE, OCCASIONAL, FREQUENT, CERTAIN
    risk_score INTEGER, -- 风险评分
    mitigation_measures TEXT,
    responsible_person_id BIGINT,
    target_date DATE,
    status VARCHAR(20) DEFAULT 'OPEN', -- OPEN, IN_PROGRESS, CLOSED
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 变化点审批记录表
CREATE TABLE cp_approval_record (
    approval_id BIGSERIAL PRIMARY KEY,
    change_id BIGINT NOT NULL,
    approval_node VARCHAR(50) NOT NULL,
    approval_role VARCHAR(100) NOT NULL,
    approver_id BIGINT,
    approver_name VARCHAR(100),
    approval_decision VARCHAR(20), -- APPROVED, REJECTED, RETURNED
    approval_comment TEXT,
    approval_time TIMESTAMP,
    approval_level INTEGER,
    status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, APPROVED, REJECTED, SKIPPED
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 变化点实施记录表
CREATE TABLE cp_implementation_record (
    implementation_id BIGSERIAL PRIMARY KEY,
    change_id BIGINT NOT NULL,
    implement_step VARCHAR(200),
    step_description TEXT,
    responsible_id BIGINT,
    planned_date DATE,
    actual_date DATE,
    implementation_result TEXT,
    issues_encountered TEXT,
    status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, IN_PROGRESS, COMPLETED, DELAYED
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 变化点验证记录表
CREATE TABLE cp_verification_record (
    verification_id BIGSERIAL PRIMARY KEY,
    change_id BIGINT NOT NULL,
    verification_type VARCHAR(50), -- FUNCTIONAL_TEST, PERFORMANCE_TEST, QUALITY_INSPECTION
    verification_standard VARCHAR(200),
    verification_method TEXT,
    verification_result VARCHAR(20), -- PASS, FAIL, CONDITIONAL
    verification_data JSONB,
    sample_size INTEGER,
    inspector_id BIGINT,
    verification_date TIMESTAMP,
    findings TEXT,
    corrective_actions TEXT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 变化点追溯表
CREATE TABLE cp_traceability (
    traceability_id BIGSERIAL PRIMARY KEY,
    change_id BIGINT NOT NULL,
    production_order_id VARCHAR(50),
    batch_number VARCHAR(100),
    lot_number VARCHAR(100),
    material_id BIGINT,
    customer_id BIGINT,
    product_serial_number VARCHAR(100),
    trace_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    description TEXT
);
\`\`\`

#### 2.1.4 CAPA管理模块

\`\`\`sql
-- CAPA主表
CREATE TABLE capa (
    capa_id BIGSERIAL PRIMARY KEY,
    capa_number VARCHAR(50) UNIQUE NOT NULL,
    capa_type VARCHAR(20) NOT NULL, -- CORRECTIVE, PREVENTIVE
    severity VARCHAR(20), -- LOW, MEDIUM, HIGH, CRITICAL
    source_type VARCHAR(50), -- CUSTOMER_COMPLAINT, INTERNAL_AUDIT, NONCONFORMANCE, TREND_ANALYSIS
    source_id BIGINT,
    source_number VARCHAR(50),
    department_id BIGINT,
    requester_id BIGINT NOT NULL,
    request_date TIMESTAMP NOT NULL,
    problem_description TEXT NOT NULL,
    problem_category VARCHAR(100),
    affected_area VARCHAR(200),
    capa_status VARCHAR(20) DEFAULT 'OPEN', -- OPEN, IN_PROGRESS, CLOSED, CANCELLED
    priority VARCHAR(20), -- LOW, MEDIUM, HIGH, URGENT
    target_completion_date DATE,
    actual_completion_date DATE,
    effectiveness_verification VARCHAR(20), -- PENDING, PASSED, FAILED
    effectiveness_comment TEXT,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-问题分析表
CREATE TABLE capa_problem_analysis (
    analysis_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    analysis_method VARCHAR(50), -- FIVE_WHY, FISHBONE, FTA, 8D
    analysis_date TIMESTAMP,
    analyst_id BIGINT,
    analysis_content TEXT,
    attachments JSONB,
    root_cause_identified BOOLEAN DEFAULT FALSE,
    root_cause_description TEXT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-5Why分析表
CREATE TABLE capa_five_why_analysis (
    five_why_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    analysis_order INTEGER NOT NULL, -- 第几个Why
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    verification_method TEXT,
    is_root_cause BOOLEAN DEFAULT FALSE,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-鱼骨图分析表
CREATE TABLE capa_fishbone_analysis (
    fishbone_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    category VARCHAR(50) NOT NULL, -- MAN, MACHINE, MATERIAL, METHOD, MEASUREMENT, ENVIRONMENT
    factor TEXT NOT NULL,
    sub_factors JSONB,
    is_contributing_factor BOOLEAN DEFAULT FALSE,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-FTA故障树分析表
CREATE TABLE capa_fta_analysis (
    fta_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    event_id VARCHAR(50),
    event_description TEXT NOT NULL,
    event_type VARCHAR(50), -- TOP_EVENT, INTERMEDIATE_EVENT, BASIC_EVENT
    parent_event_id BIGINT,
    logic_gate VARCHAR(20), -- AND, OR
    probability NUMERIC(10,4),
    consequence VARCHAR(200),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-纠正措施表
CREATE TABLE capa_corrective_action (
    corrective_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    action_number VARCHAR(50),
    action_description TEXT NOT NULL,
    action_type VARCHAR(50), -- IMMEDIATE, INTERMEDIATE, PERMANENT
    objective TEXT,
    target_date DATE NOT NULL,
    responsible_person_id BIGINT NOT NULL,
    department_id BIGINT,
    required_resources TEXT,
    budget NUMERIC(18,2),
    action_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, IN_PROGRESS, COMPLETED, DELAYED
    completion_date DATE,
    completion_report TEXT,
    verification_status VARCHAR(20), -- PENDING, PASSED, FAILED
    verifier_id BIGINT,
    verification_date TIMESTAMP,
    effectiveness_rating VARCHAR(20), -- EFFECTIVE, PARTIALLY_EFFECTIVE, NOT_EFFECTIVE
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-预防措施表
CREATE TABLE capa_preventive_action (
    preventive_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    action_number VARCHAR(50),
    action_description TEXT NOT NULL,
    risk_description TEXT,
    objective TEXT,
    target_date DATE NOT NULL,
    responsible_person_id BIGINT NOT NULL,
    department_id BIGINT,
    required_resources TEXT,
    budget NUMERIC(18,2),
    action_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, IN_PROGRESS, COMPLETED, DELAYED
    completion_date DATE,
    completion_report TEXT,
    verification_status VARCHAR(20), -- PENDING, PASSED, FAILED
    verifier_id BIGINT,
    verification_date TIMESTAMP,
    effectiveness_rating VARCHAR(20), -- EFFECTIVE, PARTIALLY_EFFECTIVE, NOT_EFFECTIVE
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-有效性验证表
CREATE TABLE capa_effectiveness_verification (
    verification_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    verification_type VARCHAR(50), -- MONITORING, AUDIT, METRIC_REVIEW
    verification_period_start DATE,
    verification_period_end DATE,
    verification_method TEXT,
    verification_criteria TEXT,
    data_collected JSONB,
    analysis_result TEXT,
    effectiveness_score NUMERIC(5,2), -- 0-100
    effectiveness_level VARCHAR(20), -- EXCELLENT, GOOD, SATISFACTORY, POOR
    verifier_id BIGINT,
    verification_date TIMESTAMP,
    follow_up_required BOOLEAN DEFAULT FALSE,
    follow_up_actions TEXT,
    status VARCHAR(20) DEFAULT 'COMPLETED',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-任务分配表
CREATE TABLE capa_task (
    task_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    task_number VARCHAR(50),
    task_title VARCHAR(500) NOT NULL,
    task_description TEXT,
    task_type VARCHAR(50), -- INVESTIGATION, IMPLEMENTATION, VERIFICATION, DOCUMENTATION
    priority VARCHAR(20), -- LOW, MEDIUM, HIGH, URGENT
    assignee_id BIGINT NOT NULL,
    department_id BIGINT,
    planned_start_date DATE,
    planned_end_date DATE NOT NULL,
    actual_start_date DATE,
    actual_end_date DATE,
    task_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, IN_PROGRESS, COMPLETED, ON_HOLD, CANCELLED
    progress NUMERIC(5,2), -- 0-100
    completion_report TEXT,
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CAPA-成本记录表
CREATE TABLE capa_cost (
    cost_id BIGSERIAL PRIMARY KEY,
    capa_id BIGINT NOT NULL,
    cost_category VARCHAR(50), -- LABOR, MATERIAL, EQUIPMENT, LOST_PRODUCTIVITY, OPPORTUNITY_COST
    cost_description TEXT,
    estimated_cost NUMERIC(18,2),
    actual_cost NUMERIC(18,2),
    currency VARCHAR(10) DEFAULT 'CNY',
    cost_date DATE,
    recorded_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
\`\`\`

#### 2.1.5 QRQC快速响应质量控制模块

\`\`\`sql
-- QRQC事件主表
CREATE TABLE qrqc_event (
    event_id BIGSERIAL PRIMARY KEY,
    event_number VARCHAR(50) UNIQUE NOT NULL,
    event_type VARCHAR(50) NOT NULL, -- QUALITY_ISSUE, CUSTOMER_COMPLAINT, PROCESS_DEVIATION
    severity VARCHAR(20), -- LOW, MEDIUM, HIGH, CRITICAL
    detection_time TIMESTAMP NOT NULL,
    detection_location VARCHAR(200),
    detection_person_id BIGINT NOT NULL,
    detection_department_id BIGINT,
    event_description TEXT NOT NULL,
    immediate_impact TEXT,
    affected_product VARCHAR(200),
    affected_batch VARCHAR(100),
    affected_quantity INTEGER,
    customer_id BIGINT,
    work_order_id VARCHAR(50),
    process_step VARCHAR(100),
    event_category VARCHAR(100),
    qrqc_status VARCHAR(20) DEFAULT 'OPEN', -- OPEN, CONTAINED, INVESTIGATING, RESOLVED, CLOSED
    response_team_id BIGINT,
    team_leader_id BIGINT,
    response_target_time TIMESTAMP, -- 响应目标时间(24小时内)
    actual_response_time TIMESTAMP,
    containment_target_time TIMESTAMP, -- 围堵目标时间
    actual_containment_time TIMESTAMP,
    investigation_target_time TIMESTAMP,
    actual_investigation_time TIMESTAMP,
    resolution_target_time TIMESTAMP,
    actual_resolution_time TIMESTAMP,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_by BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC团队组建表
CREATE TABLE qrqc_team (
    team_id BIGSERIAL PRIMARY KEY,
    event_id BIGINT NOT NULL,
    team_name VARCHAR(200),
    team_leader_id BIGINT NOT NULL,
    formation_time TIMESTAMP,
    team_members JSONB, -- 成员列表及角色
    meeting_location VARCHAR(200),
    meeting_time TIMESTAMP,
    meeting_notes TEXT,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC团队成员表
CREATE TABLE qrqc_team_member (
    member_id BIGSERIAL PRIMARY KEY,
    team_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    role VARCHAR(50), -- LEADER, QUALITY, ENGINEERING, PRODUCTION, MAINTENANCE
    responsibility TEXT,
    contact_phone VARCHAR(20),
    join_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC现场调查记录表
CREATE TABLE qrqc_investigation (
    investigation_id BIGSERIAL PRIMARY KEY,
    event_id BIGINT NOT NULL,
    investigation_date TIMESTAMP,
    investigator_id BIGINT,
    investigation_location VARCHAR(200),
    investigation_type VARCHAR(50), -- ON_SITE, DOCUMENT_REVIEW, INTERVIEW
    findings TEXT NOT NULL,
    evidence_collected JSONB, -- 收集的证据列表
    photos_json JSONB, -- 照片路径
    witnesses JSONB, -- 目击者信息
    preliminary_cause TEXT,
    next_steps TEXT,
    status VARCHAR(20) DEFAULT 'COMPLETED',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC围堵措施表
CREATE TABLE qrqc_containment (
    containment_id BIGSERIAL PRIMARY KEY,
    event_id BIGINT NOT NULL,
    containment_number VARCHAR(50),
    containment_description TEXT NOT NULL,
    containment_type VARCHAR(50), -- INSPECTION, SEGREGATION, REWORK, SCRAP
    affected_product VARCHAR(200),
    affected_batch VARCHAR(100),
    affected_quantity INTEGER,
    quarantine_location VARCHAR(200),
    inspection_method TEXT,
    sample_size INTEGER,
    inspected_quantity INTEGER,
    nonconforming_quantity INTEGER,
    responsible_person_id BIGINT NOT NULL,
    planned_date DATE,
    actual_date DATE,
    containment_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, IN_PROGRESS, COMPLETED
    completion_report TEXT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC时间线记录表
CREATE TABLE qrqc_timeline (
    timeline_id BIGSERIAL PRIMARY KEY,
    event_id BIGINT NOT NULL,
    event_time TIMESTAMP NOT NULL,
    event_type VARCHAR(50) NOT NULL, -- DETECTION, REPORTING, TEAM_FORMATION, INVESTIGATION, CONTAINMENT, RESOLUTION
    event_description TEXT,
    actor_id BIGINT,
    action_taken TEXT,
    status VARCHAR(20) DEFAULT 'COMPLETED',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC24小时响应跟踪表
CREATE TABLE qrqc_24h_tracking (
    tracking_id BIGSERIAL PRIMARY KEY,
    event_id BIGINT NOT NULL,
    milestone VARCHAR(50) NOT NULL, -- REPORTING_1H, TEAM_ASSEMBLY_4H, INVESTIGATION_12H, CONTAINMENT_24H
    planned_time TIMESTAMP NOT NULL,
    actual_time TIMESTAMP,
    status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, ACHIEVED, DELAYED, MISSED
    delay_reason TEXT,
    responsible_person_id BIGINT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- QRQC围堵效果跟踪表
CREATE TABLE qrqc_containment_effect (
    effect_id BIGSERIAL PRIMARY KEY,
    event_id BIGINT NOT NULL,
    containment_id BIGINT,
    effect_type VARCHAR(50), -- CUSTOMER_NOTIFIED, PRODUCT_ISOLATED, REWORK_COMPLETED, SCRAP_PROCESSED
    effect_description TEXT,
    affected_quantity INTEGER,
    customer_impact TEXT,
    financial_impact NUMERIC(18,2),
    verification_date TIMESTAMP,
    verified_by BIGINT,
    status VARCHAR(20) DEFAULT 'VERIFIED',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
\`\`\`

---

## 3. MongoDB 集合设计

### 3.1 知识库集合 (Knowledge Base)

\`\`\`javascript
// 知识库文章集合
db.createCollection("KnowledgeBaseArticles", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["articleId", "title", "category", "content", "createdBy", "createdTime"],
      properties: {
        articleId: { bsonType: "string" },
        title: { bsonType: "string" },
        summary: { bsonType: "string" },
        category: { bsonType: "string", enum: ["EXPERIENCE", "BEST_PRACTICE", "FAILURE_CASE", "LESSON_LEARNED", "KNOWLEDGE_SHARING"] },
        subCategory: { bsonType: "string" },
        tags: { bsonType: "array", items: { bsonType: "string" } },
        content: { bsonType: "string" },
        attachments: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              fileName: { bsonType: "string" },
              filePath: { bsonType: "string" },
              fileType: { bsonType: "string" },
              fileSize: { bsonType: "long" }
            }
          }
        },
        relatedArticles: { bsonType: "array", items: { bsonType: "string" } },
        viewCount: { bsonType: "int", default: 0 },
        rating: { bsonType: "decimal", default: 0.0 },
        ratingCount: { bsonType: "int", default: 0 },
        comments: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              commentId: { bsonType: "string" },
              userId: { bsonType: "long" },
              userName: { bsonType: "string" },
              content: { bsonType: "string" },
              commentTime: { bsonType: "date" },
              parentId: { bsonType: "string" }
            }
          }
        },
        approvalStatus: { bsonType: "string", enum: ["DRAFT", "PENDING_APPROVAL", "APPROVED", "REJECTED"] },
        approverId: { bsonType: "long" },
        approvalTime: { bsonType: "date" },
        createdBy: { bsonType: "long" },
        createdTime: { bsonType: "date" },
        updatedBy: { bsonType: "long" },
        updatedTime: { bsonType: "date" },
        status: { bsonType: "string", enum: ["ACTIVE", "INACTIVE", "ARCHIVED"], default: "ACTIVE" }
      }
    }
  },
  validationLevel: "moderate",
  validationAction: "warn"
});

// 索引创建
db.KnowledgeBaseArticles.createIndex({ articleId: 1 }, { unique: true });
db.KnowledgeBaseArticles.createIndex({ category: 1, subCategory: 1 });
db.KnowledgeBaseArticles.createIndex({ tags: 1 });
db.KnowledgeBaseArticles.createIndex({ title: "text", content: "text", summary: "text" });
db.KnowledgeBaseArticles.createIndex({ createdTime: -1 });
db.KnowledgeBaseArticles.createIndex({ createdBy: 1, createdTime: -1 });
\`\`\`

### 3.2 8D报告集合 (8D Reports)

\`\`\`javascript
// 8D报告主集合
db.createCollection("EightDReports", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["reportId", "reportNumber", "complaintSource", "createdBy", "createdTime"],
      properties: {
        reportId: { bsonType: "string" },
        reportNumber: { bsonType: "string" },
        complaintSource: { bsonType: "string", enum: ["CUSTOMER", "INTERNAL", "SUPPLIER", "REGULATORY"] },
        customerId: { bsonType: "long" },
        supplierId: { bsonType: "long" },
        problemDescription: { bsonType: "string" },
        detectionDate: { bsonType: "date" },
        severity: { bsonType: "string", enum: ["LOW", "MEDIUM", "HIGH", "CRITICAL"] },
        priority: { bsonType: "string", enum: ["LOW", "MEDIUM", "HIGH", "URGENT"] },
        
        // D1: 成立小组
        teamLeaderId: { bsonType: "long" },
        teamMembers: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              userId: { bsonType: "long" },
              userName: { bsonType: "string" },
              role: { bsonType: "string" },
              responsibility: { bsonType: "string" }
            }
          }
        },
        
        // D2: 问题描述
        problemStatement: { bsonType: "string" },
        what5W2H: {
          bsonType: "object",
          properties: {
            what: { bsonType: "string" },
            who: { bsonType: "string" },
            where: { bsonType: "string" },
            when: { bsonType: "string" },
            why: { bsonType: "string" },
            how: { bsonType: "string" },
            howMany: { bsonType: "string" }
          }
        },
        
        // D3: 临时围堵措施
        containmentActions: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              actionId: { bsonType: "string" },
              actionDescription: { bsonType: "string" },
              responsibleId: { bsonType: "long" },
              targetDate: { bsonType: "date" },
              actualDate: { bsonType: "date" },
              effectiveness: { bsonType: "string" }
            }
          }
        },
        
        // D4: 根本原因分析
        rootCauseAnalysis: {
          bsonType: "object",
          properties: {
            analysisMethod: { bsonType: "string" },
            directCause: { bsonType: "string" },
            rootCause: { bsonType: "string" },
            contributingFactors: { bsonType: "array", items: { bsonType: "string" } },
            fiveWhys: { bsonType: "array", items: { bsonType: "object" } },
            fishbone: { bsonType: "object" }
          }
        },
        
        // D5: 永久纠正措施
        permanentCorrectiveActions: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              actionId: { bsonType: "string" },
              actionDescription: { bsonType: "string" },
              responsibleId: { bsonType: "long" },
              targetDate: { bsonType: "date" },
              actualDate: { bsonType: "date" },
              effectiveness: { bsonType: "string" }
            }
          }
        },
        
        // D6: 实施纠正措施
        implementationStatus: { bsonType: "string" },
        implementationEvidence: { bsonType: "array", items: { bsonType: "string" } },
        
        // D7: 预防再发生措施
        preventiveActions: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              actionId: { bsonType: "string" },
              actionDescription: { bsonType: "string" },
              responsibleId: { bsonType: "long" },
              targetDate: { bsonType: "date" },
              actualDate: { bsonType: "date" },
              type: { bsonType: "string", enum: ["SYSTEM_UPDATE", "TRAINING", "DOCUMENTATION", "PROCESS_CHANGE"] }
            }
          }
        },
        
        // D8: 小组祝贺
        teamRecognition: { bsonType: "string" },
        lessonsLearned: { bsonType: "string" },
        financialImpact: { bsonType: "decimal" },
        customerNotified: { bsonType: "bool" },
        notificationDate: { bsonType: "date" },
        
        reportStatus: { bsonType: "string", enum: ["DRAFT", "IN_PROGRESS", "COMPLETED", "VERIFIED", "CLOSED"] },
        targetCompletionDate: { bsonType: "date" },
        actualCompletionDate: { bsonType: "date" },
        verifierId: { bsonType: "long" },
        verificationDate: { bsonType: "date" },
        
        createdBy: { bsonType: "long" },
        createdTime: { bsonType: "date" },
        updatedBy: { bsonType: "long" },
        updatedTime: { bsonType: "date" },
        
        attachments: { bsonType: "array", items: { bsonType: "string" } },
        status: { bsonType: "string", enum: ["ACTIVE", "INACTIVE", "ARCHIVED"], default: "ACTIVE" }
      }
    }
  }
});

// 索引
db.EightDReports.createIndex({ reportId: 1 }, { unique: true });
db.EightDReports.createIndex({ reportNumber: 1 }, { unique: true });
db.EightDReports.createIndex({ customerId: 1 });
db.EightDReports.createIndex({ complaintSource: 1 });
db.EightDReports.createIndex({ reportStatus: 1 });
db.EightDReports.createIndex({ detectionDate: -1 });
\`\`\`

### 3.3 审核记录集合 (Audit Records)

\`\`\`javascript
// 审核记录集合
db.createCollection("AuditRecords", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["auditId", "auditType", "auditDate", "createdTime"],
      properties: {
        auditId: { bsonType: "string" },
        auditNumber: { bsonType: "string" },
        auditType: { bsonType: "string", enum: ["INTERNAL", "EXTERNAL", "SUPPLIER", "SECOND_PARTY", "LPA", "PRODUCT"] },
        auditSubType: { bsonType: "string" },
        auditCategory: { bsonType: "string" },
        
        // 审核计划信息
        plannedStartDate: { bsonType: "date" },
        plannedEndDate: { bsonType: "date" },
        actualStartDate: { bsonType: "date" },
        actualEndDate: { bsonType: "date" },
        auditLocation: { bsonType: "string" },
        
        // 审核团队
        auditTeam: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              auditorId: { bsonType: "long" },
              auditorName: { bsonType: "string" },
              role: { bsonType: "string" }, // LEAD_AUDITOR, AUDITOR, OBSERVER
              qualifications: { bsonType: "string" }
            }
          }
        },
        leadAuditorId: { bsonType: "long" },
        
        // 审核范围
        auditScope: { bsonType: "string" },
        departments: { bsonType: "array", items: { bsonType: "string" } },
        processes: { bsonType: "array", items: { bsonType: "string" } },
        standards: { bsonType: "array", items: { bsonType: "string" }, default: ["IATF16949"] },
        
        // 审核发现
        findings: {
          bsonType: "array",
          items: {
            bsonType: "object",
            properties: {
              findingId: { bsonType: "string" },
              clause: { bsonType: "string" },
              findingType: { bsonType: "string", enum: ["MAJOR_NC", "MINOR_NC", "OPPORTUNITY_IMPROVEMENT", "STRENGTH"] },
              description: { bsonType: "string" },
              evidence: { bsonType: "string" },
              severity: { bsonType: "string" },
              responsibleDepartment: { bsonType: "string" },
              rootCauseAnalysis: { bsonType: "string" },
              correctiveAction: { bsonType: "string" },
              targetDate: { bsonType: "date" },
              verificationDate: { bsonType: "date" },
              status: { bsonType: "string", enum: ["OPEN", "IN_PROGRESS", "CLOSED"] }
            }
          }
        },
        
        // 审核结果
        overallRating: { bsonType: "string", enum: ["EXCELLENT", "GOOD", "SATISFACTORY", "NEEDS_IMPROVEMENT", "POOR"] },
        totalFindings: { bsonType: "int" },
        majorNCCount: { bsonType: "int" },
        minorNCCount: { bsonType: "int" },
        opportunityCount: { bsonType: "int" },
        strengthCount: { bsonType: "int" },
        
        // LPA特有字段
        lpaLayer: { bsonType: "string", enum: ["OPERATOR", "SUPERVISOR", "MANAGER", "EXECUTIVE"] },
        lpaFrequency: { bsonType: "string", enum: ["DAILY", "WEEKLY", "MONTHLY", "QUARTERLY"] },
        lpaScore: { bsonType: "decimal" },
        lpaProcessArea: { bsonType: "string" },
        
        auditStatus: { bsonType: "string", enum: ["PLANNED", "IN_PROGRESS", "COMPLETED", "CLOSED"] },
        auditorSignature: { bsonType: "string" },
        auditeeSignature: { bsonType: "string" },
        approvalDate: { bsonType: "date" },
        
        createdBy: { bsonType: "long" },
        createdTime: { bsonType: "date" },
        updatedBy: { bsonType: "long" },
        updatedTime: { bsonType: "date" },
        
        attachments: { bsonType: "array", items: { bsonType: "string" } },
        comments: { bsonType: "array", items: { bsonType: "object" } }
      }
    }
  }
});

// 索引
db.AuditRecords.createIndex({ auditId: 1 }, { unique: true });
db.AuditRecords.createIndex({ auditType: 1, auditDate: -1 });
db.AuditRecords.createIndex({ auditStatus: 1 });
db.AuditRecords.createIndex({ lpaLayer: 1 });
db.AuditRecords.createIndex({ leadAuditorId: 1 });
\`\`\`

---

## 4. InfluxDB 数据设计

### 4.1 生产过程参数 (Production Process Parameters)

\`\`\`sql
-- 生产过程参数测量点
CREATE MEASUREMENT production_process_params (
  time TIMESTAMP,
  equipment_id TAG,
  process_step TAG,
  parameter_name TAG,
  parameter_type TAG, -- PRESSURE, TEMPERATURE, SPEED, CYCLE_TIME, VACUUM
  material_type TAG, -- ALUMINUM, ZINC, MAGNESIUM
  batch_number TAG,
  work_order_id TAG,
  
  parameter_value FIELD(REAL),
  min_threshold FIELD(REAL),
  max_threshold FIELD(REAL),
  unit TAG,
  is_abnormal TAG,
  
  operator_id TAG,
  production_line TAG
);

-- 索引策略
CREATE INDEX ON production_process_params(time);
CREATE INDEX ON production_process_params(equipment_id);
CREATE INDEX ON production_process_params(batch_number);
CREATE INDEX ON production_process_params(work_order_id);
\`\`\`

### 4.2 SPC控制点数据 (SPC Control Points)

\`\`\`sql
-- SPC控制点数据
CREATE MEASUREMENT spc_control_points (
  time TIMESTAMP,
  control_point_id TAG,
  characteristic_id TAG,
  part_number TAG,
  process_step TAG,
  measurement_type TAG, -- DIMENSION, WEIGHT, HARDNESS, SURFACE_ROUGHNESS
  instrument_id TAG,
  operator_id TAG,
  shift TAG,
  
  sample_number FIELD(INTEGER),
  measurement_value FIELD(REAL),
  subgroup_size FIELD(INTEGER),
  
  -- 控制限
  lsl FIELD(REAL), -- 规格下限
  usl FIELD(REAL), -- 规格上限
  lcl FIELD(REAL), -- 控制下限
  ucl FIELD(REAL), -- 控制上限
  nominal FIELD(REAL), -- 目标值
  
  -- 异常标识
  out_of_control TAG,
  violation_type TAG, -- ONE_POINT_BEYOND_3SIGMA, SIX_POINTS_TREND, FOUR_OUT_OF_FIVE_POINTS, etc.
  
  batch_number TAG,
  work_order_id TAG
);

-- 索引
CREATE INDEX ON spc_control_points(time);
CREATE INDEX ON spc_control_points(control_point_id);
CREATE INDEX ON spc_control_points(characteristic_id);
CREATE INDEX ON spc_control_points(batch_number);
\`\`\`

### 4.3 MSA测量分析数据 (MSA Measurement Analysis)

\`\`\`sql
-- MSA测量数据
CREATE MEASUREMENT msa_measurement_data (
  time TIMESTAMP,
  msa_study_id TAG,
  study_type TAG, -- GR_R, BIAS, LINEARITY, STABILITY
  gage_id TAG,
  operator_id TAG,
  part_id TAG,
  measurement_trial TAG, -- 试验次数
  trial_number FIELD(INTEGER),
  
  measurement_value FIELD(REAL),
  true_value FIELD(REAL), -- 用于偏倚和线性研究
  deviation FIELD(REAL),
  
  sample_number FIELD(INTEGER),
  characteristic_name TAG,
  
  -- Gage R&R计算结果
  total_variance FIELD(REAL),
  equipment_variance FIELD(REAL),
  appraiser_variance FIELD(REAL),
  part_to_part_variance FIELD(REAL),
  
  -- MSA指标
  ev FIELD(REAL), -- Equipment Variation (repeatability)
  av FIELD(REAL), -- Appraiser Variation (reproducibility)
  grr FIELD(REAL), -- Gage R&R
  ndc FIELD(INTEGER), -- Number of Distinct Categories
  pv FIELD(REAL), -- Part Variation
  tv FIELD(REAL), -- Total Variation
  
  study_status TAG, -- IN_PROGRESS, COMPLETED
  analyst_id TAG
);

-- 索引
CREATE INDEX ON msa_measurement_data(time);
CREATE INDEX ON msa_measurement_data(msa_study_id);
CREATE INDEX ON msa_measurement_data(study_type);
CREATE INDEX ON msa_measurement_data(gage_id);
\`\`\`

### 4.4 设备实时监测数据 (Equipment Monitoring)

\`\`\`sql
-- 设备实时监测
CREATE MEASUREMENT equipment_monitoring (
  time TIMESTAMP,
  equipment_id TAG,
  equipment_type TAG, -- DIE_CASTING_MACHINE, ROBOT, CONVEYOR, FURNACE
  equipment_status TAG, -- RUNNING, STOPPED, IDLE, ERROR, MAINTENANCE
  
  -- 运行参数
  temperature FIELD(REAL),
  pressure FIELD(REAL),
  vibration FIELD(REAL),
  current FIELD(REAL),
  voltage FIELD(REAL),
  speed FIELD(REAL),
  
  -- 生产数据
  cycle_time FIELD(REAL),
  shot_count FIELD(INTEGER),
  cavity_count FIELD(INTEGER),
  
  -- 维护信息
  last_maintenance_time TIMESTAMP,
  next_maintenance_time TIMESTAMP,
  maintenance_type TAG,
  
  -- 报警
  alarm_code TAG,
  alarm_level TAG, -- INFO, WARNING, ERROR, CRITICAL
  alarm_message TAG,
  
  operator_id TAG,
  production_line TAG,
  work_order_id TAG
);

-- 索引
CREATE INDEX ON equipment_monitoring(time);
CREATE INDEX ON equipment_monitoring(equipment_id);
CREATE INDEX ON equipment_monitoring(equipment_status);
CREATE INDEX ON equipment_monitoring(alarm_level);
\`\`\`

---

## 5. 数据迁移策略

### 5.1 数据迁移原则

1. **数据完整性**: 确保迁移过程中数据不丢失、不损坏
2. **业务连续性**: 采用渐进式迁移,确保业务不中断
3. **回滚机制**: 每个阶段都有明确的回滚方案
4. **数据验证**: 迁移后进行全面的数据质量检查

### 5.2 数据迁移步骤

\`\`\`sql
-- 1. 现有系统数据评估
-- 2. 数据映射和转换规则定义
-- 3. 测试环境迁移验证
-- 4. 生产环境分批迁移
-- 5. 数据校验和一致性检查
-- 6. 切换和性能监控
\`\`\`

### 5.3 与现有系统集成

\`\`\`sql
-- ERP系统集成视图
CREATE VIEW v_erp_integration_material AS
SELECT 
    m.material_id,
    m.material_code,
    m.material_name,
    m.category_id,
    mc.category_name,
    m.base_unit,
    m.material_group,
    m.status,
    m.sync_status,
    m.erp_material_id,
    m.sync_time
FROM md_material m
LEFT JOIN md_material_category mc ON m.category_id = mc.category_id
WHERE m.sync_status = 'UNSYNCED';

-- MES集成视图
CREATE VIEW v_mes_integration_production AS
SELECT 
    p.production_order_id,
    p.work_order_id,
    p.material_id,
    m.material_name,
    p.plan_quantity,
    p.actual_quantity,
    p.status,
    p.start_time,
    p.end_time
FROM production_order p
LEFT JOIN md_material m ON p.material_id = m.material_id
WHERE p.status IN ('IN_PROGRESS', 'COMPLETED');
\`\`\`

---

## 6. 数据备份与恢复策略

### 6.1 备份策略

| 数据库 | 备份类型 | 频率 | 保留期 |
|--------|---------|------|--------|
| PostgreSQL | 全量 + 增量 | 全量:每天, 增量:每小时 | 全量:30天, 增量:7天 |
| MongoDB | 副本集 + 全量 | 全量:每天 | 30天 |
| InfluxDB | 持续备份 + 快照 | 持续备份, 快照:每天 | 快照:7天 |

### 6.2 灾难恢复方案

\`\`\`
主数据中心 (上海)
  ↓ 实时同步
备数据中心 (苏州)
  ↓ 定期备份
异地容灾中心 (北京)
\`\`\`

---

## 7. 数据安全与访问控制

### 7.1 数据加密

- **传输加密**: TLS 1.3
- **存储加密**: AES-256
- **字段加密**: 敏感字段 (密码、身份证等) 使用字段级加密

### 7.2 访问审计

所有数据访问操作记录到 \`sys_audit_log\` 表,包括:
- 数据查询
- 数据修改
- 数据删除
- 导出操作

### 7.3 数据脱敏

敏感数据在查询时自动脱敏:
- 手机号: 138****5678
- 身份证: 330***********1234
- 邮箱: user***@domain.com

---

## 8. 性能优化建议

### 8.1 索引策略

1. **PostgreSQL**:
   - 主键索引: 所有表都有主键
   - 外键索引: 所有外键字段
   - 查询索引: 根据高频查询创建复合索引
   - 全文检索: 文本字段创建GIN索引

2. **MongoDB**:
   - 单字段索引: 常用查询字段
   - 复合索引: 多条件查询
   - 全文索引: 标题、内容等文本字段
   - 地理索引: 如有地理位置需求

3. **InfluxDB**:
   - Tag索引: 自动创建
   - 时间索引: 自动创建
   - 复合Tag索引: 根据查询模式优化

### 8.2 分库分表策略

对于大数据量表,采用分库分表策略:

| 表名 | 分表策略 | 分表字段 |
|------|---------|---------|
| sys_audit_log | 按月分表 | created_time |
| production_process_params | 按月分表 | time |
| spc_control_points | 按季度分表 | time |

### 8.3 数据归档策略

历史数据定期归档:
- 超过1年的生产数据 → 归档库
- 超过2年的审计日志 → 冷存储
- 超过3年的SPC数据 → 压缩存储

---

## 9. 数据字典

### 9.1 通用状态值

| 类别 | 值 | 说明 |
|------|-----|------|
| 用户状态 | ACTIVE, INACTIVE, LOCKED | 用户账户状态 |
| 流程状态 | DRAFT, PENDING, APPROVED, REJECTED, CANCELLED | 通用流程状态 |
| 优先级 | LOW, MEDIUM, HIGH, URGENT | 任务优先级 |
| 严重性 | LOW, MEDIUM, HIGH, CRITICAL | 问题严重性 |
| 数据状态 | ACTIVE, INACTIVE, ARCHIVED | 数据记录状态 |

### 9.2 质量相关状态

| 类别 | 值 | 说明 |
|------|-----|------|
| 检验结果 | ACCEPT, REJECT, CONDITIONAL_ACCEPT | 检验判定 |
| 风险等级 | LOW, MEDIUM, HIGH, CRITICAL | 风险等级 |
| 质量等级 | A, B, C, D | 质量/供应商等级 |
| 抽样标准 | NORMAL, TIGHTENED, RELAXED | 抽样严格程度 |

---

## 10. 数据库维护计划

### 10.1 定期维护任务

| 任务 | 频率 | 责任人 |
|------|------|--------|
| 数据库性能监控 | 每日 | DBA |
| 索引优化 | 每周 | DBA |
| 统计信息更新 | 每周 | DBA |
| 空间清理 | 每月 | DBA |
| 备份验证 | 每月 | DBA |
| 容灾演练 | 每季度 | DBA + IT |

### 10.2 容量规划

| 数据库 | 当前容量 | 年增长率 | 3年后预估 |
|--------|---------|---------|-----------|
| PostgreSQL | 500GB | 50% | 1.7TB |
| MongoDB | 200GB | 80% | 1.5TB |
| InfluxDB | 300GB | 100% | 2.4TB |

---

## 总结

本数据库设计规范为舜富QMS系统提供了完整的数据架构设计,包括:

1. **PostgreSQL**: 50+张核心业务表,覆盖所有功能模块
2. **MongoDB**: 3个核心集合,用于文档型数据存储
3. **InfluxDB**: 4个核心measurement,用于时序数据存储
4. **数据安全**: 加密、脱敏、审计、备份恢复机制
5. **性能优化**: 索引、分库分表、归档策略
6. **运维保障**: 维护计划、容量规划

数据库设计遵循IATF16949质量管理体系要求,充分考虑压铸行业的特点,支持从原材料到成品的全流程质量追溯。
`,te=`# 舜富QMS系统 - 核心模块详细实现规范

## 1. 变化点管理模块详细实现

### 1.1 模块架构设计

\`\`\`
┌─────────────────────────────────────────────────────────────┐
│              变化点管理模块 - 微服务架构                      │
├─────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                  API Layer (Controller)                │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │  │
│  │  │变化点   │ │审批     │ │影响分析 │ │实施记录 │    │  │
│  │  │Controller│ Controller│Controller│Controller│   │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘    │  │
│  └───────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                 Service Layer                         │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │  │
│  │  │变化点   │ │风险     │ │流程     │ │通知     │    │  │
│  │  │Service  │ │评估     │ │Service  │ │Service  │    │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘    │  │
│  └───────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                 Repository Layer                      │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │  │
│  │  │变化点   │ │审批     │ │影响分析 │ │实施记录 │    │  │
│  │  │Repository│ Repository│Repository│Repository│  │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘    │  │
│  └───────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                    Database Layer                     │  │
│  │  PostgreSQL: cp_change_point (变化点主表)              │  │
│  │  PostgreSQL: cp_approval_record (审批记录表)           │  │
│  │  PostgreSQL: cp_impact_analysis (影响分析表)           │  │
│  │  PostgreSQL: cp_implementation_record (实施记录表)     │  │
│  │  PostgreSQL: cp_verification_record (验证记录表)       │  │
│  └───────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2 核心业务流程

#### 1.2.1 变化点创建与审批流程

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│  变化点完整业务流程图                                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ 草稿创建  │───▶│ 提交审批  │───▶│ 部门经理  │                   │
│  └──────────┘    └──────────┘    └────┬─────┘                   │
│                                       │                          │
│                          ┌────────────┴────────────┐            │
│                          ▼                         ▼            │
│                   ┌──────────┐              ┌──────────┐          │
│                   │ 审批通过  │              │ 审批拒绝  │          │
│                   └────┬─────┘              └──────────┘          │
│                        │                                          │
│                   ┌────┴────┐                                     │
│                   ▼         ▼                                     │
│            ┌──────────┐ ┌──────────┐                             │
│            │ 风险评估  │ │ 质量经理  │                             │
│            └────┬─────┘ └────┬─────┘                             │
│                 │          │                                     │
│        ┌────────┴──────────┴────────┐                            │
│        ▼                           ▼                            │
│  ┌──────────┐              ┌──────────┐                          │
│  │ 重大/关键 │              │ 质量经理  │                          │
│  │需总监审批 │              │ 审批拒绝  │                          │
│  └────┬─────┘              └──────────┘                          │
│       │                                                        │
│       ▼                                                        │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                  │
│  │ 审批完成  │───▶│ 制定实施  │───▶│ 实施变更  │                  │
│  └──────────┘    └──────────┘    └──────────┘                  │
│                                        │                         │
│                                        ▼                         │
│                                  ┌──────────┐                    │
│                                  │ 质量验证  │                    │
│                                  └────┬─────┘                    │
│                                       │                         │
│                            ┌──────────┴──────────┐             │
│                            ▼                     ▼              │
│                     ┌──────────┐          ┌──────────┐          │
│                     │ 验证通过  │          │ 验证失败  │          │
│                     └────┬─────┘          └──────────┘          │
│                          │                                       │
│                          ▼                                       │
│                   ┌──────────┐                                   │
│                   │ 变更关闭  │                                   │
│                   └──────────┘                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

#### 1.2.2 变化点详细流程说明

**步骤1: 变化点草稿创建**
- 申请者填写变化点基本信息
- 系统自动生成变化点编号 (CPYYYYMMNNN)
- 系统根据影响评估初步判断变更类别 (Minor/Moderate/Major/Critical)

**步骤2: 提交审批**
- 提交时系统验证必填字段
- 系统自动判断需要的审批层级
- 根据变化点类别确定审批路径

**步骤3: 部门经理审批**
- 审查变更必要性、技术可行性
- 审批通过→进入风险评估
- 审批拒绝→返回草稿状态,记录拒绝原因

**步骤4: 风险评估**
- 系统根据影响分析自动计算风险评分
- 支持多维度影响评估 (质量、成本、交付、安全、环境)
- 风险评分算法: Risk = Severity × Probability

**步骤5: 质量经理审批**
- 审查风险分析充分性
- 审查质量影响评估
- 重大/关键变更需总监审批

**步骤6: 总监审批 (仅重大/关键变更)**
- 重大变更: 影响范围大、成本高 (>50万)
- 关键变更: 影响安全、法规合规

**步骤7: 制定实施计划**
- 明确实施步骤、责任人、时间节点
- 关联影响分析中的缓解措施
- 制定验证计划和标准

**步骤8: 实施变更**
- 按计划执行变更
- 记录实施过程和遇到的问题
- 实时更新实施进度

**步骤9: 质量验证**
- 执行验证计划
- 收集验证数据
- 判定验证结果 (Pass/Fail/Conditional Pass)

**步骤10: 变更关闭**
- 验证通过→关闭变更,记录生效日期
- 验证失败→启动CAPA流程
- 更新追溯信息

### 1.3 核心类设计

#### 1.3.1 实体类 (Entity)

\`\`\`java
/**
 * 变化点实体类
 */
@Data
@Entity
@Table(name = "cp_change_point")
@DynamicUpdate
public class ChangePoint {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "change_id")
    private Long changeId;
    
    @Column(name = "change_number", unique = true, nullable = false)
    private String changeNumber;
    
    @Column(name = "change_title", nullable = false)
    private String changeTitle;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "change_type", nullable = false)
    private ChangeType changeType; // MAN, MACHINE, MATERIAL, METHOD, ENV
    
    @Column(name = "change_sub_type")
    private String changeSubType;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "change_source")
    private ChangeSource changeSource;
    
    @Column(name = "department_id")
    private Long departmentId;
    
    @Column(name = "requester_id", nullable = false)
    private Long requesterId;
    
    @Column(name = "request_date", nullable = false)
    private LocalDateTime requestDate;
    
    @Column(name = "planned_change_date")
    private LocalDate plannedChangeDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "change_category")
    private ChangeCategory changeCategory; // MINOR, MODERATE, MAJOR, CRITICAL
    
    @Enumerated(EnumType.STRING)
    @Column(name = "risk_level")
    private RiskLevel riskLevel; // LOW, MEDIUM, HIGH, CRITICAL
    
    @Column(name = "business_impact", columnDefinition = "TEXT")
    private String businessImpact;
    
    @Column(name = "quality_impact", columnDefinition = "TEXT")
    private String qualityImpact;
    
    @Column(name = "safety_impact", columnDefinition = "TEXT")
    private String safetyImpact;
    
    @Column(name = "cost_impact")
    private BigDecimal costImpact;
    
    @Type(type = "json")
    @Column(name = "affected_products", columnDefinition = "jsonb")
    private List<AffectedProduct> affectedProducts;
    
    @Type(type = "json")
    @Column(name = "affected_processes", columnDefinition = "jsonb")
    private List<AffectedProcess> affectedProcesses;
    
    @Type(type = "json")
    @Column(name = "affected_customers", columnDefinition = "jsonb")
    private List<AffectedCustomer> affectedCustomers;
    
    @Type(type = "json")
    @Column(name = "affected_suppliers", columnDefinition = "jsonb")
    private List<AffectedSupplier> affectedSuppliers;
    
    @Column(name = "change_description", nullable = false, columnDefinition = "TEXT")
    private String changeDescription;
    
    @Column(name = "change_reason", columnDefinition = "TEXT")
    private String changeReason;
    
    @Column(name = "change_plan", columnDefinition = "TEXT")
    private String changePlan;
    
    @Column(name = "verification_plan", columnDefinition = "TEXT")
    private String verificationPlan;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "change_status", nullable = false)
    private ChangeStatus changeStatus; // DRAFT, PENDING_APPROVAL, APPROVED, REJECTED, IMPLEMENTED, CANCELLED
    
    @Column(name = "approval_level")
    private String approvalLevel;
    
    @Column(name = "rejection_reason", columnDefinition = "TEXT")
    private String rejectionReason;
    
    @Column(name = "implemented_date")
    private LocalDateTime implementedDate;
    
    @Column(name = "verified_date")
    private LocalDateTime verifiedDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "verification_result")
    private VerificationResult verificationResult; // PASS, FAIL, CONDITIONAL_PASS
    
    @Column(name = "effectiveness_date")
    private LocalDate effectivenessDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private RecordStatus status; // ACTIVE, INACTIVE
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "created_time", nullable = false, updatable = false)
    private LocalDateTime createdTime;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
    
    // 关联关系
    @OneToMany(mappedBy = "changePoint", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ChangeAttachment> attachments = new ArrayList<>();
    
    @OneToMany(mappedBy = "changePoint", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ImpactAnalysis> impactAnalyses = new ArrayList<>();
    
    @OneToMany(mappedBy = "changePoint", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ApprovalRecord> approvalRecords = new ArrayList<>();
    
    @OneToMany(mappedBy = "changePoint", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ImplementationRecord> implementationRecords = new ArrayList<>();
    
    @OneToMany(mappedBy = "changePoint", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<VerificationRecord> verificationRecords = new ArrayList<>();
    
    @OneToMany(mappedBy = "changePoint", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Traceability> traceabilities = new ArrayList<>();
}

/**
 * 影响分析实体类
 */
@Data
@Entity
@Table(name = "cp_impact_analysis")
public class ImpactAnalysis {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "analysis_id")
    private Long analysisId;
    
    @Column(name = "change_id", nullable = false)
    private Long changeId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "impact_type", nullable = false)
    private ImpactType impactType; // QUALITY, COST, DELIVERY, SAFETY, ENVIRONMENT
    
    @Column(name = "impact_description", columnDefinition = "TEXT")
    private String impactDescription;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "severity")
    private Severity severity; // LOW, MEDIUM, HIGH, CRITICAL
    
    @Enumerated(EnumType.STRING)
    @Column(name = "probability")
    private Probability probability; // RARE, OCCASIONAL, FREQUENT, CERTAIN
    
    @Column(name = "risk_score")
    private Integer riskScore;
    
    @Column(name = "mitigation_measures", columnDefinition = "TEXT")
    private String mitigationMeasures;
    
    @Column(name = "responsible_person_id")
    private Long responsiblePersonId;
    
    @Column(name = "target_date")
    private LocalDate targetDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private AnalysisStatus status; // OPEN, IN_PROGRESS, CLOSED
    
    @Column(name = "created_time", nullable = false, updatable = false)
    private LocalDateTime createdTime;
    
    // 关联关系
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "change_id", insertable = false, updatable = false)
    private ChangePoint changePoint;
}
\`\`\`

#### 1.3.2 服务层 (Service)

\`\`\`java
/**
 * 变化点服务接口
 */
public interface ChangePointService {
    
    /**
     * 创建变化点草稿
     */
    ChangePointDTO createChangePointDraft(ChangePointCreateDTO dto);
    
    /**
     * 提交审批
     */
    ChangePointDTO submitForApproval(Long changeId);
    
    /**
     * 审批变化点
     */
    ChangePointDTO approveChangePoint(Long changeId, ApprovalDTO dto);
    
    /**
     * 创建影响分析
     */
    ImpactAnalysisDTO createImpactAnalysis(Long changeId, ImpactAnalysisCreateDTO dto);
    
    /**
     * 计算风险评分
     */
    RiskAssessmentResult calculateRiskScore(Long changeId);
    
    /**
     * 制定实施计划
     */
    ChangePointDTO createImplementationPlan(Long changeId, ImplementationPlanCreateDTO dto);
    
    /**
     * 实施变更
     */
    ChangePointDTO implementChange(Long changeId, Long implementationId, ImplementationDTO dto);
    
    /**
     * 质量验证
     */
    ChangePointDTO verifyChange(Long changeId, VerificationDTO dto);
    
    /**
     * 关闭变更
     */
    ChangePointDTO closeChange(Long changeId);
    
    /**
     * 查询变化点详情
     */
    ChangePointDetailDTO getChangePointDetail(Long changeId);
    
    /**
     * 查询变化点列表
     */
    PageResult<ChangePointDTO> searchChangePoints(ChangePointQueryDTO queryDTO);
    
    /**
     * 添加追溯信息
     */
    TraceabilityDTO addTraceability(Long changeId, TraceabilityCreateDTO dto);
}

/**
 * 变化点服务实现类
 */
@Service
@Transactional
@Slf4j
public class ChangePointServiceImpl implements ChangePointService {
    
    @Autowired
    private ChangePointRepository changePointRepository;
    
    @Autowired
    private ImpactAnalysisRepository impactAnalysisRepository;
    
    @Autowired
    private ApprovalRecordRepository approvalRecordRepository;
    
    @Autowired
    private ApprovalWorkflowService approvalWorkflowService;
    
    @Autowired
    private RiskAssessmentService riskAssessmentService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private TraceabilityService traceabilityService;
    
    /**
     * 创建变化点草稿
     */
    @Override
    public ChangePointDTO createChangePointDraft(ChangePointCreateDTO dto) {
        log.info("创建变化点草稿,请求人: {}", SecurityUtils.getCurrentUserId());
        
        // 1. 数据验证
        validateChangePointData(dto);
        
        // 2. 生成变化点编号
        String changeNumber = generateChangeNumber();
        
        // 3. 创建变化点实体
        ChangePoint changePoint = new ChangePoint();
        BeanUtils.copyProperties(dto, changePoint);
        changePoint.setChangeNumber(changeNumber);
        changePoint.setRequesterId(SecurityUtils.getCurrentUserId());
        changePoint.setRequestDate(LocalDateTime.now());
        changePoint.setChangeStatus(ChangeStatus.DRAFT);
        changePoint.setStatus(RecordStatus.ACTIVE);
        changePoint.setCreatedBy(SecurityUtils.getCurrentUserId());
        changePoint.setCreatedTime(LocalDateTime.now());
        
        // 4. 初步判断变更类别
        ChangeCategory category = determineInitialCategory(dto);
        changePoint.setChangeCategory(category);
        
        // 5. 保存变化点
        changePoint = changePointRepository.save(changePoint);
        
        log.info("变化点草稿创建成功,变化点编号: {}", changeNumber);
        
        // 6. 创建DTO返回
        return convertToDTO(changePoint);
    }
    
    /**
     * 提交审批
     */
    @Override
    public ChangePointDTO submitForApproval(Long changeId) {
        log.info("提交变化点审批,变化点ID: {}", changeId);
        
        // 1. 查询变化点
        ChangePoint changePoint = getChangePointById(changeId);
        
        // 2. 验证状态
        if (changePoint.getChangeStatus() != ChangeStatus.DRAFT) {
            throw new BusinessException("只有草稿状态的变化点才能提交审批");
        }
        
        // 3. 验证必填字段
        validateRequiredFieldsForApproval(changePoint);
        
        // 4. 更新状态
        changePoint.setChangeStatus(ChangeStatus.PENDING_APPROVAL);
        changePoint.setUpdatedBy(SecurityUtils.getCurrentUserId());
        changePoint.setUpdatedTime(LocalDateTime.now());
        changePointRepository.save(changePoint);
        
        // 5. 启动审批流程
        approvalWorkflowService.startApprovalProcess(changePoint);
        
        // 6. 发送通知
        sendApprovalNotification(changePoint);
        
        log.info("变化点提交审批成功,变化点编号: {}", changePoint.getChangeNumber());
        
        return convertToDTO(changePoint);
    }
    
    /**
     * 审批变化点
     */
    @Override
    public ChangePointDTO approveChangePoint(Long changeId, ApprovalDTO dto) {
        log.info("审批变化点,变化点ID: {}, 审批结果: {}", changeId, dto.getApprovalDecision());
        
        // 1. 查询变化点
        ChangePoint changePoint = getChangePointById(changeId);
        
        // 2. 验证状态
        if (changePoint.getChangeStatus() != ChangeStatus.PENDING_APPROVAL) {
            throw new BusinessException("只有待审批状态的变化点才能审批");
        }
        
        // 3. 验证审批权限
        validateApprovalPermission(changePoint);
        
        // 4. 记录审批记录
        ApprovalRecord approvalRecord = createApprovalRecord(changePoint, dto);
        approvalRecordRepository.save(approvalRecord);
        
        // 5. 根据审批结果处理
        if (ApprovalDecision.APPROVED == dto.getApprovalDecision()) {
            handleApprovalSuccess(changePoint, approvalRecord);
        } else {
            handleApprovalRejection(changePoint, approvalRecord);
        }
        
        changePointRepository.save(changePoint);
        
        log.info("变化点审批完成,变化点编号: {}, 审批结果: {}", 
            changePoint.getChangeNumber(), changePoint.getChangeStatus());
        
        return convertToDTO(changePoint);
    }
    
    /**
     * 处理审批通过
     */
    private void handleApprovalSuccess(ChangePoint changePoint, ApprovalRecord approvalRecord) {
        log.info("变化点审批通过,变化点编号: {}", changePoint.getChangeNumber());
        
        // 检查是否为最后一个审批节点
        boolean isLastNode = approvalWorkflowService.isLastApprovalNode(
            changePoint.getChangeId(), 
            approvalRecord.getApprovalNode()
        );
        
        if (isLastNode) {
            // 所有审批节点都通过,更新状态为已批准
            changePoint.setChangeStatus(ChangeStatus.APPROVED);
            changePoint.setApprovalLevel(approvalRecord.getApprovalNode());
            
            // 发送实施准备通知
            sendImplementationPreparationNotification(changePoint);
            
            // 如果需要追溯,自动创建追溯记录
            if (requiresTraceability(changePoint)) {
                createAutomaticTraceability(changePoint);
            }
        } else {
            // 进入下一个审批节点
            approvalWorkflowService.moveToNextNode(changePoint);
            
            // 发送下一级审批通知
            sendNextApprovalNotification(changePoint);
        }
    }
    
    /**
     * 处理审批拒绝
     */
    private void handleApprovalRejection(ChangePoint changePoint, ApprovalRecord approvalRecord) {
        log.info("变化点审批拒绝,变化点编号: {}, 拒绝原因: {}", 
            changePoint.getChangeNumber(), approvalRecord.getApprovalComment());
        
        // 更新状态
        changePoint.setChangeStatus(ChangeStatus.REJECTED);
        changePoint.setRejectionReason(approvalRecord.getApprovalComment());
        
        // 停止审批流程
        approvalWorkflowService.terminateApprovalProcess(changePoint.getChangeId());
        
        // 发送拒绝通知
        sendRejectionNotification(changePoint, approvalRecord);
    }
    
    /**
     * 创建影响分析
     */
    @Override
    public ImpactAnalysisDTO createImpactAnalysis(Long changeId, ImpactAnalysisCreateDTO dto) {
        log.info("创建影响分析,变化点ID: {}, 影响类型: {}", changeId, dto.getImpactType());
        
        // 1. 查询变化点
        ChangePoint changePoint = getChangePointById(changeId);
        
        // 2. 验证状态
        if (changePoint.getChangeStatus() != ChangeStatus.APPROVED) {
            throw new BusinessException("只有已批准的变化点才能创建影响分析");
        }
        
        // 3. 创建影响分析实体
        ImpactAnalysis analysis = new ImpactAnalysis();
        BeanUtils.copyProperties(dto, analysis);
        analysis.setChangeId(changeId);
        analysis.setStatus(AnalysisStatus.OPEN);
        analysis.setCreatedTime(LocalDateTime.now());
        
        // 4. 计算风险评分
        analysis.setRiskScore(calculateRiskScore(dto.getSeverity(), dto.getProbability()));
        
        // 5. 保存影响分析
        analysis = impactAnalysisRepository.save(analysis);
        
        log.info("影响分析创建成功,分析ID: {}, 风险评分: {}", 
            analysis.getAnalysisId(), analysis.getRiskScore());
        
        // 6. 重新计算整体风险等级
        riskAssessmentService.updateOverallRiskLevel(changeId);
        
        return convertToAnalysisDTO(analysis);
    }
    
    /**
     * 计算风险评分
     */
    private Integer calculateRiskScore(Severity severity, Probability probability) {
        int severityScore = getSeverityScore(severity);
        int probabilityScore = getProbabilityScore(probability);
        return severityScore * probabilityScore;
    }
    
    /**
     * 获取严重性评分
     */
    private int getSeverityScore(Severity severity) {
        switch (severity) {
            case LOW: return 1;
            case MEDIUM: return 2;
            case HIGH: return 3;
            case CRITICAL: return 4;
            default: return 1;
        }
    }
    
    /**
     * 获取概率评分
     */
    private int getProbabilityScore(Probability probability) {
        switch (probability) {
            case RARE: return 1;
            case OCCASIONAL: return 2;
            case FREQUENT: return 3;
            case CERTAIN: return 4;
            default: return 1;
        }
    }
    
    /**
     * 实施变更
     */
    @Override
    public ChangePointDTO implementChange(Long changeId, Long implementationId, ImplementationDTO dto) {
        log.info("实施变更,变化点ID: {}, 实施ID: {}", changeId, implementationId);
        
        // 1. 查询变化点
        ChangePoint changePoint = getChangePointById(changeId);
        
        // 2. 验证状态
        if (changePoint.getChangeStatus() != ChangeStatus.APPROVED) {
            throw new BusinessException("只有已批准的变化点才能实施");
        }
        
        // 3. 查询实施记录
        ImplementationRecord record = getImplementationRecordById(implementationId);
        
        // 4. 更新实施记录
        BeanUtils.copyProperties(dto, record);
        record.setImplementationStatus(ImplementationStatus.COMPLETED);
        record.setActualDate(dto.getActualDate() != null ? dto.getActualDate() : LocalDate.now());
        record.setUpdatedTime(LocalDateTime.now());
        
        // 5. 检查所有实施步骤是否都完成
        List<ImplementationRecord> allRecords = changePoint.getImplementationRecords();
        boolean allCompleted = allRecords.stream()
            .allMatch(r -> r.getImplementationStatus() == ImplementationStatus.COMPLETED);
        
        if (allCompleted) {
            // 所有实施步骤完成,更新变化点状态
            changePoint.setChangeStatus(ChangeStatus.IMPLEMENTED);
            changePoint.setImplementedDate(LocalDateTime.now());
            
            // 发送验证通知
            sendVerificationNotification(changePoint);
        }
        
        changePointRepository.save(changePoint);
        implementationRecordRepository.save(record);
        
        log.info("变更实施完成,变化点编号: {}", changePoint.getChangeNumber());
        
        return convertToDTO(changePoint);
    }
    
    /**
     * 质量验证
     */
    @Override
    public ChangePointDTO verifyChange(Long changeId, VerificationDTO dto) {
        log.info("质量验证,变化点ID: {}, 验证结果: {}", changeId, dto.getVerificationResult());
        
        // 1. 查询变化点
        ChangePoint changePoint = getChangePointById(changeId);
        
        // 2. 验证状态
        if (changePoint.getChangeStatus() != ChangeStatus.IMPLEMENTED) {
            throw new BusinessException("只有已实施的变化点才能验证");
        }
        
        // 3. 创建验证记录
        VerificationRecord record = new VerificationRecord();
        BeanUtils.copyProperties(dto, record);
        record.setChangeId(changeId);
        record.setVerificationDate(LocalDateTime.now());
        record.setInspectorId(SecurityUtils.getCurrentUserId());
        record.setCreatedTime(LocalDateTime.now());
        
        verificationRecordRepository.save(record);
        
        // 4. 根据验证结果处理
        if (VerificationResult.PASS == dto.getVerificationResult()) {
            // 验证通过,关闭变更
            changePoint.setVerificationResult(VerificationResult.PASS);
            changePoint.setVerifiedDate(LocalDateTime.now());
            changePoint.setEffectivenessDate(LocalDate.now());
            
            log.info("变更验证通过,自动关闭变更,变化点编号: {}", changePoint.getChangeNumber());
            
        } else if (VerificationResult.FAIL == dto.getVerificationResult()) {
            // 验证失败,启动CAPA流程
            changePoint.setVerificationResult(VerificationResult.FAIL);
            changePoint.setVerifiedDate(LocalDateTime.now());
            
            log.info("变更验证失败,启动CAPA流程,变化点编号: {}", changePoint.getChangeNumber());
            
            // 创建CAPA
            createCAPAForFailedVerification(changePoint, dto);
            
        } else {
            // 有条件通过
            changePoint.setVerificationResult(VerificationResult.CONDITIONAL_PASS);
            changePoint.setVerifiedDate(LocalDateTime.now());
            changePoint.setEffectivenessDate(LocalDate.now());
            
            log.info("变更有条件通过,需要附加验证,变化点编号: {}", changePoint.getChangeNumber());
        }
        
        changePointRepository.save(changePoint);
        
        return convertToDTO(changePoint);
    }
    
    /**
     * 为验证失败的变化点创建CAPA
     */
    private void createCAPAForFailedVerification(ChangePoint changePoint, VerificationDTO dto) {
        log.info("为验证失败的变化点创建CAPA,变化点编号: {}", changePoint.getChangeNumber());
        
        // 构建CAPA创建DTO
        CAPACreateDTO capaDto = new CAPACreateDTO();
        capaDto.setCapaType(CAPAType.CORRECTIVE);
        capaDto.setSourceType(CAPASourceType.CHANGE_POINT_VERIFICATION);
        capaDto.setSourceId(changePoint.getChangeId());
        capaDto.setSourceNumber(changePoint.getChangeNumber());
        capaDto.setProblemDescription(
            String.format("变化点验证失败: %s, 验证结果: %s", 
                changePoint.getChangeTitle(), dto.getVerificationResult())
        );
        capaDto.setProblemCategory("CHANGE_VERIFICATION");
        capaDto.setSeverity(changePoint.getRiskLevel().name());
        capaDto.setPriority("HIGH");
        
        // 调用CAPA服务创建CAPA
        capaService.createCAPA(capaDto);
        
        // 发送CAPA创建通知
        sendCAPACreatedNotification(changePoint);
    }
    
    // ... 其他方法实现
}
\`\`\`

### 1.4 风险评估算法

\`\`\`java
/**
 * 风险评估服务
 */
@Service
@Slf4j
public class RiskAssessmentServiceImpl implements RiskAssessmentService {
    
    /**
     * 计算整体风险等级
     */
    @Override
    public RiskLevel calculateOverallRiskLevel(Long changeId) {
        log.info("计算整体风险等级,变化点ID: {}", changeId);
        
        // 1. 获取所有影响分析
        List<ImpactAnalysis> analyses = impactAnalysisRepository.findByChangeId(changeId);
        
        if (analyses.isEmpty()) {
            return RiskLevel.LOW;
        }
        
        // 2. 计算加权风险评分
        double totalWeightedScore = 0.0;
        double totalWeight = 0.0;
        
        for (ImpactAnalysis analysis : analyses) {
            double weight = getImpactTypeWeight(analysis.getImpactType());
            totalWeightedScore += analysis.getRiskScore() * weight;
            totalWeight += weight;
        }
        
        double averageScore = totalWeight / totalWeight;
        
        // 3. 根据评分确定风险等级
        RiskLevel riskLevel = determineRiskLevel(averageScore);
        
        log.info("整体风险等级计算完成,变化点ID: {}, 风险等级: {}, 平均评分: {}", 
            changeId, riskLevel, averageScore);
        
        return riskLevel;
    }
    
    /**
     * 获取影响类型权重
     */
    private double getImpactTypeWeight(ImpactType impactType) {
        switch (impactType) {
            case QUALITY: return 3.0;      // 质量影响权重最高
            case SAFETY: return 4.0;       // 安全影响权重更高
            case COST: return 2.0;
            case DELIVERY: return 1.5;
            case ENVIRONMENT: return 2.5;
            default: return 1.0;
        }
    }
    
    /**
     * 根据评分确定风险等级
     */
    private RiskLevel determineRiskLevel(double score) {
        if (score >= 16) {
            return RiskLevel.CRITICAL;   // 16分以上 (4×4)
        } else if (score >= 9) {
            return RiskLevel.HIGH;        // 9-15分
        } else if (score >= 4) {
            return RiskLevel.MEDIUM;      // 4-8分
        } else {
            return RiskLevel.LOW;         // 1-3分
        }
    }
    
    /**
     * 风险矩阵可视化
     */
    public RiskMatrixVisualizer createRiskMatrix(Long changeId) {
        List<ImpactAnalysis> analyses = impactAnalysisRepository.findByChangeId(changeId);
        
        RiskMatrixVisualizer matrix = new RiskMatrixVisualizer();
        
        for (ImpactAnalysis analysis : analyses) {
            int severity = getSeverityScore(analysis.getSeverity());
            int probability = getProbabilityScore(analysis.getProbability());
            
            matrix.addPoint(
                analysis.getImpactType(),
                severity,
                probability,
                analysis.getRiskScore()
            );
        }
        
        return matrix;
    }
}
\`\`\`

### 1.5 审批工作流引擎

\`\`\`java
/**
 * 审批工作流服务
 */
@Service
@Slf4j
public class ApprovalWorkflowServiceImpl implements ApprovalWorkflowService {
    
    // 变更类别对应的审批路径
    private static final Map<ChangeCategory, List<String>> APPROVAL_PATHS = Map.of(
        ChangeCategory.MINOR, List.of("DEPT_MANAGER"),
        ChangeCategory.MODERATE, List.of("DEPT_MANAGER", "QUALITY_MANAGER"),
        ChangeCategory.MAJOR, List.of("DEPT_MANAGER", "QUALITY_MANAGER", "DIRECTOR"),
        ChangeCategory.CRITICAL, List.of("DEPT_MANAGER", "QUALITY_MANAGER", "DIRECTOR", "GENERAL_MANAGER")
    );
    
    /**
     * 启动审批流程
     */
    @Override
    public void startApprovalProcess(ChangePoint changePoint) {
        log.info("启动审批流程,变化点编号: {}, 变更类别: {}", 
            changePoint.getChangeNumber(), changePoint.getChangeCategory());
        
        // 1. 获取审批路径
        List<String> approvalPath = APPROVAL_PATHS.get(changePoint.getChangeCategory());
        if (approvalPath == null) {
            approvalPath = APPROVAL_PATHS.get(ChangeCategory.MODERATE);
        }
        
        // 2. 创建第一条审批记录
        ApprovalRecord firstRecord = createFirstApprovalRecord(changePoint, approvalPath.get(0));
        approvalRecordRepository.save(firstRecord);
        
        // 3. 发送审批通知
        sendApprovalNotification(changePoint, firstRecord);
        
        log.info("审批流程启动成功,首节点: {}", firstRecord.getApprovalNode());
    }
    
    /**
     * 创建第一条审批记录
     */
    private ApprovalRecord createFirstApprovalRecord(ChangePoint changePoint, String firstNode) {
        ApprovalRecord record = new ApprovalRecord();
        record.setChangeId(changePoint.getChangeId());
        record.setApprovalNode(firstNode);
        record.setApprovalRole(getRoleForNode(firstNode));
        record.setApprovalStatus(ApprovalStatus.PENDING);
        record.setApprovalLevel(1);
        record.setCreatedTime(LocalDateTime.now());
        return record;
    }
    
    /**
     * 移动到下一个审批节点
     */
    @Override
    public void moveToNextNode(ChangePoint changePoint) {
        log.info("移动到下一个审批节点,变化点编号: {}", changePoint.getChangeNumber());
        
        // 1. 获取审批路径
        List<String> approvalPath = APPROVAL_PATHS.get(changePoint.getChangeCategory());
        
        // 2. 获取当前审批记录
        List<ApprovalRecord> records = approvalRecordRepository
            .findByChangeIdOrderByApprovalLevelAsc(changePoint.getChangeId());
        
        int currentLevel = records.size();
        
        // 3. 检查是否还有下一个节点
        if (currentLevel >= approvalPath.size()) {
            throw new BusinessException("没有更多的审批节点");
        }
        
        // 4. 创建下一节点审批记录
        ApprovalRecord nextRecord = new ApprovalRecord();
        nextRecord.setChangeId(changePoint.getChangeId());
        nextRecord.setApprovalNode(approvalPath.get(currentLevel));
        nextRecord.setApprovalRole(getRoleForNode(approvalPath.get(currentLevel)));
        nextRecord.setApprovalStatus(ApprovalStatus.PENDING);
        nextRecord.setApprovalLevel(currentLevel + 1);
        nextRecord.setCreatedTime(LocalDateTime.now());
        approvalRecordRepository.save(nextRecord);
        
        // 5. 发送审批通知
        sendApprovalNotification(changePoint, nextRecord);
        
        log.info("已移动到下一个审批节点: {}", nextRecord.getApprovalNode());
    }
    
    /**
     * 判断是否为最后一个审批节点
     */
    @Override
    public boolean isLastApprovalNode(Long changeId, String approvalNode) {
        List<String> approvalPath = getApprovalPathForChange(changeId);
        int lastIndex = approvalPath.size() - 1;
        return approvalNode.equals(approvalPath.get(lastIndex));
    }
    
    /**
     * 终止审批流程
     */
    @Override
    public void terminateApprovalProcess(Long changeId) {
        log.info("终止审批流程,变化点ID: {}", changeId);
        
        // 将所有待审批的记录标记为跳过
        List<ApprovalRecord> pendingRecords = approvalRecordRepository
            .findByChangeIdAndApprovalStatus(changeId, ApprovalStatus.PENDING);
        
        for (ApprovalRecord record : pendingRecords) {
            record.setApprovalStatus(ApprovalStatus.SKIPPED);
            record.setApprovalTime(LocalDateTime.now());
            approvalRecordRepository.save(record);
        }
        
        log.info("审批流程已终止,跳过 {} 个待审批节点", pendingRecords.size());
    }
}
\`\`\`

---

## 2. CAPA管理模块详细实现

### 2.1 CAPA业务流程设计

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│  CAPA完整生命周期管理流程                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ CAPA创建 │───▶│ 问题识别  │───▶│ 根本原因  │                   │
│  └──────────┘    └──────────┘    └────┬─────┘                   │
│                                       │                          │
│                          ┌────────────┴────────────┐            │
│                          ▼                         ▼            │
│                   ┌──────────┐              ┌──────────┐          │
│                   │ 5Why分析 │              │ 鱼骨图分析 │          │
│                   └────┬─────┘              └────┬─────┘          │
│                        │                        │                │
│                        └──────────┬─────────────┘                │
│                                   ▼                              │
│                            ┌──────────┐                          │
│                            │ 制定措施  │                          │
│                            └────┬─────┘                          │
│                   ┌────────────┴────────────┐                    │
│                   ▼                         ▼                    │
│            ┌──────────┐              ┌──────────┐               │
│            │ 纠正措施 │              │ 预防措施 │               │
│            └────┬─────┘              └────┬─────┘               │
│                 │                        │                      │
│                 └──────────┬─────────────┘                      │
│                            ▼                                     │
│                      ┌──────────┐                                │
│                      │ 任务分配  │                                │
│                      └────┬─────┘                                │
│                           ▼                                       │
│                     ┌──────────┐                                 │
│                     │ 措施实施  │                                 │
│                     └────┬─────┘                                 │
│                          │                                        │
│                   ┌──────┴──────┐                               │
│                   ▼             ▼                               │
│            ┌──────────┐   ┌──────────┐                         │
│            │ 实施完成  │   │ 实施失败  │                         │
│            └────┬─────┘   └────┬─────┘                         │
│                 │              │                                 │
│                 ▼              ▼                                 │
│           ┌──────────┐   ┌──────────┐                          │
│           │ 效果验证  │   │ CAPA重启  │                          │
│           └────┬─────┘   └──────────┘                          │
│                │                                                │
│         ┌──────┴──────┐                                          │
│         ▼             ▼                                          │
│  ┌──────────┐  ┌──────────┐                                     │
│  │ 验证通过  │  │ 验证失败  │                                     │
│  └────┬─────┘  └────┬─────┘                                     │
│       │             │                                           │
│       ▼             ▼                                           │
│  ┌──────────┐  ┌──────────┐                                    │
│  │ CAPA关闭  │  │ 再次CAPA │                                    │
│  └──────────┘  └──────────┘                                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 2.2 5Why分析实现

\`\`\`java
/**
 * 5Why分析服务
 */
@Service
@Slf4j
public class FiveWhyAnalysisServiceImpl implements FiveWhyAnalysisService {
    
    /**
     * 创建5Why分析
     */
    @Override
    public FiveWhyAnalysisDTO createAnalysis(Long capaId, FiveWhyAnalysisCreateDTO dto) {
        log.info("创建5Why分析,CAPA ID: {}", capaId);
        
        // 1. 验证CAPA状态
        CAPA capa = getCAPAById(capaId);
        validateCAPAStatusForAnalysis(capa);
        
        // 2. 验证5Why数据
        validateFiveWhyData(dto);
        
        // 3. 保存5Why分析
        List<FiveWhyAnalysis> analyses = new ArrayList<>();
        for (FiveWhyItemDTO item : dto.getAnalyses()) {
            FiveWhyAnalysis analysis = new FiveWhyAnalysis();
            analysis.setCapaId(capaId);
            analysis.setAnalysisOrder(item.getAnalysisOrder());
            analysis.setQuestion(item.getQuestion());
            analysis.setAnswer(item.getAnswer());
            analysis.setVerificationMethod(item.getVerificationMethod());
            analysis.setIsRootCause(item.getIsRootCause());
            analysis.setCreatedTime(LocalDateTime.now());
            analyses.add(analysis);
        }
        
        fiveWhyAnalysisRepository.saveAll(analyses);
        
        // 4. 检查是否识别出根本原因
        boolean rootCauseIdentified = analyses.stream()
            .anyMatch(FiveWhyAnalysis::getIsRootCause);
        
        if (rootCauseIdentified) {
            // 更新CAPA根本原因
            updateCAPARootCause(capa, analyses);
        }
        
        log.info("5Why分析创建成功,CAPA ID: {}, 是否识别根本原因: {}", 
            capaId, rootCauseIdentified);
        
        return convertToDTO(analyses);
    }
    
    /**
     * 验证5Why数据
     */
    private void validateFiveWhyData(FiveWhyAnalysisCreateDTO dto) {
        List<FiveWhyItemDTO> analyses = dto.getAnalyses();
        
        // 验证至少3个Why
        if (analyses.size() < 3) {
            throw new BusinessException("5Why分析至少需要3个Why");
        }
        
        // 验证顺序
        Set<Integer> orders = analyses.stream()
            .map(FiveWhyItemDTO::getAnalysisOrder)
            .collect(Collectors.toSet());
        
        if (orders.size() != analyses.size()) {
            throw new BusinessException("5Why分析顺序不能重复");
        }
        
        // 验证问题与答案的连贯性
        validateLogicalConnection(analyses);
    }
    
    /**
     * 验证逻辑连贯性
     */
    private void validateLogicalConnection(List<FiveWhyItemDTO> analyses) {
        analyses.sort(Comparator.comparing(FiveWhyItemDTO::getAnalysisOrder));
        
        for (int i = 0; i < analyses.size() - 1; i++) {
            String currentAnswer = analyses.get(i).getAnswer();
            String nextQuestion = analyses.get(i + 1).getQuestion();
            
            // 检查下一个问题是否基于上一个答案
            if (!isQuestionBasedOnAnswer(currentAnswer, nextQuestion)) {
                log.warn("5Why分析逻辑不连贯: Answer[{}]: {}, Question[{}]: {}", 
                    i, currentAnswer, i + 1, nextQuestion);
                // 不强制要求,只是警告
            }
        }
    }
    
    /**
     * 智能根本原因识别助手
     */
    @Override
    public RootCauseSuggestion suggestRootCause(Long capaId) {
        log.info("智能根本原因识别,CAPA ID: {}", capaId);
        
        CAPA capa = getCAPAById(capaId);
        
        RootCauseSuggestion suggestion = new RootCauseSuggestion();
        
        // 1. 基于问题类别推荐
        List<String> categoryBasedSuggestions = suggestByProblemCategory(capa);
        suggestion.setCategoryBasedSuggestions(categoryBasedSuggestions);
        
        // 2. 基于历史数据推荐
        List<String> historyBasedSuggestions = suggestByHistory(capa);
        suggestion.setHistoryBasedSuggestions(historyBasedSuggestions);
        
        // 3. 基于5Why分析生成
        List<FiveWhyAnalysis> analyses = fiveWhyAnalysisRepository.findByCapaId(capaId);
        if (!analyses.isEmpty()) {
            List<String> fiveWhyBasedSuggestions = generateFromFiveWhy(analyses);
            suggestion.setFiveWhyBasedSuggestions(fiveWhyBasedSuggestions);
        }
        
        // 4. 综合推荐
        String comprehensiveSuggestion = generateComprehensiveSuggestion(suggestion);
        suggestion.setComprehensiveSuggestion(comprehensiveSuggestion);
        
        return suggestion;
    }
    
    /**
     * 基于历史数据推荐
     */
    private List<String> suggestByHistory(CAPA capa) {
        List<String> suggestions = new ArrayList<>();
        
        // 查询相似CAPA
        List<CAPA> similarCAPAs = capaRepository
            .findByProblemCategoryAndCapaStatus(
                capa.getProblemCategory(), 
                CAPAStatus.CLOSED
            );
        
        if (similarCAPAs.isEmpty()) {
            return suggestions;
        }
        
        // 分析相似CAPA的根本原因
        Map<String, Long> rootCauseFrequency = similarCAPAs.stream()
            .flatMap(c -> fiveWhyAnalysisRepository
                .findByCapaId(c.getCapaId()).stream()
                .filter(FiveWhyAnalysis::getIsRootCause))
            .collect(Collectors.groupingBy(
                FiveWhyAnalysis::getAnswer,
                Collectors.counting()
            ));
        
        // 按频率排序
        rootCauseFrequency.entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .limit(5)
            .forEach(entry -> {
                suggestions.add(String.format("历史相似案例: %s (出现%d次)", 
                    entry.getKey(), entry.getValue()));
            });
        
        return suggestions;
    }
}
\`\`\`

### 2.3 鱼骨图分析实现

\`\`\`java
/**
 * 鱼骨图分析服务
 */
@Service
@Slf4j
public class FishboneAnalysisServiceImpl implements FishboneAnalysisService {
    
    // 鱼骨图6大类
    private static final List<String> FISHBONE_CATEGORIES = List.of(
        "MAN",      // 人
        "MACHINE",  // 机
        "MATERIAL", // 料
        "METHOD",   // 法
        "MEASUREMENT", // 测
        "ENVIRONMENT"  // 环
    );
    
    /**
     * 创建鱼骨图分析
     */
    @Override
    public FishboneAnalysisDTO createAnalysis(Long capaId, FishboneAnalysisCreateDTO dto) {
        log.info("创建鱼骨图分析,CAPA ID: {}", capaId);
        
        // 1. 验证CAPA状态
        CAPA capa = getCAPAById(capaId);
        validateCAPAStatusForAnalysis(capa);
        
        // 2. 验证鱼骨图类别
        validateFishboneCategories(dto.getFactors());
        
        // 3. 保存鱼骨图分析
        List<FishboneAnalysis> analyses = new ArrayList<>();
        for (FishboneFactorDTO factor : dto.getFactors()) {
            FishboneAnalysis analysis = new FishboneAnalysis();
            analysis.setCapaId(capaId);
            analysis.setCategory(factor.getCategory());
            analysis.setFactor(factor.getFactor());
            analysis.setSubFactors(factor.getSubFactors());
            analysis.setIsContributingFactor(factor.getIsContributingFactor());
            analysis.setCreatedTime(LocalDateTime.now());
            analyses.add(analysis);
        }
        
        fishboneAnalysisRepository.saveAll(analyses);
        
        log.info("鱼骨图分析创建成功,CAPA ID: {}, 因素数量: {}", 
            capaId, analyses.size());
        
        return convertToDTO(analyses);
    }
    
    /**
     * 生成鱼骨图可视化数据
     */
    @Override
    public FishboneVisualizationDTO generateVisualization(Long capaId) {
        log.info("生成鱼骨图可视化数据,CAPA ID: {}", capaId);
        
        List<FishboneAnalysis> analyses = fishboneAnalysisRepository.findByCapaId(capaId);
        
        FishboneVisualizationDTO visualization = new FishboneVisualizationDTO();
        
        // 按类别分组
        Map<String, List<FishboneAnalysis>> groupedByCategory = analyses.stream()
            .collect(Collectors.groupingBy(FishboneAnalysis::getCategory));
        
        // 构建可视化数据
        List<FishboneBranchDTO> branches = new ArrayList<>();
        for (String category : FISHBONE_CATEGORIES) {
            List<FishboneAnalysis> categoryAnalyses = groupedByCategory.getOrDefault(category, List.of());
            
            if (!categoryAnalyses.isEmpty()) {
                FishboneBranchDTO branch = new FishboneBranchDTO();
                branch.setCategory(category);
                branch.setCategoryName(getCategoryDisplayName(category));
                branch.setFactorCount(categoryAnalyses.size());
                branch.setContributingFactorCount(
                    (int) categoryAnalyses.stream()
                        .filter(FishboneAnalysis::getIsContributingFactor)
                        .count()
                );
                branch.setFactors(categoryAnalyses.stream()
                    .map(this::convertToFactorDTO)
                    .collect(Collectors.toList())
                );
                branches.add(branch);
            }
        }
        
        visualization.setBranches(branches);
        visualization.setTotalFactorCount(analyses.size());
        visualization.setContributingFactorCount(
            (int) analyses.stream()
                .filter(FishboneAnalysis::getIsContributingFactor)
                .count()
        );
        
        return visualization;
    }
    
    /**
     * 鱼骨图因素自动识别
     */
    @Override
    public List<FishboneFactorSuggestion> autoIdentifyFactors(Long capaId) {
        log.info("鱼骨图因素自动识别,CAPA ID: {}", capaId);
        
        CAPA capa = getCAPAById(capaId);
        List<FishboneFactorSuggestion> suggestions = new ArrayList<>();
        
        // 1. 基于问题描述识别
        List<FishboneFactorSuggestion> fromDescription = 
            identifyFactorsFromDescription(capa.getProblemDescription());
        suggestions.addAll(fromDescription);
        
        // 2. 基于历史案例识别
        List<FishboneFactorSuggestion> fromHistory = 
            identifyFactorsFromHistory(capa.getProblemCategory());
        suggestions.addAll(fromHistory);
        
        // 3. 去重和排序
        suggestions = deduplicateAndSort(suggestions);
        
        return suggestions;
    }
    
    /**
     * 基于问题描述识别因素
     */
    private List<FishboneFactorSuggestion> identifyFactorsFromDescription(String description) {
        List<FishboneFactorSuggestion> suggestions = new ArrayList<>();
        
        // 关键词映射
        Map<String, List<String>> keywordMapping = Map.of(
            "MAN", List.of("操作员", "员工", "培训", "技能", "经验", "疲劳"),
            "MACHINE", List.of("设备", "机器", "故障", "维护", "保养", "老化"),
            "MATERIAL", List.of("材料", "物料", "原料", "质量", "规格", "批次"),
            "METHOD", List.of("工艺", "流程", "方法", "标准", "作业", "程序"),
            "MEASUREMENT", List.of("测量", "检测", "检验", "仪器", "工具", "标准"),
            "ENVIRONMENT", List.of("温度", "湿度", "环境", "照明", "噪音", "清洁")
        );
        
        // 关键词匹配
        for (Map.Entry<String, List<String>> entry : keywordMapping.entrySet()) {
            String category = entry.getKey();
            List<String> keywords = entry.getValue();
            
            for (String keyword : keywords) {
                if (description.contains(keyword)) {
                    FishboneFactorSuggestion suggestion = new FishboneFactorSuggestion();
                    suggestion.setCategory(category);
                    suggestion.setFactor(keyword + "相关因素");
                    suggestion.setSource("问题描述识别");
                    suggestion.setConfidence(0.7);
                    suggestions.add(suggestion);
                }
            }
        }
        
        return suggestions;
    }
}
\`\`\`

---

## 3. QRQC快速响应模块详细实现

### 3.1 QRQC实时监控与告警

\`\`\`java
/**
 * QRQC监控服务
 */
@Service
@Slf4j
public class QRQCMonitoringServiceImpl implements QRQCMonitoringService {
    
    /**
     * 24小时响应监控
     */
    @Scheduled(fixedDelay = 60000) // 每分钟执行
    public void monitor24HourResponse() {
        log.debug("开始监控24小时响应");
        
        // 1. 查询未完成24小时响应的事件
        List<QRQCEvent> events = qrqcEventRepository
            .findByQrqcStatusAndDetectionTimeAfter(
                QRQCStatus.OPEN, 
                LocalDateTime.now().minusHours(24)
            );
        
        for (QRQCEvent event : events) {
            monitorEvent(event);
        }
        
        log.debug("24小时响应监控完成,监控事件数: {}", events.size());
    }
    
    /**
     * 监控单个事件
     */
    private void monitorEvent(QRQCEvent event) {
        LocalDateTime detectionTime = event.getDetectionTime();
        long hoursElapsed = ChronoUnit.HOURS.between(detectionTime, LocalDateTime.now());
        
        // 检查各里程碑
        QRQC24hTracking tracking = get24hTracking(event.getEventId());
        
        // 1小时报告检查
        if (hoursElapsed >= 1 && !isMilestoneAchieved(tracking, "REPORTING_1H")) {
            sendWarningNotification(event, "1小时内未报告");
        }
        
        // 4小时团队组建检查
        if (hoursElapsed >= 4 && !isMilestoneAchieved(tracking, "TEAM_ASSEMBLY_4H")) {
            sendUrgentNotification(event, "4小时内未组建团队");
        }
        
        // 12小时调查检查
        if (hoursElapsed >= 12 && !isMilestoneAchieved(tracking, "INVESTIGATION_12H")) {
            sendUrgentNotification(event, "12小时内未完成调查");
        }
        
        // 24小时围堵检查
        if (hoursElapsed >= 24 && !isMilestoneAchieved(tracking, "CONTAINMENT_24H")) {
            sendCriticalNotification(event, "24小时内未完成围堵");
        }
    }
    
    /**
     * 质量异常自动识别
     */
    @Override
    public void detectQualityAnomalies() {
        log.debug("开始质量异常自动识别");
        
        // 1. 从InfluxDB查询SPC数据
        List<SPCControlPoint> recentPoints = queryRecentSPCPoints();
        
        // 2. 检测异常点
        for (SPCControlPoint point : recentPoints) {
            if (isAnomaly(point)) {
                // 创建QRQC事件
                createAutoQRQCEvent(point);
            }
        }
        
        log.debug("质量异常自动识别完成");
    }
    
    /**
     * 检测是否为异常点
     */
    private boolean isAnomaly(SPCControlPoint point) {
        // 1. 超出控制限
        if (isBeyondControlLimits(point)) {
            return true;
        }
        
        // 2. 连续异常模式检测
        if (hasPatternViolation(point)) {
            return true;
        }
        
        // 3. 趋势检测
        if (hasTrendViolation(point)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * 超出控制限检测
     */
    private boolean isBeyondControlLimits(SPCControlPoint point) {
        double value = point.getMeasurementValue();
        double ucl = point.getUcl();
        double lcl = point.getLcl();
        
        if (point.getOutOfControl()) {
            return true; // 已标记为超控
        }
        
        // 检查是否超出3σ控制限
        return value > ucl || value < lcl;
    }
    
    /**
     * 连续异常模式检测
     */
    private boolean hasPatternViolation(SPCControlPoint point) {
        // 1. 连续6点递增或递减
        if (hasConsecutiveTrend(point, 6)) {
            return true;
        }
        
        // 2. 连续9点在中心线同一侧
        if (hasConsecutiveSide(point, 9)) {
            return true;
        }
        
        // 3. 14点交替上下
        if (hasAlternatingPattern(point, 14)) {
            return true;
        }
        
        // 4. 3点中有2点在A区
        if (hasTwoOfThreeInZoneA(point)) {
            return true;
        }
        
        // 5. 5点中有4点在B区
        if (hasFourOfFiveInZoneB(point)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * 连续趋势检测
     */
    private boolean hasConsecutiveTrend(SPCControlPoint point, int count) {
        // 查询最近的控制点
        List<SPCControlPoint> recentPoints = spcControlPointRepository
            .findByCharacteristicIdAndTimestampBeforeOrderByTimestampDesc(
                point.getCharacteristicId(),
                point.getTimestamp()
            )
            .stream()
            .limit(count)
            .collect(Collectors.toList());
        
        if (recentPoints.size() < count) {
            return false;
        }
        
        // 检查是否全部递增或递减
        boolean increasing = true;
        boolean decreasing = true;
        
        for (int i = 0; i < count - 1; i++) {
            double current = recentPoints.get(i).getMeasurementValue();
            double next = recentPoints.get(i + 1).getMeasurementValue();
            
            if (current <= next) {
                decreasing = false;
            }
            if (current >= next) {
                increasing = false;
            }
        }
        
        return increasing || decreasing;
    }
    
    /**
     * 创建自动QRQC事件
     */
    private void createAutoQRQCEvent(SPCControlPoint point) {
        log.info("创建自动QRQC事件,控制点ID: {}", point.getControlPointId());
        
        QRQCCreateDTO dto = new QRQCCreateDTO();
        dto.setEventType("QUALITY_ANOMALY");
        dto.setSeverity(determineSeverity(point));
        dto.setDetectionTime(LocalDateTime.now());
        dto.setDetectionLocation(point.getProcessStep());
        dto.setDetectionPersonId(getAutoDetectionUserId());
        dto.setEventDescription(buildAutoDetectionDescription(point));
        dto.setAffectedProduct(point.getPartNumber());
        dto.setWorkOrderId(point.getWorkOrderId());
        dto.setProcessStep(point.getProcessStep());
        
        // 创建事件
        qrqcService.createEvent(dto);
        
        log.info("自动QRQC事件创建成功");
    }
}
\`\`\`

### 3.2 QRQC团队智能组建

\`\`\`java
/**
 * QRQC团队组建智能推荐服务
 */
@Service
@Slf4j
public class QRQCTeamRecommendationServiceImpl implements QRQCTeamRecommendationService {
    
    /**
     * 推荐QRQC团队成员
     */
    @Override
    public TeamRecommendation recommendTeam(Long eventId) {
        log.info("推荐QRQC团队成员,事件ID: {}", eventId);
        
        QRQCEvent event = getEventById(eventId);
        TeamRecommendation recommendation = new TeamRecommendation();
        
        // 1. 推荐团队负责人
        User leader = recommendLeader(event);
        recommendation.setLeader(convertToMemberDTO(leader, "LEADER", "团队负责人"));
        
        // 2. 推荐质量工程师
        List<User> qualityEngineers = recommendQualityEngineers(event);
        recommendation.setQualityMembers(
            qualityEngineers.stream()
                .limit(2)
                .map(u -> convertToMemberDTO(u, "QUALITY", "质量分析"))
                .collect(Collectors.toList())
        );
        
        // 3. 推荐工艺工程师
        List<User> processEngineers = recommendProcessEngineers(event);
        recommendation.setEngineeringMembers(
            processEngineers.stream()
                .limit(2)
                .map(u -> convertToMemberDTO(u, "ENGINEERING", "工艺支持"))
                .collect(Collectors.toList())
        );
        
        // 4. 推荐生产代表
        List<User> productionRepresentatives = recommendProductionRepresentatives(event);
        recommendation.setProductionMembers(
            productionRepresentatives.stream()
                .limit(2)
                .map(u -> convertToMemberDTO(u, "PRODUCTION", "生产协调"))
                .collect(Collectors.toList())
        );
        
        // 5. 推荐设备工程师 (如需要)
        if (requiresMaintenanceEngineer(event)) {
            User maintenanceEngineer = recommendMaintenanceEngineer(event);
            recommendation.setMaintenanceMember(
                convertToMemberDTO(maintenanceEngineer, "MAINTENANCE", "设备支持")
            );
        }
        
        return recommendation;
    }
    
    /**
     * 推荐团队负责人
     */
    private User recommendLeader(QRQCEvent event) {
        // 1. 优先选择质量经理
        User qualityManager = findUserByRoleAndDepartment(
            "QUALITY_MANAGER", 
            event.getDetectionDepartmentId()
        );
        if (qualityManager != null) {
            return qualityManager;
        }
        
        // 2. 选择质量工程师
        User qualityEngineer = findUserByRoleAndDepartment(
            "QUALITY_ENGINEER", 
            event.getDetectionDepartmentId()
        );
        if (qualityEngineer != null) {
            return qualityEngineer;
        }
        
        // 3. 选择部门负责人
        return findDepartmentHead(event.getDetectionDepartmentId());
    }
    
    /**
     * 推荐质量工程师
     */
    private List<User> recommendQualityEngineers(QRQCEvent event) {
        List<User> engineers = new ArrayList<>();
        
        // 1. 基于问题类型推荐
        engineers.addAll(findEngineersByProblemType(event.getEventType()));
        
        // 2. 基于历史经验推荐
        engineers.addAll(findEngineersBySimilarHistory(event));
        
        // 3. 基于当前工作负荷推荐
        engineers = sortByWorkload(engineers);
        
        return engineers;
    }
    
    /**
     * 基于历史相似案例推荐
     */
    private List<User> findEngineersBySimilarHistory(QRQCEvent event) {
        List<User> engineers = new ArrayList<>();
        
        // 查询相似QRQC事件
        List<QRQCEvent> similarEvents = qrqcEventRepository
            .findByEventTypeAndProcessStep(
                event.getEventType(),
                event.getProcessStep()
            );
        
        // 统计参与过的工程师
        Map<Long, Long> engineerFrequency = similarEvents.stream()
            .flatMap(e -> qrqcTeamMemberRepository.findByTeamId(e.getTeamId()).stream())
            .filter(m -> "QUALITY".equals(m.getRole()))
            .collect(Collectors.groupingBy(
                QRQCTeamMember::getUserId,
                Collectors.counting()
            ));
        
        // 按参与频率排序
        engineerFrequency.entrySet().stream()
            .sorted(Map.Entry.<Long, Long>comparingByValue().reversed())
            .limit(3)
            .forEach(entry -> {
                User engineer = userRepository.findById(entry.getKey()).orElse(null);
                if (engineer != null) {
                    engineers.add(engineer);
                }
            });
        
        return engineers;
    }
    
    /**
     * 按工作负荷排序
     */
    private List<User> sortByWorkload(List<User> users) {
        // 获取每个用户的当前待处理任务数
        Map<Long, Integer> taskCountMap = getCurrentTaskCounts(users);
        
        return users.stream()
            .sorted(Comparator.comparing(u -> taskCountMap.getOrDefault(u.getUserId(), 0)))
            .collect(Collectors.toList());
    }
    
    /**
     * 获取当前任务数
     */
    private Map<Long, Integer> getCurrentTaskCounts(List<User> users) {
        Map<Long, Integer> taskCountMap = new HashMap<>();
        
        for (User user : users) {
            // 查询用户当前活跃的QRQC任务
            long activeTaskCount = qrqcEventRepository
                .findByTeamLeaderIdAndQrqcStatusIn(
                    user.getUserId(),
                    List.of(QRQCStatus.OPEN, QRQCStatus.CONTAINED, QRQCStatus.INVESTIGATING)
                )
                .size();
            
            taskCountMap.put(user.getUserId(), (int) activeTaskCount);
        }
        
        return taskCountMap;
    }
}
\`\`\`

---

## 4. 集成与同步机制

### 4.1 变化点与MES系统集成

\`\`\`java
/**
 * 变化点-MES集成服务
 */
@Service
@Slf4j
public class ChangePointMESIntegrationServiceImpl implements ChangePointMESIntegrationService {
    
    @Autowired
    private MesClient mesClient;
    
    /**
     * 变更实施时通知MES
     */
    @EventListener
    public void onChangeImplemented(ChangeImplementedEvent event) {
        log.info("收到变更实施事件,变化点ID: {}", event.getChangeId());
        
        try {
            ChangePoint changePoint = getChangePointById(event.getChangeId());
            
            // 1. 构建MES通知数据
            MESChangeNotificationDTO mesDto = new MESChangeNotificationDTO();
            mesDto.setChangeType(changePoint.getChangeType().name());
            mesDto.setChangeNumber(changePoint.getChangeNumber());
            mesDto.setChangeDescription(changePoint.getChangeDescription());
            mesDto.setImplementedDate(changePoint.getImplementedDate());
            
            // 2. 关联影响的生产线
            List<String> affectedProductionLines = extractProductionLines(changePoint);
            mesDto.setAffectedProductionLines(affectedProductionLines);
            
            // 3. 关联影响的工序列表
            List<String> affectedProcesses = extractProcesses(changePoint);
            mesDto.setAffectedProcesses(affectedProcesses);
            
            // 4. 调用MES接口
            MesResponse response = mesClient.notifyChange(mesDto);
            
            if (response.isSuccess()) {
                log.info("MES通知成功,变化点编号: {}", changePoint.getChangeNumber());
                
                // 5. 记录集成日志
                saveIntegrationLog(changePoint, mesDto, response, true);
            } else {
                log.error("MES通知失败,变化点编号: {}, 错误: {}", 
                    changePoint.getChangeNumber(), response.getErrorMessage());
                
                // 6. 记录失败日志
                saveIntegrationLog(changePoint, mesDto, response, false);
                
                // 7. 重试机制
                retryMESNotification(changePoint, mesDto);
            }
            
        } catch (Exception e) {
            log.error("MES集成异常,变化点ID: {}", event.getChangeId(), e);
            throw new MESIntegrationException("MES集成失败", e);
        }
    }
    
    /**
     * MES重试通知
     */
    private void retryMESNotification(ChangePoint changePoint, MESChangeNotificationDTO mesDto) {
        log.info("MES通知重试,变化点编号: {}", changePoint.getChangeNumber());
        
        int maxRetries = 3;
        int retryInterval = 5000; // 5秒
        
        for (int i = 1; i <= maxRetries; i++) {
            try {
                Thread.sleep(retryInterval);
                
                MesResponse response = mesClient.notifyChange(mesDto);
                
                if (response.isSuccess()) {
                    log.info("MES通知重试成功,变化点编号: {}, 重试次数: {}", 
                        changePoint.getChangeNumber(), i);
                    return;
                }
                
                log.warn("MES通知重试失败,变化点编号: {}, 重试次数: {}", 
                    changePoint.getChangeNumber(), i);
                
            } catch (Exception e) {
                log.error("MES通知重试异常,变化点编号: {}, 重试次数: {}", 
                    changePoint.getChangeNumber(), i, e);
            }
        }
        
        // 重试全部失败,发送告警
        sendMESIntegrationFailureAlert(changePoint);
    }
    
    /**
     * 从MES接收生产数据
     */
    @Override
    public void receiveProductionData(MESProductionDataDTO mesDto) {
        log.info("从MES接收生产数据,工单ID: {}", mesDto.getWorkOrderId());
        
        try {
            // 1. 验证数据
            validateMESProductionData(mesDto);
            
            // 2. 存储到InfluxDB
            storeProductionDataToInfluxDB(mesDto);
            
            // 3. 关联变化点追溯信息
            if (mesDto.getChangePointId() != null) {
                updateChangePointTraceability(mesDto);
            }
            
            // 4. 实时质量分析
            analyzeProductionQuality(mesDto);
            
            log.info("MES生产数据接收成功");
            
        } catch (Exception e) {
            log.error("MES生产数据接收失败,工单ID: {}", mesDto.getWorkOrderId(), e);
            throw new MESIntegrationException("MES生产数据接收失败", e);
        }
    }
    
    /**
     * 实时质量分析
     */
    private void analyzeProductionQuality(MESProductionDataDTO mesDto) {
        // 1. 获取SPC控制点配置
        List<SPCControlPointConfig> configs = spcControlPointConfigRepository
            .findByProcessStep(mesDto.getProcessStep());
        
        // 2. 分析每个控制点
        for (SPCControlPointConfig config : configs) {
            Double measurementValue = mesDto.getParameters().get(config.getParameterName());
            
            if (measurementValue != null) {
                // 存储SPC数据
                storeSPCData(config, measurementValue, mesDto);
                
                // 检测异常
                if (detectSPCAnomaly(config, measurementValue)) {
                    // 触发质量告警
                    triggerQualityAnomalyAlert(config, measurementValue, mesDto);
                }
            }
        }
    }
}
\`\`\`

---

## 总结

本详细实现规范为舜富QMS系统的核心模块提供了:

1. **变化点管理**: 完整的创建、审批、风险评估、实施、验证流程,包含风险评估算法和审批工作流引擎
2. **CAPA管理**: 5Why分析、鱼骨图分析、措施制定、任务分配、效果验证的完整生命周期
3. **QRQC快速响应**: 24小时响应监控、自动质量异常识别、智能团队组建
4. **系统集成**: 与MES/ERP等外部系统的数据同步和事件通知机制

所有实现遵循Spring Boot微服务架构,采用领域驱动设计(DDD)思想,确保代码的可维护性和可扩展性。
`,re=`# 舜富QMS系统 - 供应商管理模块详细实现规范

## 1. 模块概述

### 1.1 功能定位
供应商管理模块是舜富QMS系统的关键组成部分，负责供应商全生命周期管理、绩效监控和质量评估，确保供应链质量稳定可靠，满足IATF16949:2016对供应链管理的要求。

### 1.2 业务价值
- **供应链质量管理**: 建立完整的供应商质量管理体系
- **绩效可视化**: 量化供应商绩效，支持持续改进
- **风险防控**: 识别和管控供应链质量风险
- **成本优化**: 基于绩效的供应商分级管理
- **协同管理**: 供需双方的质量协同改进

### 1.3 技术架构
- **前端**: Vue.js 3.x + Element Plus + ECharts可视化
- **后端**: Spring Boot 3.x + Spring Security + Spring Data JPA
- **数据库**: PostgreSQL (主业务) + MongoDB (文档) + InfluxDB (时序)
- **消息队列**: RabbitMQ/Kafka
- **报表**: JasperReports + Apache POI
- **监控**: Prometheus + Grafana

## 2. 核心功能详细设计

### 2.1 供应商分类管理

#### 2.1.1 多维度分类体系
\`\`\`java
// 供应商分类实体
@Entity
@Table(name = "qms_supplier_category")
@Data
public class SupplierCategory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String categoryName;
    
    @Column(length = 500)
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private SupplierCategory parent;
    
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<SupplierCategory> children;
    
    @Column(nullable = false)
    private Integer level;
    
    @Column(nullable = false)
    private Integer sortOrder;
    
    @Column(nullable = false)
    private Boolean active = true;
    
    @Column(nullable = false)
    private String categoryType; // MATERIAL, SERVICE, EQUIPMENT, MISC
    
    @Column(nullable = false)
    private String riskLevel; // HIGH, MEDIUM, LOW
}

// 供应商分类管理服务
@Service
@RequiredArgsConstructor
public class SupplierCategoryService {
    
    private final SupplierCategoryRepository categoryRepository;
    
    /**
     * 创建供应商分类
     */
    @Transactional
    public SupplierCategoryDTO createCategory(SupplierCategoryCreateDTO dto) {
        // 验证同级分类名称唯一性
        validateCategoryName(dto.getCategoryName(), dto.getParentId());
        
        SupplierCategory category = SupplierCategory.builder()
            .categoryName(dto.getCategoryName())
            .description(dto.getDescription())
            .parent(dto.getParentId() != null ? 
                categoryRepository.findById(dto.getParentId()).orElse(null) : null)
            .level(dto.getParentId() != null ? 
                getParentLevel(dto.getParentId()) + 1 : 1)
            .sortOrder(dto.getSortOrder())
            .categoryType(dto.getCategoryType())
            .riskLevel(dto.getRiskLevel())
            .active(true)
            .build();
        
        categoryRepository.save(category);
        
        return convertToDTO(category);
    }
    
    /**
     * 获取分类树结构
     */
    public List<CategoryTreeNodeDTO> getCategoryTree() {
        List<SupplierCategory> categories = categoryRepository.findByActiveTrueOrderBySortOrderAsc();
        return buildCategoryTree(categories);
    }
    
    private Integer getParentLevel(Long parentId) {
        SupplierCategory parent = categoryRepository.findById(parentId)
            .orElseThrow(() -> new EntityNotFoundException("Parent category not found"));
        return parent.getLevel();
    }
}
\`\`\`

### 2.2 供应商基本信息管理

#### 2.2.1 供应商核心实体
\`\`\`java
@Entity
@Table(name = "qms_supplier")
@Data
public class Supplier {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String supplierName;
    
    @Column(nullable = false, length = 50)
    private String supplierCode;
    
    @Column(length = 20)
    private String supplierType; // MANUFACTURER, DISTRIBUTOR, SERVICE_PROVIDER
    
    @Column(length = 50)
    private String legalRepresentative;
    
    @Column(length = 100)
    private String registrationNumber;
    
    @Column(length = 200)
    private String address;
    
    @Column(length = 20)
    private String postalCode;
    
    @Column(length = 50)
    private String contactPerson;
    
    @Column(length = 20)
    private String contactPhone;
    
    @Column(length = 100)
    private String contactEmail;
    
    @Column(length = 50)
    private String website;
    
    @Column(nullable = false)
    private String businessScope;
    
    @Column(nullable = false)
    private LocalDateTime establishedDate;
    
    @Column(length = 500)
    private String companyProfile;
    
    @Column(nullable = false)
    private SupplierStatus status; // ACTIVE, INACTIVE, SUSPENDED
    
    @Column(nullable = false)
    private LocalDateTime registrationDate;
    
    @Column(nullable = false)
    private LocalDateTime lastUpdated;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "qms_supplier_category_relation",
        joinColumns = @JoinColumn(name = "supplier_id"),
        inverseJoinColumns = @JoinColumn(name = "category_id")
    )
    private Set<SupplierCategory> categories = new HashSet<>();
    
    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL)
    private List<SupplierContact> contacts = new ArrayList<>();
    
    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL)
    private List<SupplierCertificate> certificates = new ArrayList<>();
    
    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL)
    private List<SupplierQualityAgreement> agreements = new ArrayList<>();
}

@Entity
@Table(name = "qms_supplier_contact")
@Data
public class SupplierContact {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false, length = 50)
    private String contactName;
    
    @Column(length = 20)
    private String position;
    
    @Column(length = 20)
    private String phone;
    
    @Column(length = 100)
    private String email;
    
    @Column(nullable = false)
    private ContactType contactType; // PRIMARY, TECHNICAL, BUSINESS, EMERGENCY
    
    @Column(nullable = false)
    private Boolean active = true;
}

@Entity
@Table(name = "qms_supplier_certificate")
@Data
public class SupplierCertificate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false, length = 100)
    private String certificateName;
    
    @Column(nullable = false, length = 50)
    private String certificateNumber;
    
    @Column(nullable = false)
    private CertificateType certificateType;
    
    @Column(nullable = false)
    private LocalDate issueDate;
    
    @Column(nullable = false)
    private LocalDate expiryDate;
    
    @Column(nullable = false)
    private String issuingAuthority;
    
    @Column(length = 500)
    private String certificateUrl;
    
    @Column(nullable = false)
    private CertificateStatus status; // VALID, EXPIRED, SUSPENDED
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updateCertificateStatus();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updateCertificateStatus();
    }
    
    private void updateCertificateStatus() {
        if (expiryDate != null && expiryDate.isBefore(LocalDate.now())) {
            this.status = CertificateStatus.EXPIRED;
        } else {
            this.status = CertificateStatus.VALID;
        }
    }
}
\`\`\`

#### 2.2.2 供应商管理服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class SupplierService {
    
    private final SupplierRepository supplierRepository;
    private final SupplierCategoryRepository categoryRepository;
    private final FileStorageService fileStorageService;
    private final NotificationService notificationService;
    
    /**
     * 创建供应商
     */
    @Transactional
    public SupplierDTO createSupplier(SupplierCreateDTO dto, MultipartFile[] files) {
        // 验证供应商代码唯一性
        validateSupplierCode(dto.getSupplierCode());
        
        // 创建供应商实体
        Supplier supplier = Supplier.builder()
            .supplierName(dto.getSupplierName())
            .supplierCode(dto.getSupplierCode())
            .supplierType(dto.getSupplierType())
            .legalRepresentative(dto.getLegalRepresentative())
            .registrationNumber(dto.getRegistrationNumber())
            .address(dto.getAddress())
            .postalCode(dto.getPostalCode())
            .contactPerson(dto.getContactPerson())
            .contactPhone(dto.getContactPhone())
            .contactEmail(dto.getContactEmail())
            .website(dto.getWebsite())
            .businessScope(dto.getBusinessScope())
            .establishedDate(dto.getEstablishedDate())
            .companyProfile(dto.getCompanyProfile())
            .status(SupplierStatus.ACTIVE)
            .registrationDate(LocalDateTime.now())
            .lastUpdated(LocalDateTime.now())
            .build();
        
        // 设置分类
        if (dto.getCategoryIds() != null && !dto.getCategoryIds().isEmpty()) {
            Set<SupplierCategory> categories = categoryRepository.findAllById(dto.getCategoryIds());
            supplier.setCategories(categories);
        }
        
        supplierRepository.save(supplier);
        
        // 处理附件上传
        handleSupplierFiles(supplier, files);
        
        // 发送通知
        notificationService.sendSupplierCreatedNotification(supplier);
        
        return convertToDTO(supplier);
    }
    
    /**
     * 更新供应商信息
     */
    @Transactional
    public SupplierDTO updateSupplier(Long supplierId, SupplierUpdateDTO dto) {
        Supplier supplier = supplierRepository.findById(supplierId)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        // 更新基本信息
        if (StringUtils.hasText(dto.getSupplierName())) {
            supplier.setSupplierName(dto.getSupplierName());
        }
        if (StringUtils.hasText(dto.getLegalRepresentative())) {
            supplier.setLegalRepresentative(dto.getLegalRepresentative());
        }
        if (StringUtils.hasText(dto.getAddress())) {
            supplier.setAddress(dto.getAddress());
        }
        if (StringUtils.hasText(dto.getContactPhone())) {
            supplier.setContactPhone(dto.getContactPhone());
        }
        
        // 更新分类
        if (dto.getCategoryIds() != null) {
            Set<SupplierCategory> categories = categoryRepository.findAllById(dto.getCategoryIds());
            supplier.setCategories(categories);
        }
        
        supplier.setLastUpdated(LocalDateTime.now());
        supplierRepository.save(supplier);
        
        return convertToDTO(supplier);
    }
    
    /**
     * 供应商基本信息查询
     */
    public SupplierDetailDTO getSupplierDetail(Long supplierId) {
        Supplier supplier = supplierRepository.findByIdWithDetails(supplierId)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        SupplierDetailDTO dto = convertToDetailDTO(supplier);
        
        // 获取绩效统计
        SupplierPerformanceStats stats = getSupplierPerformanceStats(supplierId);
        dto.setPerformanceStats(stats);
        
        // 获取风险评估结果
        SupplierRiskAssessment risk = getSupplierRiskAssessment(supplierId);
        dto.setRiskAssessment(risk);
        
        return dto;
    }
    
    /**
     * 供应商搜索
     */
    public Page<SupplierListDTO> searchSuppliers(SupplierSearchCriteria criteria, Pageable pageable) {
        Specification<Supplier> spec = Specification.where(null);
        
        // 关键词搜索
        if (StringUtils.hasText(criteria.getKeyword())) {
            spec = spec.and((root, query, cb) -> cb.or(
                cb.like(root.get("supplierName"), "%" + criteria.getKeyword() + "%"),
                cb.like(root.get("supplierCode"), "%" + criteria.getKeyword() + "%"),
                cb.like(root.get("contactPerson"), "%" + criteria.getKeyword() + "%")
            ));
        }
        
        // 分类过滤
        if (criteria.getCategoryId() != null) {
            spec = spec.and((root, query, cb) -> {
                Join<Supplier, SupplierCategory> categoryJoin = root.join("categories", JoinType.INNER);
                return cb.equal(categoryJoin.get("id"), criteria.getCategoryId());
            });
        }
        
        // 状态过滤
        if (criteria.getStatus() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("status"), criteria.getStatus()));
        }
        
        // 供应商类型过滤
        if (StringUtils.hasText(criteria.getSupplierType())) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("supplierType"), criteria.getSupplierType()));
        }
        
        // 评级过滤
        if (criteria.getRating() != null) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("currentRating"), criteria.getRating()));
        }
        
        Page<Supplier> page = supplierRepository.findAll(spec, pageable);
        return page.map(this::convertToListDTO);
    }
}
\`\`\`

### 2.3 供应商评估认证管理

#### 2.3.1 供应商评估体系
\`\`\`java
// 供应商评估实体
@Entity
@Table(name = "qms_supplier_assessment")
@Data
public class SupplierAssessment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false, length = 100)
    private String assessmentName;
    
    @Column(nullable = false)
    private AssessmentType assessmentType; // INITIAL, PERIODIC, SPECIAL
    
    @Column(nullable = false)
    private LocalDate assessmentDate;
    
    @Column(nullable = false)
    private AssessorStatus status; // PLANNED, IN_PROGRESS, COMPLETED, FAILED
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assessor_id", nullable = false)
    private User assessor;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    @OneToMany(mappedBy = "assessment", cascade = CascadeType.ALL)
    private List<AssessmentCriteria> criteria = new ArrayList<>();
    
    @OneToMany(mappedBy = "assessment", cascade = CascadeType.ALL)
    private List<AssessmentFinding> findings = new ArrayList<>();
    
    @OneToMany(mappedBy = "assessment", cascade = CascadeType.ALL)
    private List<AssessmentEvidence> evidence = new ArrayList<>();
    
    @Column(nullable = false)
    private BigDecimal totalScore;
    
    @Column(nullable = false)
    private BigDecimal maxScore;
    
    @Column(nullable = false)
    private BigDecimal percentage;
    
    @Column(nullable = false)
    private SupplierRating rating; // A, B, C, D
    
    @Column(length = 2000)
    private String overallAssessment;
    
    @Column(length = 1000)
    private String improvementPlan;
    
    @Column
    private LocalDate nextAssessmentDate;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        status = AssessorStatus.PLANNED;
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

// 评估标准实体
@Entity
@Table(name = "qms_assessment_criteria")
@Data
public class AssessmentCriteria {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assessment_id", nullable = false)
    private SupplierAssessment assessment;
    
    @Column(nullable = false, length = 200)
    private String criteriaName;
    
    @Column(nullable = false, length = 1000)
    private String criteriaDescription;
    
    @Column(nullable = false)
    private Integer weight;
    
    @Column(nullable = false)
    private BigDecimal maxScore;
    
    @Column(nullable = false)
    private BigDecimal actualScore;
    
    @Column(nullable = false)
    private String category; // QUALITY, DELIVERY, COST, SERVICE, TECHNOLOGY, MANAGEMENT
    
    @Column(length = 1000)
    private String evidenceRequired;
    
    @Column(length = 1000)
    private String improvementSuggestions;
    
    @Column(nullable = false)
    private AssessmentCriteriaStatus status; // NOT_STARTED, IN_PROGRESS, COMPLETED, N/A
}

// 评估发现实体
@Entity
@Table(name = "qms_assessment_finding")
@Data
public class AssessmentFinding {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assessment_id", nullable = false)
    private SupplierAssessment assessment;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "criteria_id", nullable = false)
    private AssessmentCriteria criteria;
    
    @Column(nullable = false, length = 500)
    private String findingDescription;
    
    @Column(nullable = false)
    private FindingSeverity severity; // CRITICAL, MAJOR, MINOR, OBSERVATION
    
    @Column(nullable = false, length = 1000)
    private String rootCauseAnalysis;
    
    @Column(nullable = false, length = 1000)
    private String correctiveAction;
    
    @Column(length = 1000)
    private String preventiveAction;
    
    @Column(nullable = false)
    private FindingStatus status; // OPEN, IN_PROGRESS, COMPLETED, VERIFIED
    
    @Column
    private LocalDate dueDate;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignee_id")
    private User assignee;
    
    @Column(length = 1000)
    private String verificationResults;
    
    @Column
    private LocalDate verificationDate;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "verifier_id")
    private User verifier;
}
\`\`\`

#### 2.3.2 评估流程管理
\`\`\`java
@Service
@RequiredArgsConstructor
public class SupplierAssessmentService {
    
    private final SupplierAssessmentRepository assessmentRepository;
    private final AssessmentCriteriaRepository criteriaRepository;
    private final FindingRepository findingRepository;
    private final SupplierRepository supplierRepository;
    private final NotificationService notificationService;
    private final WorkflowEngine workflowEngine;
    
    /**
     * 创建供应商评估
     */
    @Transactional
    public SupplierAssessmentDTO createAssessment(SupplierAssessmentCreateDTO dto) {
        Supplier supplier = supplierRepository.findById(dto.getSupplierId())
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        // 创建评估记录
        SupplierAssessment assessment = SupplierAssessment.builder()
            .supplier(supplier)
            .assessmentName(dto.getAssessmentName())
            .assessmentType(dto.getAssessmentType())
            .assessmentDate(dto.getAssessmentDate())
            .assessor(SecurityUtils.getCurrentUser())
            .totalScore(BigDecimal.ZERO)
            .maxScore(BigDecimal.ZERO)
            .percentage(BigDecimal.ZERO)
            .rating(SupplierRating.C)
            .status(AssessorStatus.PLANNED)
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();
        
        assessmentRepository.save(assessment);
        
        // 创建评估标准
        createAssessmentCriteria(assessment, dto.getTemplateId());
        
        // 启动评估工作流
        startAssessmentWorkflow(assessment);
        
        return convertToDTO(assessment);
    }
    
    /**
     * 开始评估
     */
    @Transactional
    public void startAssessment(Long assessmentId) {
        SupplierAssessment assessment = assessmentRepository.findById(assessmentId)
            .orElseThrow(() -> new EntityNotFoundException("Assessment not found"));
        
        assessment.setStatus(AssessorStatus.IN_PROGRESS);
        assessment.setUpdatedAt(LocalDateTime.now());
        assessmentRepository.save(assessment);
        
        // 启动评估任务分配
        assignAssessmentTasks(assessment);
        
        notificationService.sendAssessmentStartedNotification(assessment);
    }
    
    /**
     * 提交评估结果
     */
    @Transactional
    public void submitAssessment(Long assessmentId, AssessmentSubmitDTO dto) {
        SupplierAssessment assessment = assessmentRepository.findById(assessmentId)
            .orElseThrow(() -> new EntityNotFoundException("Assessment not found"));
        
        // 验证评估完成
        validateAssessmentCompletion(assessment);
        
        // 计算总分和评级
        calculateAssessmentScore(assessment, dto.getScores());
        
        // 更新状态
        assessment.setStatus(AssessorStatus.COMPLETED);
        assessment.setOverallAssessment(dto.getOverallAssessment());
        assessment.setImprovementPlan(dto.getImprovementPlan());
        assessment.setNextAssessmentDate(dto.getNextAssessmentDate());
        assessment.setUpdatedAt(LocalDateTime.now());
        
        assessmentRepository.save(assessment);
        
        // 更新供应商评级
        updateSupplierRating(assessment.getSupplier().getId(), assessment.getRating());
        
        // 发送通知
        notificationService.sendAssessmentCompletedNotification(assessment);
    }
    
    /**
     * 创建评估标准
     */
    private void createAssessmentCriteria(SupplierAssessment assessment, Long templateId) {
        AssessmentTemplate template = getAssessmentTemplate(templateId);
        
        for (TemplateCriteria templateCriteria : template.getCriteria()) {
            AssessmentCriteria criteria = AssessmentCriteria.builder()
                .assessment(assessment)
                .criteriaName(templateCriteria.getName())
                .criteriaDescription(templateCriteria.getDescription())
                .weight(templateCriteria.getWeight())
                .maxScore(templateCriteria.getMaxScore())
                .category(templateCriteria.getCategory())
                .evidenceRequired(templateCriteria.getEvidenceRequired())
                .improvementSuggestions(templateCriteria.getImprovementSuggestions())
                .status(AssessmentCriteriaStatus.NOT_STARTED)
                .actualScore(BigDecimal.ZERO)
                .build();
            
            criteriaRepository.save(criteria);
            assessment.getCriteria().add(criteria);
        }
        
        // 计算总分
        BigDecimal maxScore = assessment.getCriteria().stream()
            .map(c -> c.getMaxScore())
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        assessment.setMaxScore(maxScore);
        
        assessmentRepository.save(assessment);
    }
    
    /**
     * 计算评估分数和评级
     */
    private void calculateAssessmentScore(SupplierAssessment assessment, Map<Long, BigDecimal> scores) {
        BigDecimal totalScore = BigDecimal.ZERO;
        BigDecimal totalMaxScore = assessment.getMaxScore();
        
        // 更新每个标准的分数
        for (Map.Entry<Long, BigDecimal> entry : scores.entrySet()) {
            AssessmentCriteria criteria = criteriaRepository.findById(entry.getKey())
                .orElseThrow(() -> new EntityNotFoundException("Criteria not found"));
            
            criteria.setActualScore(entry.getValue());
            criteria.setStatus(AssessmentCriteriaStatus.COMPLETED);
            criteriaRepository.save(criteria);
            
            totalScore = totalScore.add(entry.getValue().multiply(new BigDecimal(criteria.getWeight())));
        }
        
        // 计算百分比
        BigDecimal percentage = totalScore.divide(totalMaxScore, 4, RoundingMode.HALF_UP).multiply(new BigDecimal("100"));
        
        // 确定评级
        SupplierRating rating = determineRating(percentage);
        
        // 更新评估结果
        assessment.setTotalScore(totalScore);
        assessment.setPercentage(percentage);
        assessment.setRating(rating);
        
        assessmentRepository.save(assessment);
    }
    
    /**
     * 确定供应商评级
     */
    private SupplierRating determineRating(BigDecimal percentage) {
        if (percentage.compareTo(new BigDecimal("90")) >= 0) {
            return SupplierRating.A;
        } else if (percentage.compareTo(new BigDecimal("80")) >= 0) {
            return SupplierRating.B;
        } else if (percentage.compareTo(new BigDecimal("60")) >= 0) {
            return SupplierRating.C;
        } else {
            return SupplierRating.D;
        }
    }
    
    /**
     * 更新供应商评级
     */
    private void updateSupplierRating(Long supplierId, SupplierRating newRating) {
        Supplier supplier = supplierRepository.findById(supplierId)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        supplier.setCurrentRating(newRating);
        supplier.setLastRatingUpdate(LocalDateTime.now());
        supplierRepository.save(supplier);
    }
}
\`\`\`

### 2.4 供应商绩效监控

#### 2.4.1 绩效指标体系
\`\`\`java
// 供应商绩效实体
@Entity
@Table(name = "qms_supplier_performance")
@Data
public class SupplierPerformance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false)
    private LocalDate performanceMonth;
    
    @Column(nullable = false)
    private BigDecimal qualityScore;
    
    @Column(nullable = false)
    private BigDecimal deliveryScore;
    
    @Column(nullable = false)
    private BigDecimal costScore;
    
    @Column(nullable = false)
    private BigDecimal serviceScore;
    
    @Column(nullable = false)
    private BigDecimal technologyScore;
    
    @Column(nullable = false)
    private BigDecimal managementScore;
    
    @Column(nullable = false)
    private BigDecimal overallScore;
    
    @Column(nullable = false)
    private SupplierRating rating;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(length = 1000)
    private String performanceSummary;
    
    @Column(length = 2000)
    private String improvementAreas;
    
    @OneToMany(mappedBy = "performance", cascade = CascadeType.ALL)
    private List<PerformanceMetric> metrics = new ArrayList<>();
    
    @OneToMany(mappedBy = "performance", cascade = CascadeType.ALL)
    private List<PerformanceIncident> incidents = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}

// 绩效指标实体
@Entity
@Table(name = "qms_performance_metric")
@Data
public class PerformanceMetric {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "performance_id", nullable = false)
    private SupplierPerformance performance;
    
    @Column(nullable = false, length = 100)
    private String metricName;
    
    @Column(nullable = false)
    private String metricType; // QUANTITY, PERCENTAGE, RATIO, SCORE
    
    @Column(nullable = false)
    private BigDecimal targetValue;
    
    @Column(nullable = false)
    private BigDecimal actualValue;
    
    @Column(nullable = false)
    private BigDecimal score;
    
    @Column(nullable = false)
    private MetricStatus status; // ON_TARGET, BELOW_TARGET, ABOVE_TARGET
    
    @Column(nullable = false)
    private String category; // QUALITY, DELIVERY, COST, SERVICE, TECHNOLOGY, MANAGEMENT
    
    @Column(length = 500)
    private String calculationMethod;
    
    @Column(length = 1000)
    private String comments;
}
\`\`\`

#### 2.4.2 绩效监控服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class SupplierPerformanceService {
    
    private final SupplierPerformanceRepository performanceRepository;
    private final PerformanceMetricRepository metricRepository;
    private final IncidentRepository incidentRepository;
    private final SupplierRepository supplierRepository;
    private InfluxDBClient influxDBClient;
    
    /**
     * 记录供应商绩效
     */
    @Transactional
    public SupplierPerformanceDTO recordPerformance(SupplierPerformanceDTO dto) {
        Supplier supplier = supplierRepository.findById(dto.getSupplierId())
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        // 检查是否已存在该月的绩效记录
        LocalDate performanceMonth = dto.getPerformanceMonth();
        Optional<SupplierPerformance> existing = performanceRepository
            .findBySupplierIdAndPerformanceMonth(supplier.getId(), performanceMonth);
        
        if (existing.isPresent()) {
            throw new IllegalStateException("Performance record already exists for this month");
        }
        
        // 创建绩效记录
        SupplierPerformance performance = SupplierPerformance.builder()
            .supplier(supplier)
            .performanceMonth(performanceMonth)
            .qualityScore(dto.getQualityScore())
            .deliveryScore(dto.getDeliveryScore())
            .costScore(dto.getCostScore())
            .serviceScore(dto.getServiceScore())
            .technologyScore(dto.getTechnologyScore())
            .managementScore(dto.getManagementScore())
            .performanceSummary(dto.getPerformanceSummary())
            .improvementAreas(dto.getImprovementAreas())
            .createdAt(LocalDateTime.now())
            .build();
        
        // 计算总分和评级
        calculateOverallScore(performance);
        
        performanceRepository.save(performance);
        
        // 记录指标
        recordPerformanceMetrics(performance, dto.getMetrics());
        
        // 记录事件
        recordPerformanceIncidents(performance, dto.getIncidents());
        
        // 写入时序数据库
        writePerformanceToTimeSeries(performance);
        
        return convertToDTO(performance);
    }
    
    /**
     * 计算综合绩效分数
     */
    private void calculateOverallScore(SupplierPerformance performance) {
        // 定义权重
        Map<String, BigDecimal> weights = Map.of(
            "quality", new BigDecimal("0.30"),
            "delivery", new BigDecimal("0.25"),
            "cost", new BigDecimal("0.15"),
            "service", new BigDecimal("0.10"),
            "technology", new BigDecimal("0.10"),
            "management", new BigDecimal("0.10")
        );
        
        // 计算加权总分
        BigDecimal totalScore = BigDecimal.ZERO;
        for (Map.Entry<String, BigDecimal> entry : weights.entrySet()) {
            BigDecimal categoryScore = getScoreByCategory(performance, entry.getKey());
            totalScore = totalScore.add(categoryScore.multiply(entry.getValue()));
        }
        
        performance.setOverallScore(totalScore.setScale(2, RoundingMode.HALF_UP));
        
        // 确定评级
        SupplierRating rating = determineRating(totalScore);
        performance.setRating(rating);
    }
    
    /**
     * 获取分类分数
     */
    private BigDecimal getScoreByCategory(SupplierPerformance performance, String category) {
        switch (category) {
            case "quality":
                return performance.getQualityScore();
            case "delivery":
                return performance.getDeliveryScore();
            case "cost":
                return performance.getCostScore();
            case "service":
                return performance.getServiceScore();
            case "technology":
                return performance.getTechnologyScore();
            case "management":
                return performance.getManagementScore();
            default:
                return BigDecimal.ZERO;
        }
    }
    
    /**
     * 生成月度绩效报告
     */
    @Async
    public void generateMonthlyPerformanceReport(LocalDate month) {
        List<Supplier> activeSuppliers = supplierRepository.findByStatus(SupplierStatus.ACTIVE);
        
        for (Supplier supplier : activeSuppliers) {
            generateSupplierPerformanceReport(supplier, month);
        }
    }
    
    /**
     * 生成供应商绩效趋势分析
     */
    public PerformanceTrendDTO getPerformanceTrend(Long supplierId, int months) {
        LocalDate endDate = LocalDate.now();
        LocalDate startDate = endDate.minusMonths(months);
        
        List<SupplierPerformance> performances = performanceRepository
            .findBySupplierIdAndPerformanceMonthBetween(supplierId, startDate, endDate);
        
        PerformanceTrendDTO trend = new PerformanceTrendDTO();
        trend.setSupplierId(supplierId);
        trend.setStartDate(startDate);
        trend.setEndDate(endDate);
        
        // 按月组织数据
        Map<LocalDate, PerformanceMonthData> monthlyData = new HashMap<>();
        
        for (SupplierPerformance performance : performances) {
            PerformanceMonthData monthData = new PerformanceMonthData();
            monthData.setMonth(performance.getPerformanceMonth());
            monthData.setOverallScore(performance.getOverallScore());
            monthData.setQualityScore(performance.getQualityScore());
            monthData.setDeliveryScore(performance.getDeliveryScore());
            monthData.setCostScore(performance.getCostScore());
            monthData.setServiceScore(performance.getServiceScore());
            monthData.setTechnologyScore(performance.getTechnologyScore());
            monthData.setManagementScore(performance.getManagementScore());
            monthData.setRating(performance.getRating());
            
            monthlyData.put(performance.getPerformanceMonth(), monthData);
        }
        
        trend.setMonthlyData(new ArrayList<>(monthlyData.values()));
        
        // 计算趋势指标
        calculateTrendIndicators(trend);
        
        return trend;
    }
    
    /**
     * 计算趋势指标
     */
    private void calculateTrendIndicators(PerformanceTrendDTO trend) {
        List<PerformanceMonthData> monthlyData = trend.getMonthlyData();
        
        if (monthlyData.size() < 2) {
            return;
        }
        
        // 计算总体趋势
        BigDecimal firstScore = monthlyData.get(0).getOverallScore();
        BigDecimal lastScore = monthlyData.get(monthlyData.size() - 1).getOverallScore();
        BigDecimal trendScore = lastScore.subtract(firstScore);
        
        trend.setOverallTrend(trendScore.compareTo(BigDecimal.ZERO) > 0 ? "IMPROVING" : 
                            trendScore.compareTo(BigDecimal.ZERO) < 0 ? "DECLINING" : "STABLE");
        
        // 计算各分类趋势
        Map<String, String> categoryTrends = new HashMap<>();
        categoryTrends.put("quality", calculateCategoryTrend(monthlyData, PerformanceMonthData::getQualityScore));
        categoryTrends.put("delivery", calculateCategoryTrend(monthlyData, PerformanceMonthData::getDeliveryScore));
        categoryTrends.put("cost", calculateCategoryTrend(monthlyData, PerformanceMonthData::getCostScore));
        categoryTrends.put("service", calculateCategoryTrend(monthlyData, PerformanceMonthData::getServiceScore));
        categoryTrends.put("technology", calculateCategoryTrend(monthlyData, PerformanceMonthData::getTechnologyScore));
        categoryTrends.put("management", calculateCategoryTrend(monthlyData, PerformanceMonthData::getManagementScore));
        
        trend.setCategoryTrends(categoryTrends);
    }
    
    private String calculateCategoryTrend(List<PerformanceMonthData> monthlyData, 
                                        Function<PerformanceMonthData, BigDecimal> scoreExtractor) {
        if (monthlyData.size() < 2) {
            return "STABLE";
        }
        
        BigDecimal firstScore = scoreExtractor.apply(monthlyData.get(0));
        BigDecimal lastScore = scoreExtractor.apply(monthlyData.get(monthlyData.size() - 1));
        BigDecimal difference = lastScore.subtract(firstScore);
        
        if (difference.abs().compareTo(new BigDecimal("2")) < 0) {
            return "STABLE";
        }
        
        return difference.compareTo(BigDecimal.ZERO) > 0 ? "IMPROVING" : "DECLINING";
    }
}
\`\`\`

### 2.5 供应商质量管理

#### 2.5.1 质量问题跟踪
\`\`\`java
// 供应商质量问题实体
@Entity
@Table(name = "qms_supplier_quality_issue")
@Data
public class SupplierQualityIssue {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false, length = 100)
    private String issueCode;
    
    @Column(nullable = false, length = 500)
    private String issueDescription;
    
    @Column(nullable = false)
    private QualityIssueType issueType; // MATERIAL_DEFECT, PROCESS_DEFECT, DOCUMENTATION, OTHER
    
    @Column(nullable = false)
    private IssueSeverity severity; // CRITICAL, MAJOR, MINOR
    
    @Column(nullable = false)
    private IssueStatus status; // OPEN, IN_PROGRESS, RESOLVED, CLOSED
    
    @Column(nullable = false)
    private LocalDate discoveryDate;
    
    @Column
    private LocalDate targetResolutionDate;
    
    @Column
    private LocalDate actualResolutionDate;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reported_by")
    private User reportedBy;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assigned_to")
    private User assignedTo;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    @Column(length = 2000)
    private String rootCauseAnalysis;
    
    @Column(length = 2000)
    private String correctiveAction;
    
    @Column(length = 2000)
    private String preventiveAction;
    
    @Column(length = 1000)
    private String verificationResults;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "verified_by")
    private User verifiedBy;
    
    @Column
    private LocalDateTime verificationDate;
    
    @OneToMany(mappedBy = "issue", cascade = CascadeType.ALL)
    private List<QualityIssueAttachment> attachments = new ArrayList<>();
    
    @OneToMany(mappedBy = "issue", cascade = CascadeType.ALL)
    private List<IssueHistory> history = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        discoveryDate = LocalDate.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
\`\`\`

#### 2.5.2 质量问题管理服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class SupplierQualityIssueService {
    
    private final SupplierQualityIssueRepository issueRepository;
    private final SupplierRepository supplierRepository;
    private final NotificationService notificationService;
    private final WorkflowEngine workflowEngine;
    
    /**
     * 创建供应商质量问题
     */
    @Transactional
    public SupplierQualityIssueDTO createIssue(SupplierQualityIssueCreateDTO dto) {
        Supplier supplier = supplierRepository.findById(dto.getSupplierId())
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        // 生成问题编号
        String issueCode = generateIssueCode();
        
        // 创建质量问题记录
        SupplierQualityIssue issue = SupplierQualityIssue.builder()
            .supplier(supplier)
            .issueCode(issueCode)
            .issueDescription(dto.getIssueDescription())
            .issueType(dto.getIssueType())
            .severity(dto.getSeverity())
            .status(IssueStatus.OPEN)
            .reportedBy(SecurityUtils.getCurrentUser())
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .targetResolutionDate(dto.getTargetResolutionDate())
            .build();
        
        issueRepository.save(issue);
        
        // 分配处理任务
        assignIssueTask(issue);
        
        // 记录历史
        recordIssueHistory(issue, "ISSUE_CREATED", "质量问题已创建");
        
        // 发送通知
        notificationService.sendSupplierQualityIssueCreatedNotification(issue);
        
        return convertToDTO(issue);
    }
    
    /**
     * 更新问题状态
     */
    @Transactional
    public void updateIssueStatus(Long issueId, IssueStatus newStatus, String comment) {
        SupplierQualityIssue issue = issueRepository.findById(issueId)
            .orElseThrow(() -> new EntityNotFoundException("Quality issue not found"));
        
        IssueStatus oldStatus = issue.getStatus();
        issue.setStatus(newStatus);
        issue.setUpdatedAt(LocalDateTime.now());
        
        // 如果问题已解决，记录解决日期
        if (newStatus == IssueStatus.RESOLVED) {
            issue.setActualResolutionDate(LocalDate.now());
        }
        
        issueRepository.save(issue);
        
        // 记录状态变更历史
        recordIssueHistory(issue, "STATUS_CHANGED", 
            String.format("状态从 %s 变更为 %s", oldStatus, newStatus), comment);
        
        // 发送通知
        notificationService.sendSupplierQualityIssueStatusChangedNotification(issue, oldStatus, newStatus);
    }
    
    /**
     * 分配问题处理任务
     */
    @Transactional
    public void assignIssue(Long issueId, Long assigneeId, String comment) {
        SupplierQualityIssue issue = issueRepository.findById(issueId)
            .orElseThrow(() -> new EntityNotFoundException("Quality issue not found"));
        
        User assignee = userRepository.findById(assigneeId)
            .orElseThrow(() -> new EntityNotFoundException("Assignee not found"));
        
        User oldAssignee = issue.getAssignedTo();
        issue.setAssignedTo(assignee);
        issue.setUpdatedAt(LocalDateTime.now());
        
        issueRepository.save(issue);
        
        // 记录分配历史
        recordIssueHistory(issue, "ASSIGNED", 
            String.format("从 %s 分配给 %s", 
                oldAssignee != null ? oldAssignee.getName() : "未分配", 
                assignee.getName()), comment);
        
        // 通知新负责人
        notificationService.sendSupplierQualityIssueAssignedNotification(issue, assignee);
    }
    
    /**
     * 关闭质量问题
     */
    @Transactional
    public void closeIssue(Long issueId, String verificationResults, String comment) {
        SupplierQualityIssue issue = issueRepository.findById(issueId)
            .orElseThrow(() -> new EntityNotFoundException("Quality issue not found"));
        
        if (issue.getStatus() != IssueStatus.RESOLVED) {
            throw new IllegalStateException("Only resolved issues can be closed");
        }
        
        issue.setStatus(IssueStatus.CLOSED);
        issue.setVerificationResults(verificationResults);
        issue.setVerifiedBy(SecurityUtils.getCurrentUser());
        issue.setVerificationDate(LocalDate.now());
        issue.setUpdatedAt(LocalDateTime.now());
        
        issueRepository.save(issue);
        
        // 记录关闭历史
        recordIssueHistory(issue, "CLOSED", "质量问题已关闭", comment);
        
        // 更新供应商绩效
        updateSupplierQualityPerformance(issue.getSupplier().getId());
        
        // 发送通知
        notificationService.sendSupplierQualityIssueClosedNotification(issue);
    }
    
    /**
     * 获取供应商质量问题统计
     */
    public SupplierQualityStatsDTO getSupplierQualityStats(Long supplierId) {
        Supplier supplier = supplierRepository.findById(supplierId)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        SupplierQualityStatsDTO stats = new SupplierQualityStatsDTO();
        stats.setSupplierId(supplierId);
        stats.setSupplierName(supplier.getSupplierName());
        
        // 获取各类问题统计
        Map<IssueSeverity, Long> severityStats = issueRepository
            .countBySupplierIdAndSeverity(supplierId);
        stats.setSeverityStats(severityStats);
        
        // 获取状态统计
        Map<IssueStatus, Long> statusStats = issueRepository
            .countBySupplierIdAndStatus(supplierId);
        stats.setStatusStats(statusStats);
        
        // 计算质量指数
        BigDecimal qualityIndex = calculateQualityIndex(supplierId);
        stats.setQualityIndex(qualityIndex);
        
        // 获取最近的问题
        List<SupplierQualityIssue> recentIssues = issueRepository
            .findTop10BySupplierIdOrderByCreatedAtDesc(supplierId);
        stats.setRecentIssues(recentIssues.stream().map(this::convertToDTO).collect(Collectors.toList()));
        
        return stats;
    }
    
    /**
     * 计算质量指数
     */
    private BigDecimal calculateQualityIndex(Long supplierId) {
        // 获取过去6个月的问题数据
        LocalDate sixMonthsAgo = LocalDate.now().minusMonths(6);
        List<SupplierQualityIssue> recentIssues = issueRepository
            .findBySupplierIdAndDiscoveryDateAfter(supplierId, sixMonthsAgo);
        
        if (recentIssues.isEmpty()) {
            return BigDecimal.valueOf(100); // 没有问题得满分
        }
        
        // 计算加权分数
        BigDecimal totalWeight = BigDecimal.ZERO;
        BigDecimal weightedScore = BigDecimal.ZERO;
        
        for (SupplierQualityIssue issue : recentIssues) {
            BigDecimal severityWeight = getSeverityWeight(issue.getSeverity());
            totalWeight = totalWeight.add(severityWeight);
            
            // 未解决的问题扣分
            if (issue.getStatus() != IssueStatus.CLOSED) {
                weightedScore = weightedScore.add(severityWeight);
            }
        }
        
        if (totalWeight.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.valueOf(100);
        }
        
        // 质量指数 = 100 - (加权扣分 / 总权重 * 100)
        BigDecimal deduction = weightedScore.divide(totalWeight, 4, RoundingMode.HALF_UP)
            .multiply(new BigDecimal("100"));
        
        return BigDecimal.valueOf(100).subtract(deduction).max(BigDecimal.ZERO);
    }
    
    /**
     * 获取严重性权重
     */
    private BigDecimal getSeverityWeight(IssueSeverity severity) {
        switch (severity) {
            case CRITICAL:
                return new BigDecimal("3.0");
            case MAJOR:
                return new BigDecimal("2.0");
            case MINOR:
                return new BigDecimal("1.0");
            default:
                return BigDecimal.ONE;
        }
    }
    
    /**
     * 更新供应商质量绩效
     */
    private void updateSupplierQualityPerformance(Long supplierId) {
        SupplierQualityStatsDTO stats = getSupplierQualityStats(supplierId);
        BigDecimal qualityIndex = stats.getQualityIndex();
        
        // 根据质量指数调整供应商绩效分数
        SupplierPerformance latestPerformance = performanceRepository
            .findTopBySupplierIdOrderByPerformanceMonthDesc(supplierId)
            .orElse(null);
        
        if (latestPerformance != null) {
            // 质量指数转换为质量分数
            BigDecimal qualityScore = qualityIndex.multiply(new BigDecimal("0.4"))
                .add(new BigDecimal("60")); // 基础分60分
            
            latestPerformance.setQualityScore(qualityScore);
            performanceRepository.save(latestPerformance);
        }
    }
}
\`\`\`

### 2.6 供应商风险管控

#### 2.6.1 风险评估体系
\`\`\`java
// 供应商风险评估实体
@Entity
@Table(name = "qms_supplier_risk_assessment")
@Data
public class SupplierRiskAssessment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false, length = 100)
    private String assessmentName;
    
    @Column(nullable = false)
    private LocalDate assessmentDate;
    
    @Column(nullable = false)
    private RiskAssessmentStatus status; // DRAFT, IN_REVIEW, APPROVED, REJECTED
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    @Column(nullable = false)
    private BigDecimal overallRiskScore;
    
    @Column(nullable = false)
    private RiskLevel overallRiskLevel; // LOW, MEDIUM, HIGH, CRITICAL
    
    @Column(nullable = false)
    private RiskAssessmentType assessmentType; // INITIAL, PERIODIC, TRIGGERED
    
    @OneToMany(mappedBy = "assessment", cascade = CascadeType.ALL)
    private List<RiskFactor> riskFactors = new ArrayList<>();
    
    @OneToMany(mappedBy = "assessment", cascade = CascadeType.ALL)
    private List<RiskMitigation> mitigations = new ArrayList<>();
    
    @Column(length = 2000)
    private String riskSummary;
    
    @Column(length = 2000)
    private String riskMitigationPlan;
    
    @Column
    private LocalDate nextAssessmentDate;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

// 风险因素实体
@Entity
@Table(name = "qms_risk_factor")
@Data
public class RiskFactor {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assessment_id", nullable = false)
    private SupplierRiskAssessment assessment;
    
    @Column(nullable = false, length = 200)
    private String factorName;
    
    @Column(nullable = false)
    private RiskCategory category; // FINANCIAL, OPERATIONAL, QUALITY, COMPLIANCE, REPUTATIONAL
    
    @Column(nullable = false)
    private RiskImpact impact; // HIGH, MEDIUM, LOW
    
    @Column(nullable = false)
    private RiskProbability probability; // HIGH, MEDIUM, LOW
    
    @Column(nullable = false)
    private BigDecimal riskScore;
    
    @Column(nullable = false)
    private RiskLevel riskLevel; // LOW, MEDIUM, HIGH, CRITICAL
    
    @Column(nullable = false, length = 1000)
    private String riskDescription;
    
    @Column(nullable = false, length = 1000)
    private String existingControls;
    
    @Column(length = 1000)
    private String additionalControls;
    
    @Column(nullable = false)
    private RiskFactorStatus status; // IDENTIFIED, ANALYZED, MITIGATED, ACCEPTED
}
\`\`\`

#### 2.6.2 风险管理服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class SupplierRiskService {
    
    private final SupplierRiskAssessmentRepository riskRepository;
    private final RiskFactorRepository factorRepository;
    private final SupplierRepository supplierRepository;
    private final RiskNotificationService riskNotificationService;
    
    /**
     * 创建风险评估
     */
    @Transactional
    public SupplierRiskAssessmentDTO createRiskAssessment(SupplierRiskAssessmentCreateDTO dto) {
        Supplier supplier = supplierRepository.findById(dto.getSupplierId())
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        // 创建风险评估记录
        SupplierRiskAssessment assessment = SupplierRiskAssessment.builder()
            .supplier(supplier)
            .assessmentName(dto.getAssessmentName())
            .assessmentDate(dto.getAssessmentDate())
            .status(RiskAssessmentStatus.DRAFT)
            .assessmentType(dto.getAssessmentType())
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();
        
        riskRepository.save(assessment);
        
        // 创建初始风险因素
        createInitialRiskFactors(assessment);
        
        return convertToDTO(assessment);
    }
    
    /**
     * 评估风险因素
     */
    @Transactional
    public void assessRiskFactor(Long factorId, RiskAssessmentDTO dto) {
        RiskFactor factor = factorRepository.findById(factorId)
            .orElseThrow(() -> new EntityNotFoundException("Risk factor not found"));
        
        // 更新影响和概率
        factor.setImpact(dto.getImpact());
        factor.setProbability(dto.getProbability());
        
        // 计算风险分数
        BigDecimal riskScore = calculateRiskScore(dto.getImpact(), dto.getProbability());
        factor.setRiskScore(riskScore);
        
        // 确定风险等级
        RiskLevel riskLevel = determineRiskLevel(riskScore);
        factor.setRiskLevel(riskLevel);
        
        factor.setStatus(RiskFactorStatus.ANALYZED);
        factorRepository.save(factor);
        
        // 更新总体风险评估
        updateOverallRiskAssessment(factor.getAssessment().getId());
    }
    
    /**
     * 创建缓解措施
     */
    @Transactional
    public void createRiskMitigation(Long assessmentId, RiskMitigationCreateDTO dto) {
        SupplierRiskAssessment assessment = riskRepository.findById(assessmentId)
            .orElseThrow(() -> new EntityNotFoundException("Risk assessment not found"));
        
        // 验证相关风险因素
        RiskFactor factor = factorRepository.findById(dto.getFactorId())
            .orElseThrow(() -> new EntityNotFoundException("Risk factor not found"));
        
        if (!factor.getAssessment().getId().equals(assessmentId)) {
            throw new IllegalStateException("Risk factor does not belong to this assessment");
        }
        
        // 创建缓解措施
        RiskMitigation mitigation = RiskMitigation.builder()
            .assessment(assessment)
            .factor(factor)
            .mitigationTitle(dto.getMitigationTitle())
            .mitigationDescription(dto.getMitigationDescription())
            .mitigationType(dto.getMitigationType())
            .targetReduction(dto.getTargetReduction())
            .implementationDate(dto.getImplementationDate())
            .responsiblePerson(dto.getResponsiblePerson())
            .status(MitigationStatus.PLANNED)
            .createdAt(LocalDateTime.now())
            .build();
        
        assessment.getMitigations().add(mitigation);
        riskRepository.save(assessment);
        
        // 更新风险因素状态
        factor.setStatus(RiskFactorStatus.MITIGATED);
        factorRepository.save(factor);
        
        // 更新总体风险评估
        updateOverallRiskAssessment(assessmentId);
    }
    
    /**
     * 计算风险分数
     */
    private BigDecimal calculateRiskScore(RiskImpact impact, RiskProbability probability) {
        // 定义分值
        Map<RiskImpact, Integer> impactScores = Map.of(
            RiskImpact.HIGH, 3,
            RiskImpact.MEDIUM, 2,
            RiskImpact.LOW, 1
        );
        
        Map<RiskProbability, Integer> probabilityScores = Map.of(
            RiskProbability.HIGH, 3,
            RiskProbability.MEDIUM, 2,
            RiskProbability.LOW, 1
        );
        
        int impactScore = impactScores.get(impact);
        int probabilityScore = probabilityScores.get(probability);
        
        return new BigDecimal(impactScore * probabilityScore);
    }
    
    /**
     * 确定风险等级
     */
    private RiskLevel determineRiskLevel(BigDecimal riskScore) {
        if (riskScore.compareTo(new BigDecimal("9")) >= 0) {
            return RiskLevel.CRITICAL;
        } else if (riskScore.compareTo(new BigDecimal("6")) >= 0) {
            return RiskLevel.HIGH;
        } else if (riskScore.compareTo(new BigDecimal("3")) >= 0) {
            return RiskLevel.MEDIUM;
        } else {
            return RiskLevel.LOW;
        }
    }
    
    /**
     * 更新总体风险评估
     */
    private void updateOverallRiskAssessment(Long assessmentId) {
        SupplierRiskAssessment assessment = riskRepository.findById(assessmentId)
            .orElseThrow(() -> new EntityNotFoundException("Risk assessment not found"));
        
        List<RiskFactor> factors = factorRepository.findByAssessmentId(assessmentId);
        
        if (factors.isEmpty()) {
            return;
        }
        
        // 计算加权平均风险分数
        BigDecimal totalWeight = BigDecimal.ZERO;
        BigDecimal weightedScore = BigDecimal.ZERO;
        
        for (RiskFactor factor : factors) {
            BigDecimal weight = getRiskFactorWeight(factor.getRiskLevel());
            totalWeight = totalWeight.add(weight);
            
            // 未缓解的风险因素需要额外考虑
            if (factor.getStatus() != RiskFactorStatus.MITIGATED && 
                factor.getStatus() != RiskFactorStatus.ACCEPTED) {
                weightedScore = weightedScore.add(factor.getRiskScore().multiply(weight));
            } else {
                weightedScore = weightedScore.add(factor.getRiskScore().multiply(weight).multiply(new BigDecimal("0.3")));
            }
        }
        
        if (totalWeight.compareTo(BigDecimal.ZERO) == 0) {
            return;
        }
        
        BigDecimal overallScore = weightedScore.divide(totalWeight, 2, RoundingMode.HALF_UP);
        
        // 确定总体风险等级
        RiskLevel overallLevel = determineRiskLevel(overallScore);
        
        assessment.setOverallRiskScore(overallScore);
        assessment.setOverallRiskLevel(overallLevel);
        riskRepository.save(assessment);
        
        // 检查是否需要触发预警
        if (overallLevel == RiskLevel.CRITICAL || overallLevel == RiskLevel.HIGH) {
            riskNotificationService.sendHighRiskAlert(assessment);
        }
    }
    
    /**
     * 获取风险因素权重
     */
    private BigDecimal getRiskFactorWeight(RiskLevel level) {
        switch (level) {
            case CRITICAL:
                return new BigDecimal("3.0");
            case HIGH:
                return new BigDecimal("2.5");
            case MEDIUM:
                return new BigDecimal("2.0");
            case LOW:
                return new BigDecimal("1.0");
            default:
                return BigDecimal.ONE;
        }
    }
    
    /**
     * 获取供应商风险仪表板数据
     */
    public SupplierRiskDashboardDTO getSupplierRiskDashboard(Long supplierId) {
        Supplier supplier = supplierRepository.findById(supplierId)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        SupplierRiskDashboardDTO dashboard = new SupplierRiskDashboardDTO();
        dashboard.setSupplierId(supplierId);
        dashboard.setSupplierName(supplier.getSupplierName());
        
        // 获取最新的风险评估
        SupplierRiskAssessment latestAssessment = riskRepository
            .findTopBySupplierIdOrderByAssessmentDateDesc(supplierId)
            .orElse(null);
        
        if (latestAssessment != null) {
            dashboard.setLatestAssessment(convertToDTO(latestAssessment));
            
            // 风险分布统计
            Map<RiskLevel, Long> riskDistribution = factorRepository
                .countByAssessmentIdAndRiskLevel(latestAssessment.getId());
            dashboard.setRiskDistribution(riskDistribution);
            
            // 风险趋势
            List<RiskAssessmentTrend> trend = getRiskAssessmentTrend(supplierId, 12);
            dashboard.setRiskTrend(trend);
        }
        
        // 高风险因素列表
        List<RiskFactor> highRiskFactors = factorRepository
            .findByAssessmentIdAndRiskLevelInOrderByRiskScoreDesc(
                latestAssessment != null ? latestAssessment.getId() : -1, 
                List.of(RiskLevel.CRITICAL, RiskLevel.HIGH));
        dashboard.setHighRiskFactors(highRiskFactors.stream().map(this::convertFactorToDTO).collect(Collectors.toList()));
        
        return dashboard;
    }
    
    /**
     * 获取风险评估趋势
     */
    private List<RiskAssessmentTrend> getRiskAssessmentTrend(Long supplierId, int months) {
        LocalDate endDate = LocalDate.now();
        LocalDate startDate = endDate.minusMonths(months);
        
        List<SupplierRiskAssessment> assessments = riskRepository
            .findBySupplierIdAndAssessmentDateBetween(supplierId, startDate, endDate);
        
        return assessments.stream()
            .map(assessment -> {
                RiskAssessmentTrend trend = new RiskAssessmentTrend();
                trend.setAssessmentDate(assessment.getAssessmentDate());
                trend.setOverallRiskScore(assessment.getOverallRiskScore());
                trend.setOverallRiskLevel(assessment.getOverallRiskLevel());
                return trend;
            })
            .sorted(Comparator.comparing(RiskAssessmentTrend::getAssessmentDate))
            .collect(Collectors.toList());
    }
}
\`\`\`

### 2.7 供应商协同管理

#### 2.7.1 协同工作流
\`\`\`java
// 供应商协同任务实体
@Entity
@Table(name = "qms_supplier_collaboration_task")
@Data
public class SupplierCollaborationTask {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;
    
    @Column(nullable = false, length = 100)
    private String taskCode;
    
    @Column(nullable = false, length = 200)
    private String taskTitle;
    
    @Column(nullable = false)
    private CollaborationTaskType taskType; // QUALITY_IMPROVEMENT, DELIVERY_COORDINATION, COST_OPTIMIZATION
    
    @Column(nullable = false)
    private TaskStatus status; // PENDING, IN_PROGRESS, COMPLETED, CANCELLED
    
    @Column(nullable = false)
    private LocalDate startDate;
    
    @Column
    private LocalDate targetDate;
    
    @Column
    private LocalDate actualCompletionDate;
    
    @Column(nullable = false)
    private String taskDescription;
    
    @Column(nullable = false, length = 1000)
    private String deliverables;
    
    @Column(length = 2000)
    private String collaborationPlan;
    
    @Column(length = 2000)
    private String progressReport;
    
    @Column(length = 1000)
    private String finalResults;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "initiator_id", nullable = false)
    private User initiator;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_contact_id")
    private User supplierContact;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    @OneToMany(mappedBy = "task", cascade = CascadeType.ALL)
    private List<TaskAttachment> attachments = new ArrayList<>();
    
    @OneToMany(mappedBy = "task", cascade = CascadeType.ALL)
    private List<TaskMeeting> meetings = new ArrayList<>();
    
    @OneToMany(mappedBy = "task", cascade = CascadeType.ALL)
    private List<TaskMilestone> milestones = new ArrayList<>();
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        startDate = LocalDate.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
\`\`\`

#### 2.7.2 协同管理服务
\`\`\`java
@Service
@RequiredArgsConstructor
public class SupplierCollaborationService {
    
    private final SupplierCollaborationTaskRepository taskRepository;
    private final SupplierRepository supplierRepository;
    private final NotificationService notificationService;
    private final ExternalApiService externalApiService;
    
    /**
     * 创建协同任务
     */
    @Transactional
    public SupplierCollaborationTaskDTO createCollaborationTask(
            SupplierCollaborationTaskCreateDTO dto) {
        Supplier supplier = supplierRepository.findById(dto.getSupplierId())
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        // 生成任务编号
        String taskCode = generateTaskCode();
        
        // 创建协同任务
        SupplierCollaborationTask task = SupplierCollaborationTask.builder()
            .supplier(supplier)
            .taskCode(taskCode)
            .taskTitle(dto.getTaskTitle())
            .taskType(dto.getTaskType())
            .status(TaskStatus.PENDING)
            .taskDescription(dto.getTaskDescription())
            .deliverables(dto.getDeliverables())
            .collaborationPlan(dto.getCollaborationPlan())
            .targetDate(dto.getTargetDate())
            .initiator(SecurityUtils.getCurrentUser())
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();
        
        taskRepository.save(task);
        
        // 分配供应商联系人
        assignSupplierContact(task, dto.getSupplierContactId());
        
        // 创建里程碑
        createTaskMilestones(task, dto.getMilestones());
        
        // 发送通知
        notifySupplierAboutTask(task);
        
        return convertToDTO(task);
    }
    
    /**
     * 启动协同任务
     */
    @Transactional
    public void startCollaborationTask(Long taskId) {
        SupplierCollaborationTask task = taskRepository.findById(taskId)
            .orElseThrow(() -> new EntityNotFoundException("Collaboration task not found"));
        
        task.setStatus(TaskStatus.IN_PROGRESS);
        task.setUpdatedAt(LocalDateTime.now());
        taskRepository.save(task);
        
        // 通知相关人员
        notificationService.sendCollaborationTaskStartedNotification(task);
        
        // 在供应商门户创建对应任务
        externalApiService.createSupplierPortalTask(task);
    }
    
    /**
     * 更新任务进度
     */
    @Transactional
    public void updateTaskProgress(Long taskId, TaskProgressUpdateDTO dto) {
        SupplierCollaborationTask task = taskRepository.findById(taskId)
            .orElseThrow(() -> new EntityNotFoundException("Collaboration task not found"));
        
        task.setProgressReport(dto.getProgressReport());
        task.setUpdatedAt(LocalDateTime.now());
        
        // 更新里程碑状态
        if (dto.getMilestoneUpdates() != null) {
            updateTaskMilestones(task, dto.getMilestoneUpdates());
        }
        
        // 检查是否可以完成任务
        if (canCompleteTask(task)) {
            task.setStatus(TaskStatus.COMPLETED);
            task.setActualCompletionDate(LocalDate.now());
            
            // 记录最终结果
            task.setFinalResults(dto.getFinalResults());
            
            // 发送完成通知
            notificationService.sendCollaborationTaskCompletedNotification(task);
            
            // 更新供应商绩效
            updateSupplierCollaborationScore(task.getSupplier().getId(), task);
        }
        
        taskRepository.save(task);
    }
    
    /**
     * 创建协同会议
     */
    @Transactional
    public TaskMeetingDTO createTaskMeeting(Long taskId, TaskMeetingCreateDTO dto) {
        SupplierCollaborationTask task = taskRepository.findById(taskId)
            .orElseThrow(() -> new EntityNotFoundException("Collaboration task not found"));
        
        // 创建会议记录
        TaskMeeting meeting = TaskMeeting.builder()
            .task(task)
            .meetingTitle(dto.getMeetingTitle())
            .meetingDate(dto.getMeetingDate())
            .meetingTime(dto.getMeetingTime())
            .durationMinutes(dto.getDurationMinutes())
            .meetingLocation(dto.getMeetingLocation())
            .meetingType(dto.getMeetingType())
            .meetingAgenda(dto.getMeetingAgenda())
            .participants(dto.getParticipants())
            .organizer(SecurityUtils.getCurrentUser())
            .status(MeetingStatus.SCHEDULED)
            .createdAt(LocalDateTime.now())
            .build();
        
        task.getMeetings().add(meeting);
        taskRepository.save(task);
        
        // 发送会议邀请
        sendMeetingInvitations(meeting);
        
        return convertMeetingToDTO(meeting);
    }
    
    /**
     * 获取供应商协同仪表板
     */
    public SupplierCollaborationDashboardDTO getCollaborationDashboard(Long supplierId) {
        Supplier supplier = supplierRepository.findById(supplierId)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        
        SupplierCollaborationDashboardDTO dashboard = new SupplierCollaborationDashboardDTO();
        dashboard.setSupplierId(supplierId);
        dashboard.setSupplierName(supplier.getSupplierName());
        
        // 获取进行中的任务
        List<SupplierCollaborationTask> activeTasks = taskRepository
            .findBySupplierIdAndStatusInOrderByCreatedAtDesc(
                supplierId, List.of(TaskStatus.PENDING, TaskStatus.IN_PROGRESS));
        dashboard.setActiveTasks(activeTasks.stream().map(this::convertToDTO).collect(Collectors.toList()));
        
        // 获取即将到期的任务
        List<SupplierCollaborationTask> upcomingTasks = taskRepository
            .findBySupplierIdAndStatusAndTargetDateBefore(
                supplierId, TaskStatus.IN_PROGRESS, LocalDate.now().plusWeeks(1));
        dashboard.setUpcomingTasks(upcomingTasks.stream().map(this::convertToDTO).collect(Collectors.toList()));
        
        // 协同统计
        CollaborationStats stats = getCollaborationStats(supplierId);
        dashboard.setStats(stats);
        
        // 协同趋势
        CollaborationTrend trend = getCollaborationTrend(supplierId, 6);
        dashboard.setTrend(trend);
        
        return dashboard;
    }
    
    /**
     * 获取协同统计
     */
    private CollaborationStats getCollaborationStats(Long supplierId) {
        CollaborationStats stats = new CollaborationStats();
        
        // 任务统计
        Long totalTasks = taskRepository.countBySupplierId(supplierId);
        Long completedTasks = taskRepository.countBySupplierIdAndStatus(supplierId, TaskStatus.COMPLETED);
        Long overdueTasks = taskRepository.countBySupplierIdAndStatusAndTargetDateBefore(
            supplierId, TaskStatus.IN_PROGRESS, LocalDate.now());
        
        stats.setTotalTasks(totalTasks);
        stats.setCompletedTasks(completedTasks);
        stats.setOverdueTasks(overdueTasks);
        stats.setCompletionRate(totalTasks > 0 ? 
            new BigDecimal(completedTasks).divide(new BigDecimal(totalTasks), 4, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100")) : BigDecimal.ZERO);
        
        // 按类型统计
        Map<CollaborationTaskType, Long> taskTypeStats = taskRepository
            .countBySupplierIdAndTaskType(supplierId);
        stats.setTaskTypeStats(taskTypeStats);
        
        return stats;
    }
    
    /**
     * 获取协同趋势
     */
    private CollaborationTrend getCollaborationTrend(Long supplierId, int months) {
        LocalDate endDate = LocalDate.now();
        LocalDate startDate = endDate.minusMonths(months);
        
        // 按月统计任务数据
        Map<LocalDate, MonthlyCollaborationData> monthlyData = new HashMap<>();
        
        for (int i = 0; i < months; i++) {
            LocalDate monthDate = startDate.plusMonths(i);
            LocalDate nextMonth = monthDate.plusMonths(1);
            
            Long taskCount = taskRepository.countBySupplierIdAndCreatedAtBetween(
                supplierId, monthDate, nextMonth);
            
            MonthlyCollaborationData data = new MonthlyCollaborationData();
            data.setMonth(monthDate);
            data.setTaskCount(taskCount.intValue());
            data.setCompletionRate(calculateMonthlyCompletionRate(supplierId, monthDate));
            
            monthlyData.put(monthDate, data);
        }
        
        CollaborationTrend trend = new CollaborationTrend();
        trend.setStartDate(startDate);
        trend.setEndDate(endDate);
        trend.setMonthlyData(new ArrayList<>(monthlyData.values()));
        
        return trend;
    }
    
    /**
     * 计算月度完成率
     */
    private BigDecimal calculateMonthlyCompletionRate(Long supplierId, LocalDate monthDate) {
        LocalDate nextMonth = monthDate.plusMonths(1);
        
        Long totalTasks = taskRepository.countBySupplierIdAndCreatedAtBetween(
            supplierId, monthDate, nextMonth);
        Long completedTasks = taskRepository.countBySupplierIdAndStatusAndCreatedAtBetween(
            supplierId, TaskStatus.COMPLETED, monthDate, nextMonth);
        
        if (totalTasks == 0) {
            return BigDecimal.ZERO;
        }
        
        return new BigDecimal(completedTasks).divide(new BigDecimal(totalTasks), 4, RoundingMode.HALF_UP)
            .multiply(new BigDecimal("100"));
    }
    
    /**
     * 更新供应商协同分数
     */
    private void updateSupplierCollaborationScore(Long supplierId, SupplierCollaborationTask task) {
        // 根据协同任务完成情况更新供应商绩效
        SupplierPerformance latestPerformance = performanceRepository
            .findTopBySupplierIdOrderByPerformanceMonthDesc(supplierId)
            .orElse(null);
        
        if (latestPerformance != null) {
            // 协同表现转换为服务分数
            BigDecimal collaborationScore = calculateCollaborationScore(task);
            
            // 更新服务分数 (协同表现占服务分数的30%)
            BigDecimal currentServiceScore = latestPerformance.getServiceScore();
            BigDecimal serviceWeight = new BigDecimal("0.3");
            BigDecimal newServiceScore = currentServiceScore.multiply(BigDecimal.ONE.subtract(serviceWeight))
                .add(collaborationScore.multiply(serviceWeight));
            
            latestPerformance.setServiceScore(newServiceScore);
            performanceRepository.save(latestPerformance);
        }
    }
    
    /**
     * 计算协同分数
     */
    private BigDecimal calculateCollaborationScore(SupplierCollaborationTask task) {
        // 根据任务完成质量计算分数
        BigDecimal baseScore = new BigDecimal("80"); // 基础分
        
        // 按时完成加10分
        if (task.getActualCompletionDate() != null && 
            !task.getActualCompletionDate().isAfter(task.getTargetDate())) {
            baseScore = baseScore.add(new BigDecimal("10"));
        }
        
        // 有最终结果加5分
        if (StringUtils.hasText(task.getFinalResults())) {
            baseScore = baseScore.add(new BigDecimal("5"));
        }
        
        // 质量评价
        if (StringUtils.hasText(task.getProgressReport())) {
            String progressReport = task.getProgressReport().toLowerCase();
            if (progressReport.contains("excellent") || progressReport.contains("outstanding")) {
                baseScore = baseScore.add(new BigDecimal("5"));
            } else if (progressReport.contains("good") || progressReport.contains("satisfactory")) {
                baseScore = baseScore.add(new BigDecimal("3"));
            }
        }
        
        return baseScore.min(new BigDecimal("100")); // 最高100分
    }
}
\`\`\`

## 3. 技术实现规范

### 3.1 数据库设计

#### 3.1.1 核心表结构
\`\`\`sql
-- 供应商表
CREATE TABLE qms_supplier (
    id BIGSERIAL PRIMARY KEY,
    supplier_name VARCHAR(200) NOT NULL,
    supplier_code VARCHAR(50) NOT NULL UNIQUE,
    supplier_type VARCHAR(50),
    legal_representative VARCHAR(50),
    registration_number VARCHAR(100),
    address VARCHAR(200),
    postal_code VARCHAR(20),
    contact_person VARCHAR(50),
    contact_phone VARCHAR(20),
    contact_email VARCHAR(100),
    website VARCHAR(50),
    business_scope TEXT NOT NULL,
    established_date DATE NOT NULL,
    company_profile TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    registration_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    current_rating VARCHAR(10),
    last_rating_update TIMESTAMP,
    created_by BIGINT NOT NULL,
    updated_by BIGINT,
    FOREIGN KEY (created_by) REFERENCES qms_user(id),
    FOREIGN KEY (updated_by) REFERENCES qms_user(id)
);

-- 供应商分类表
CREATE TABLE qms_supplier_category (
    id BIGSERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL,
    description VARCHAR(500),
    parent_id BIGINT,
    level INTEGER NOT NULL,
    sort_order INTEGER NOT NULL,
    active BOOLEAN NOT NULL DEFAULT true,
    category_type VARCHAR(50) NOT NULL,
    risk_level VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES qms_supplier_category(id)
);

-- 供应商分类关联表
CREATE TABLE qms_supplier_category_relation (
    supplier_id BIGINT NOT NULL,
    category_id BIGINT NOT NULL,
    PRIMARY KEY (supplier_id, category_id),
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id),
    FOREIGN KEY (category_id) REFERENCES qms_supplier_category(id)
);

-- 供应商联系人表
CREATE TABLE qms_supplier_contact (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    contact_name VARCHAR(50) NOT NULL,
    position VARCHAR(50),
    phone VARCHAR(20),
    email VARCHAR(100),
    contact_type VARCHAR(20) NOT NULL,
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id)
);

-- 供应商证书表
CREATE TABLE qms_supplier_certificate (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    certificate_name VARCHAR(100) NOT NULL,
    certificate_number VARCHAR(50) NOT NULL,
    certificate_type VARCHAR(50) NOT NULL,
    issue_date DATE NOT NULL,
    expiry_date DATE NOT NULL,
    issuing_authority VARCHAR(100) NOT NULL,
    certificate_url VARCHAR(500),
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id)
);

-- 供应商评估表
CREATE TABLE qms_supplier_assessment (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    assessment_name VARCHAR(100) NOT NULL,
    assessment_type VARCHAR(20) NOT NULL,
    assessment_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PLANNED',
    assessor_id BIGINT NOT NULL,
    total_score DECIMAL(10,2),
    max_score DECIMAL(10,2),
    percentage DECIMAL(10,2),
    rating VARCHAR(10),
    overall_assessment TEXT,
    improvement_plan TEXT,
    next_assessment_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id),
    FOREIGN KEY (assessor_id) REFERENCES qms_user(id)
);

-- 供应商绩效表
CREATE TABLE qms_supplier_performance (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    performance_month DATE NOT NULL,
    quality_score DECIMAL(10,2) NOT NULL,
    delivery_score DECIMAL(10,2) NOT NULL,
    cost_score DECIMAL(10,2) NOT NULL,
    service_score DECIMAL(10,2) NOT NULL,
    technology_score DECIMAL(10,2) NOT NULL,
    management_score DECIMAL(10,2) NOT NULL,
    overall_score DECIMAL(10,2) NOT NULL,
    rating VARCHAR(10),
    performance_summary TEXT,
    improvement_areas TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id),
    UNIQUE(supplier_id, performance_month)
);

-- 供应商质量问题表
CREATE TABLE qms_supplier_quality_issue (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    issue_code VARCHAR(100) NOT NULL UNIQUE,
    issue_description TEXT NOT NULL,
    issue_type VARCHAR(20) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'OPEN',
    discovery_date DATE NOT NULL,
    target_resolution_date DATE,
    actual_resolution_date DATE,
    reported_by BIGINT,
    assigned_to BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    root_cause_analysis TEXT,
    corrective_action TEXT,
    preventive_action TEXT,
    verification_results TEXT,
    verified_by BIGINT,
    verification_date DATE,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id),
    FOREIGN KEY (reported_by) REFERENCES qms_user(id),
    FOREIGN KEY (assigned_to) REFERENCES qms_user(id),
    FOREIGN KEY (verified_by) REFERENCES qms_user(id)
);

-- 供应商风险评估表
CREATE TABLE qms_supplier_risk_assessment (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    assessment_name VARCHAR(100) NOT NULL,
    assessment_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'DRAFT',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    overall_risk_score DECIMAL(10,2),
    overall_risk_level VARCHAR(20) NOT NULL,
    assessment_type VARCHAR(20) NOT NULL,
    risk_summary TEXT,
    risk_mitigation_plan TEXT,
    next_assessment_date DATE,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id)
);

-- 供应商协同任务表
CREATE TABLE qms_supplier_collaboration_task (
    id BIGSERIAL PRIMARY KEY,
    supplier_id BIGINT NOT NULL,
    task_code VARCHAR(100) NOT NULL UNIQUE,
    task_title VARCHAR(200) NOT NULL,
    task_type VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    start_date DATE NOT NULL,
    target_date DATE,
    actual_completion_date DATE,
    task_description TEXT NOT NULL,
    deliverables TEXT NOT NULL,
    collaboration_plan TEXT,
    progress_report TEXT,
    final_results TEXT,
    initiator_id BIGINT NOT NULL,
    supplier_contact_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES qms_supplier(id),
    FOREIGN KEY (initiator_id) REFERENCES qms_user(id),
    FOREIGN KEY (supplier_contact_id) REFERENCES qms_user(id)
);

-- 供应商协同会议表
CREATE TABLE qms_supplier_meeting (
    id BIGSERIAL PRIMARY KEY,
    task_id BIGINT NOT NULL,
    meeting_title VARCHAR(200) NOT NULL,
    meeting_date DATE NOT NULL,
    meeting_time TIME NOT NULL,
    duration_minutes INTEGER,
    meeting_location VARCHAR(200),
    meeting_type VARCHAR(50),
    meeting_agenda TEXT,
    participants TEXT,
    organizer_id BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'SCHEDULED',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES qms_supplier_collaboration_task(id),
    FOREIGN KEY (organizer_id) REFERENCES qms_user(id)
);
\`\`\`

### 3.2 API接口规范

#### 3.2.1 供应商管理API
\`\`\`java
@RestController
@RequestMapping("/api/suppliers")
@Tag(name = "供应商管理", description = "供应商的增删改查管理")
@RequiredArgsConstructor
public class SupplierController {
    
    private final SupplierService supplierService;
    private final SupplierSearchService searchService;
    
    /**
     * 创建供应商
     */
    @PostMapping
    @Operation(summary = "创建新供应商")
    @PreAuthorize("hasRole('SUPPLIER_CREATE')")
    public ResponseEntity<SupplierDTO> createSupplier(
            @Valid @RequestBody SupplierCreateDTO dto,
            @RequestParam(value = "files", required = false) MultipartFile[] files) {
        SupplierDTO result = supplierService.createSupplier(dto, files);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
    
    /**
     * 更新供应商信息
     */
    @PutMapping("/{id}")
    @Operation(summary = "更新供应商信息")
    @PreAuthorize("hasRole('SUPPLIER_UPDATE')")
    public ResponseEntity<SupplierDTO> updateSupplier(
            @PathVariable Long id,
            @Valid @RequestBody SupplierUpdateDTO dto) {
        SupplierDTO result = supplierService.updateSupplier(id, dto);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 获取供应商详情
     */
    @GetMapping("/{id}")
    @Operation(summary = "获取供应商详情")
    public ResponseEntity<SupplierDetailDTO> getSupplier(@PathVariable Long id) {
        SupplierDetailDTO result = supplierService.getSupplierDetail(id);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 搜索供应商
     */
    @GetMapping("/search")
    @Operation(summary = "搜索供应商")
    public ResponseEntity<Page<SupplierListDTO>> searchSuppliers(
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) Long categoryId,
            @RequestParam(required = false) SupplierStatus status,
            @RequestParam(required = false) String supplierType,
            @RequestParam(required = false) SupplierRating rating,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        SupplierSearchCriteria criteria = SupplierSearchCriteria.builder()
            .keyword(keyword)
            .categoryId(categoryId)
            .status(status)
            .supplierType(supplierType)
            .rating(rating)
            .build();
        
        Page<SupplierListDTO> result = searchService.searchSuppliers(criteria, PageRequest.of(page, size));
        return ResponseEntity.ok(result);
    }
    
    /**
     * 获取供应商分类树
     */
    @GetMapping("/categories/tree")
    @Operation(summary = "获取供应商分类树")
    public ResponseEntity<List<CategoryTreeNodeDTO>> getCategoryTree() {
        List<CategoryTreeNodeDTO> result = supplierService.getCategoryTree();
        return ResponseEntity.ok(result);
    }
    
    /**
     * 启用/禁用供应商
     */
    @PatchMapping("/{id}/status")
    @Operation(summary = "启用/禁用供应商")
    @PreAuthorize("hasRole('SUPPLIER_MANAGE')")
    public ResponseEntity<Void> updateSupplierStatus(
            @PathVariable Long id,
            @RequestParam SupplierStatus status) {
        supplierService.updateSupplierStatus(id, status);
        return ResponseEntity.ok().build();
    }
}
\`\`\`

#### 3.2.2 供应商评估API
\`\`\`java
@RestController
@RequestMapping("/api/supplier-assessments")
@Tag(name = "供应商评估", description = "供应商评估管理")
@RequiredArgsConstructor
public class SupplierAssessmentController {
    
    private final SupplierAssessmentService assessmentService;
    
    /**
     * 创建供应商评估
     */
    @PostMapping
    @Operation(summary = "创建供应商评估")
    @PreAuthorize("hasRole('ASSESSMENT_CREATE')")
    public ResponseEntity<SupplierAssessmentDTO> createAssessment(
            @Valid @RequestBody SupplierAssessmentCreateDTO dto) {
        SupplierAssessmentDTO result = assessmentService.createAssessment(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
    
    /**
     * 开始评估
     */
    @PostMapping("/{id}/start")
    @Operation(summary = "开始评估")
    @PreAuthorize("hasRole('ASSESSMENT_MANAGE')")
    public ResponseEntity<Void> startAssessment(@PathVariable Long id) {
        assessmentService.startAssessment(id);
        return ResponseEntity.ok().build();
    }
    
    /**
     * 提交评估结果
     */
    @PostMapping("/{id}/submit")
    @Operation(summary = "提交评估结果")
    @PreAuthorize("hasRole('ASSESSMENT_SUBMIT')")
    public ResponseEntity<Void> submitAssessment(
            @PathVariable Long id,
            @Valid @RequestBody AssessmentSubmitDTO dto) {
        assessmentService.submitAssessment(id, dto);
        return ResponseEntity.ok().build();
    }
    
    /**
     * 获取评估详情
     */
    @GetMapping("/{id}")
    @Operation(summary = "获取评估详情")
    public ResponseEntity<SupplierAssessmentDetailDTO> getAssessment(@PathVariable Long id) {
        SupplierAssessmentDetailDTO result = assessmentService.getAssessmentDetail(id);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 更新评估分数
     */
    @PostMapping("/{id}/criteria/{criteriaId}/score")
    @Operation(summary = "更新评估分数")
    @PreAuthorize("hasRole('ASSESSMENT_SCORE')")
    public ResponseEntity<Void> updateCriteriaScore(
            @PathVariable Long id,
            @PathVariable Long criteriaId,
            @Valid @RequestBody CriteriaScoreDTO dto) {
        assessmentService.updateCriteriaScore(id, criteriaId, dto.getScore(), dto.getComments());
        return ResponseEntity.ok().build();
    }
    
    /**
     * 添加评估发现
     */
    @PostMapping("/{id}/findings")
    @Operation(summary = "添加评估发现")
    @PreAuthorize("hasRole('ASSESSMENT_FINDING')")
    public ResponseEntity<FindingDTO> addFinding(
            @PathVariable Long id,
            @Valid @RequestBody FindingCreateDTO dto) {
        FindingDTO result = assessmentService.addFinding(id, dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
}
\`\`\`

#### 3.2.3 供应商绩效API
\`\`\`java
@RestController
@RequestMapping("/api/supplier-performance")
@Tag(name = "供应商绩效", description = "供应商绩效管理")
@RequiredArgsConstructor
public class SupplierPerformanceController {
    
    private final SupplierPerformanceService performanceService;
    
    /**
     * 记录供应商绩效
     */
    @PostMapping
    @Operation(summary = "记录供应商绩效")
    @PreAuthorize("hasRole('PERFORMANCE_RECORD')")
    public ResponseEntity<SupplierPerformanceDTO> recordPerformance(
            @Valid @RequestBody SupplierPerformanceDTO dto) {
        SupplierPerformanceDTO result = performanceService.recordPerformance(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
    
    /**
     * 获取供应商绩效详情
     */
    @GetMapping("/{supplierId}/monthly/{month}")
    @Operation(summary = "获取供应商月度绩效")
    public ResponseEntity<SupplierPerformanceDTO> getMonthlyPerformance(
            @PathVariable Long supplierId,
            @PathVariable @DateTimeFormat(pattern = "yyyy-MM") String month) {
        SupplierPerformanceDTO result = performanceService.getMonthlyPerformance(supplierId, month);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 获取绩效趋势分析
     */
    @GetMapping("/{supplierId}/trend")
    @Operation(summary = "获取绩效趋势分析")
    public ResponseEntity<PerformanceTrendDTO> getPerformanceTrend(
            @PathVariable Long supplierId,
            @RequestParam(defaultValue = "12") int months) {
        PerformanceTrendDTO result = performanceService.getPerformanceTrend(supplierId, months);
        return ResponseEntity.ok(result);
    }
    
    /**
     * 生成月度绩效报告
     */
    @PostMapping("/monthly-report")
    @Operation(summary = "生成月度绩效报告")
    @PreAuthorize("hasRole('PERFORMANCE_REPORT')")
    public ResponseEntity<Void> generateMonthlyReport(
            @RequestParam @DateTimeFormat(pattern = "yyyy-MM") String month) {
        LocalDate monthDate = LocalDate.parse(month + "-01");
        performanceService.generateMonthlyPerformanceReport(monthDate);
        return ResponseEntity.accepted().build();
    }
}
\`\`\`

### 3.3 前端界面设计

#### 3.3.1 供应商管理界面
\`\`\`vue
<!-- 供应商管理主界面 -->
<template>
  <div class="supplier-management">
    <!-- 搜索栏 -->
    <div class="search-bar">
      <el-input
        v-model="searchForm.keyword"
        placeholder="搜索供应商名称、编号、联系人..."
        prefix-icon="Search"
        @keyup.enter="handleSearch"
      />
      <el-button type="primary" @click="handleSearch">搜索</el-button>
      <el-button @click="showAdvancedSearch = true">高级搜索</el-button>
      <el-button type="success" @click="showCreateDialog = true">新增供应商</el-button>
    </div>
    
    <!-- 分类筛选 -->
    <div class="category-filter">
      <el-radio-group v-model="selectedCategory" @change="handleCategoryChange">
        <el-radio-button label="">全部</el-radio-button>
        <el-radio-button 
          v-for="category in categories" 
          :key="category.id" 
          :label="category.id"
        >
          {{ category.categoryName }}
        </el-radio-button>
      </el-radio-group>
    </div>
    
    <!-- 状态筛选 -->
    <div class="status-filter">
      <el-select v-model="searchForm.status" placeholder="选择状态" clearable @change="handleSearch">
        <el-option label="活跃" value="ACTIVE" />
        <el-option label="非活跃" value="INACTIVE" />
        <el-option label="暂停" value="SUSPENDED" />
      </el-select>
      <el-select v-model="searchForm.supplierType" placeholder="供应商类型" clearable @change="handleSearch">
        <el-option label="制造商" value="MANUFACTURER" />
        <el-option label="经销商" value="DISTRIBUTOR" />
        <el-option label="服务商" value="SERVICE_PROVIDER" />
      </el-select>
      <el-select v-model="searchForm.rating" placeholder="评级" clearable @change="handleSearch">
        <el-option label="A级" value="A" />
        <el-option label="B级" value="B" />
        <el-option label="C级" value="C" />
        <el-option label="D级" value="D" />
      </el-select>
    </div>
    
    <!-- 供应商列表 -->
    <div class="supplier-list">
      <div v-for="supplier in supplierList" :key="supplier.id" class="supplier-card">
        <div class="supplier-header">
          <div class="supplier-info">
            <h3>{{ supplier.supplierName }}</h3>
            <span class="supplier-code">{{ supplier.supplierCode }}</span>
            <span :class="['status-badge', supplier.status.toLowerCase()]">
              {{ getStatusText(supplier.status) }}
            </span>
            <span :class="['rating-badge', supplier.currentRating?.toLowerCase()]">
              {{ getRatingText(supplier.currentRating) }}
            </span>
          </div>
          <div class="supplier-type">
            <el-tag size="small">{{ getSupplierTypeText(supplier.supplierType) }}</el-tag>
          </div>
        </div>
        
        <div class="supplier-content">
          <div class="supplier-meta">
            <p><strong>联系人:</strong> {{ supplier.contactPerson }}</p>
            <p><strong>电话:</strong> {{ supplier.contactPhone }}</p>
            <p><strong>邮箱:</strong> {{ supplier.contactEmail }}</p>
            <p><strong>业务范围:</strong> {{ supplier.businessScope }}</p>
          </div>
          
          <div class="supplier-stats">
            <div class="stat-item">
              <span class="stat-label">绩效分数</span>
              <span class="stat-value">{{ supplier.performanceStats?.overallScore || '-' }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">质量指数</span>
              <span class="stat-value">{{ supplier.performanceStats?.qualityIndex || '-' }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">风险等级</span>
              <span :class="['risk-level', supplier.riskAssessment?.overallRiskLevel?.toLowerCase()]">
                {{ getRiskLevelText(supplier.riskAssessment?.overallRiskLevel) }}
              </span>
            </div>
          </div>
        </div>
        
        <div class="supplier-actions">
          <el-button size="small" @click="viewSupplier(supplier)">查看详情</el-button>
          <el-button 
            v-if="canEdit(supplier)" 
            size="small" 
            type="primary" 
            @click="editSupplier(supplier)"
          >
            编辑
          </el-button>
          <el-button 
            v-if="canAssess(supplier)" 
            size="small" 
            type="success" 
            @click="assessSupplier(supplier)"
          >
            评估
          </el-button>
          <el-dropdown @command="(command) => handleMoreAction(command, supplier)">
            <el-button size="small">
              更多<el-icon><arrow-down /></el-icon>
            </el-button>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="performance">绩效分析</el-dropdown-item>
                <el-dropdown-item command="risk">风险评估</el-dropdown-item>
                <el-dropdown-item command="collaboration">协同管理</el-dropdown-item>
                <el-dropdown-item command="issues">质量问题</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </div>
    </div>
    
    <!-- 分页 -->
    <div class="pagination">
      <el-pagination
        v-model:current-page="pagination.page"
        v-model:page-size="pagination.size"
        :total="pagination.total"
        @current-change="handlePageChange"
        @size-change="handleSizeChange"
      />
    </div>
    
    <!-- 创建供应商对话框 -->
    <el-dialog v-model="showCreateDialog" title="创建供应商" width="80%">
      <SupplierCreateForm @submit="handleCreateSubmit" @cancel="showCreateDialog = false" />
    </el-dialog>
    
    <!-- 高级搜索对话框 -->
    <el-dialog v-model="showAdvancedSearch" title="高级搜索" width="60%">
      <SupplierAdvancedSearch 
        :model="searchForm" 
        @search="handleAdvancedSearch"
        @reset="handleAdvancedReset"
      />
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import { Search, ArrowDown } from '@element-plus/icons-vue'
import SupplierCreateForm from './components/SupplierCreateForm.vue'
import SupplierAdvancedSearch from './components/SupplierAdvancedSearch.vue'

const searchForm = reactive({
  keyword: '',
  status: '',
  supplierType: '',
  rating: '',
  categoryId: ''
})

const selectedCategory = ref('')
const categories = ref([])
const supplierList = ref([])
const pagination = reactive({
  page: 1,
  size: 20,
  total: 0
})

const showCreateDialog = ref(false)
const showAdvancedSearch = ref(false)

// 搜索供应商
const handleSearch = async () => {
  try {
    const params = {
      ...searchForm,
      categoryId: selectedCategory.value,
      page: pagination.page - 1,
      size: pagination.size
    }
    
    const response = await api.suppliers.search(params)
    supplierList.value = response.data.content
    pagination.total = response.data.totalElements
  } catch (error) {
    ElMessage.error('搜索供应商失败')
  }
}

// 查看供应商详情
const viewSupplier = (supplier) => {
  router.push(\`/suppliers/\${supplier.id}\`)
}

// 编辑供应商
const editSupplier = (supplier) => {
  router.push(\`/suppliers/\${supplier.id}/edit\`)
}

// 评估供应商
const assessSupplier = (supplier) => {
  router.push(\`/suppliers/\${supplier.id}/assessment\`)
}

// 处理更多操作
const handleMoreAction = (command, supplier) => {
  switch (command) {
    case 'performance':
      router.push(\`/suppliers/\${supplier.id}/performance\`)
      break
    case 'risk':
      router.push(\`/suppliers/\${supplier.id}/risk\`)
      break
    case 'collaboration':
      router.push(\`/suppliers/\${supplier.id}/collaboration\`)
      break
    case 'issues':
      router.push(\`/suppliers/\${supplier.id}/issues\`)
      break
  }
}

// 创建供应商提交
const handleCreateSubmit = async (formData) => {
  try {
    await api.suppliers.create(formData)
    ElMessage.success('供应商创建成功')
    showCreateDialog.value = false
    handleSearch()
  } catch (error) {
    ElMessage.error('创建供应商失败')
  }
}

// 高级搜索
const handleAdvancedSearch = (searchParams) => {
  Object.assign(searchForm, searchParams)
  handleSearch()
}

// 高级搜索重置
const handleAdvancedReset = () => {
  Object.keys(searchForm).forEach(key => {
    searchForm[key] = ''
  })
  selectedCategory.value = ''
  handleSearch()
}
<\/script>
\`\`\`

#### 3.3.2 供应商评估界面
\`\`\`vue
<!-- 供应商评估界面 -->
<template>
  <div class="supplier-assessment">
    <!-- 评估概览 -->
    <div class="assessment-overview">
      <div class="overview-header">
        <h2>{{ assessment.assessmentName }}</h2>
        <div class="assessment-meta">
          <span :class="['status-badge', assessment.status.toLowerCase()]">
            {{ getStatusText(assessment.status) }}
          </span>
          <span class="assessment-date">
            评估日期: {{ formatDate(assessment.assessmentDate) }}
          </span>
          <span class="assessment-type">
            类型: {{ getAssessmentTypeText(assessment.assessmentType) }}
          </span>
        </div>
      </div>
      
      <div class="overview-stats">
        <div class="stat-card">
          <div class="stat-value">{{ assessment.percentage }}%</div>
          <div class="stat-label">完成度</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">{{ assessment.totalScore }}/{{ assessment.maxScore }}</div>
          <div class="stat-label">总分</div>
        </div>
        <div class="stat-card">
          <div :class="['stat-value', \`rating-\${assessment.rating?.toLowerCase()}\`]">
            {{ getRatingText(assessment.rating) }}
          </div>
          <div class="stat-label">评级</div>
        </div>
      </div>
    </div>
    
    <!-- 评估标准 -->
    <div class="assessment-criteria">
      <h3>评估标准</h3>
      <el-table :data="assessment.criteria" style="width: 100%">
        <el-table-column prop="criteriaName" label="标准名称" width="200" />
        <el-table-column prop="category" label="分类" width="120">
          <template #default="{ row }">
            <el-tag size="small">{{ getCategoryText(row.category) }}</el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="weight" label="权重" width="80" />
        <el-table-column prop="maxScore" label="满分" width="80" />
        <el-table-column prop="actualScore" label="得分" width="80">
          <template #default="{ row }">
            <el-input-number 
              v-if="canEditScore(row)" 
              v-model="row.actualScore" 
              :min="0" 
              :max="row.maxScore"
              @change="updateScore(row)"
            />
            <span v-else>{{ row.actualScore }}</span>
          </template>
        </el-table-column>
        <el-table-column prop="status" label="状态" width="100">
          <template #default="{ row }">
            <el-tag :type="getStatusType(row.status)">{{ getStatusText(row.status) }}</el-tag>
          </template>
        </el-table-column>
        <el-table-column label="操作">
          <template #default="{ row }">
            <el-button 
              v-if="row.status === 'NOT_STARTED'" 
              size="small" 
              @click="startCriteria(row)"
            >
              开始
            </el-button>
            <el-button 
              v-if="row.status === 'IN_PROGRESS'" 
              size="small" 
              type="primary" 
              @click="completeCriteria(row)"
            >
              完成
            </el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
    
    <!-- 评估发现 -->
    <div class="assessment-findings">
      <div class="findings-header">
        <h3>评估发现</h3>
        <el-button 
          v-if="canAddFinding" 
          type="primary" 
          size="small" 
          @click="showAddFindingDialog = true"
        >
          添加发现
        </el-button>
      </div>
      
      <div v-for="finding in assessment.findings" :key="finding.id" class="finding-item">
        <div class="finding-header">
          <span :class="['severity-badge', finding.severity.toLowerCase()]">
            {{ getSeverityText(finding.severity) }}
          </span>
          <span class="finding-status">
            {{ getStatusText(finding.status) }}
          </span>
        </div>
        <div class="finding-content">
          <p>{{ finding.findingDescription }}</p>
          <div v-if="finding.rootCauseAnalysis" class="finding-details">
            <h4>根本原因分析:</h4>
            <p>{{ finding.rootCauseAnalysis }}</p>
          </div>
          <div v-if="finding.correctiveAction" class="finding-details">
            <h4>纠正措施:</h4>
            <p>{{ finding.correctiveAction }}</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 总体评估 -->
    <div class="overall-assessment">
      <h3>总体评估</h3>
      <el-form :model="assessment" label-width="120px">
        <el-form-item label="总体评价">
          <el-input
            v-model="assessment.overallAssessment"
            type="textarea"
            :rows="4"
            placeholder="请输入总体评价..."
          />
        </el-form-item>
        <el-form-item label="改进计划">
          <el-input
            v-model="assessment.improvementPlan"
            type="textarea"
            :rows="4"
            placeholder="请输入改进计划..."
          />
        </el-form-item>
        <el-form-item label="下次评估日期">
          <el-date-picker
            v-model="assessment.nextAssessmentDate"
            type="date"
            placeholder="选择下次评估日期"
          />
        </el-form-item>
      </el-form>
    </div>
    
    <!-- 操作按钮 -->
    <div class="assessment-actions">
      <el-button @click="saveDraft">保存草稿</el-button>
      <el-button 
        v-if="canSubmit" 
        type="primary" 
        @click="submitAssessment"
      >
        提交评估
      </el-button>
    </div>
    
    <!-- 添加发现对话框 -->
    <el-dialog v-model="showAddFindingDialog" title="添加评估发现" width="60%">
      <FindingCreateForm @submit="handleAddFinding" @cancel="showAddFindingDialog = false" />
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, reactive, computed, onMounted } from 'vue'
import { ElMessage } from 'element-plus'

const assessment = ref({})
const showAddFindingDialog = ref(false)

// 权限检查
const canEditScore = (criteria) => {
  return assessment.value.status === 'IN_PROGRESS' && 
         criteria.status === 'IN_PROGRESS'
}

const canAddFinding = computed(() => {
  return assessment.value.status === 'IN_PROGRESS'
})

const canSubmit = computed(() => {
  return assessment.value.status === 'IN_PROGRESS' &&
         assessment.value.criteria.every(c => c.status === 'COMPLETED')
})

// 更新评估分数
const updateScore = async (criteria) => {
  try {
    await api.assessment.updateCriteriaScore(
      assessment.value.id, 
      criteria.id, 
      criteria.actualScore
    )
    ElMessage.success('分数更新成功')
  } catch (error) {
    ElMessage.error('分数更新失败')
  }
}

// 开始评估标准
const startCriteria = async (criteria) => {
  try {
    await api.assessment.startCriteria(assessment.value.id, criteria.id)
    criteria.status = 'IN_PROGRESS'
    ElMessage.success('标准评估已开始')
  } catch (error) {
    ElMessage.error('操作失败')
  }
}

// 完成评估标准
const completeCriteria = async (criteria) => {
  try {
    await api.assessment.completeCriteria(assessment.value.id, criteria.id)
    criteria.status = 'COMPLETED'
    ElMessage.success('标准评估已完成')
  } catch (error) {
    ElMessage.error('操作失败')
  }
}

// 添加评估发现
const handleAddFinding = async (findingData) => {
  try {
    await api.assessment.addFinding(assessment.value.id, findingData)
    showAddFindingDialog.value = false
    loadAssessmentDetail()
    ElMessage.success('评估发现已添加')
  } catch (error) {
    ElMessage.error('添加发现失败')
  }
}

// 保存草稿
const saveDraft = async () => {
  try {
    await api.assessment.saveDraft(assessment.value.id)
    ElMessage.success('草稿已保存')
  } catch (error) {
    ElMessage.error('保存草稿失败')
  }
}

// 提交评估
const submitAssessment = async () => {
  try {
    await api.assessment.submitAssessment(assessment.value.id, {
      overallAssessment: assessment.value.overallAssessment,
      improvementPlan: assessment.value.improvementPlan,
      nextAssessmentDate: assessment.value.nextAssessmentDate
    })
    ElMessage.success('评估已提交')
    router.push('/supplier-assessments')
  } catch (error) {
    ElMessage.error('提交评估失败')
  }
}
<\/script>
\`\`\`

## 4. 性能优化与扩展性

### 4.1 缓存策略
\`\`\`java
@Configuration
@EnableCaching
public class SupplierCacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .disableCachingNullValues()
            .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(redisConnectionFactory)
            .cacheDefaults(config)
            .withInitialCacheConfigurations(getCacheConfigurations())
            .build();
    }
    
    private Map<String, RedisCacheConfiguration> getCacheConfigurations() {
        Map<String, RedisCacheConfiguration> configMap = new HashMap<>();
        
        // 供应商详情缓存
        configMap.put("supplierDetails", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(2))
            .disableCachingNullValues());
        
        // 供应商分类树缓存
        configMap.put("supplierCategoryTree", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(6))
            .disableCachingNullValues());
        
        // 供应商绩效缓存
        configMap.put("supplierPerformance", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(12))
            .disableCachingNullValues());
        
        // 供应商风险缓存
        configMap.put("supplierRisk", RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .disableCachingNullValues());
        
        return configMap;
    }
}

@Service
@RequiredArgsConstructor
public class CachedSupplierService {
    
    private final SupplierRepository supplierRepository;
    private final CacheManager cacheManager;
    
    @Cacheable(value = "supplierDetails", key = "#id")
    public SupplierDTO getSupplierDTO(Long id) {
        Supplier supplier = supplierRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Supplier not found"));
        return convertToDTO(supplier);
    }
    
    @CacheEvict(value = "supplierDetails", key = "#id")
    public void updateSupplier(Long id, SupplierDTO dto) {
        // 更新供应商逻辑
    }
    
    @Cacheable(value = "supplierCategoryTree", key = "'all'")
    public List<CategoryTreeNodeDTO> getCategoryTree() {
        List<SupplierCategory> categories = categoryRepository.findByActiveTrueOrderBySortOrderAsc();
        return buildCategoryTree(categories);
    }
}
\`\`\`

### 4.2 数据分片优化
\`\`\`java
@Configuration
@EnableJpaRepositories(repositoryBaseClass = BaseRepositoryImpl.class)
public class SupplierDatabaseConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
        return transactionManager;
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.shunfu.qms.entity.supplier");
        em.setPersistenceUnitName("supplierPersistenceUnit");
        
        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);
        
        Properties properties = new Properties();
        properties.put("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");
        properties.put("hibernate.format_sql", true);
        properties.put("hibernate.use_sql_comments", true);
        properties.put("hibernate.jdbc.batch_size", 50);
        properties.put("hibernate.order_inserts", true);
        properties.put("hibernate.order_updates", true);
        properties.put("hibernate.jdbc.fetch_size", 100);
        
        em.setJpaProperties(properties);
        
        return em;
    }
}

@Repository
public interface SupplierRepository extends BaseRepository<Supplier, Long> {
    
    @Query("SELECT s FROM Supplier s WHERE s.status = :status")
    Page<Supplier> findByStatus(@Param("status") SupplierStatus status, Pageable pageable);
    
    @Query(value = "SELECT * FROM qms_supplier ORDER BY id %s", nativeQuery = true)
    Page<Supplier> findAllWithSharding(@Param("shardingKey") String shardingKey, Pageable pageable);
}
\`\`\`

### 4.3 消息队列处理
\`\`\`java
@Configuration
@EnableRabbit
public class SupplierRabbitConfig {
    
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(new Jackson2JsonMessageConverter());
        template.setMandatory(true);
        return template;
    }
    
    @Bean
    public SupplierEventQueue supplierEventQueue() {
        return new SupplierEventQueue();
    }
}

@Component
public class SupplierEventQueue {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendSupplierCreatedEvent(Supplier supplier) {
        SupplierCreatedEvent event = new SupplierCreatedEvent(supplier);
        rabbitTemplate.convertAndSend("supplier.events", "supplier.created", event);
    }
    
    public void sendSupplierUpdatedEvent(Supplier supplier) {
        SupplierUpdatedEvent event = new SupplierUpdatedEvent(supplier);
        rabbitTemplate.convertAndSend("supplier.events", "supplier.updated", event);
    }
    
    public void sendAssessmentCompletedEvent(SupplierAssessment assessment) {
        AssessmentCompletedEvent event = new AssessmentCompletedEvent(assessment);
        rabbitTemplate.convertAndSend("supplier.events", "assessment.completed", event);
    }
    
    public void sendPerformanceRecordedEvent(SupplierPerformance performance) {
        PerformanceRecordedEvent event = new PerformanceRecordedEvent(performance);
        rabbitTemplate.convertAndSend("supplier.events", "performance.recorded", event);
    }
}

@Component
@RabbitListener(queues = "supplier.events")
public class SupplierEventConsumer {
    
    private final SupplierNotificationService notificationService;
    private final SupplierRiskService riskService;
    private final SupplierPerformanceService performanceService;
    
    @RabbitHandler
    public void handleSupplierCreated(SupplierCreatedEvent event) {
        // 发送创建通知
        notificationService.sendSupplierCreatedNotification(event.getSupplier());
        
        // 触发风险评估
        riskService.triggerInitialRiskAssessment(event.getSupplier().getId());
    }
    
    @RabbitHandler
    public void handleSupplierUpdated(SupplierUpdatedEvent event) {
        // 更新相关缓存
        performanceService.updateSupplierPerformanceCache(event.getSupplier().getId());
    }
    
    @RabbitHandler
    public void handleAssessmentCompleted(AssessmentCompletedEvent event) {
        // 更新供应商评级
        performanceService.updateSupplierRating(event.getAssessment().getSupplier().getId(), 
            event.getAssessment().getRating());
    }
    
    @RabbitHandler
    public void handlePerformanceRecorded(PerformanceRecordedEvent event) {
        // 触发绩效分析
        performanceService.analyzePerformanceTrends(event.getPerformance().getSupplier().getId());
    }
}
\`\`\`

## 5. 安全与合规

### 5.1 数据安全
\`\`\`java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SupplierSecurityConfig {
    
    @Bean
    public SecurityFilterChain supplierSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            .securityMatcher("/api/suppliers/**")
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/suppliers/search").permitAll()
                .requestMatchers("/api/suppliers/{id}").hasAnyRole("SUPPLIER_READ", "ADMIN")
                .requestMatchers("/api/suppliers/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .addFilterBefore(supplierAuthorizationFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public SupplierAuthorizationFilter supplierAuthorizationFilter() {
        return new SupplierAuthorizationFilter();
    }
}

@Component
public class SupplierAuthorizationFilter extends OncePerRequestFilter {
    
    private final SupplierPermissionService permissionService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                 HttpServletResponse response, 
                                 FilterChain filterChain) throws ServletException, IOException {
        
        String requestURI = request.getRequestURI();
        Long supplierId = extractSupplierIdFromUri(requestURI);
        
        if (supplierId != null && requiresSupplierAuthorization(requestURI)) {
            String permission = determineRequiredPermission(requestURI, request.getMethod());
            
            if (!permissionService.checkSupplierPermission(supplierId, permission)) {
                response.sendError(HttpStatus.FORBIDDEN.value(), "Access denied");
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private Long extractSupplierIdFromUri(String uri) {
        try {
            Pattern pattern = Pattern.compile("/api/suppliers/(\\\\d+)");
            Matcher matcher = pattern.matcher(uri);
            if (matcher.find()) {
                return Long.parseLong(matcher.group(1));
            }
        } catch (Exception e) {
            log.warn("Failed to extract supplier ID from URI: {}", uri, e);
        }
        return null;
    }
}
\`\`\`

### 5.2 审计日志
\`\`\`java
@Aspect
@Component
public class SupplierAuditAspect {
    
    private final AuditLogRepository auditLogRepository;
    
    @AfterReturning("execution(* com.shunfu.qms.service.*.*Supplier(..)) && args(supplierId,..)")
    public void auditSupplierOperation(JoinPoint joinPoint, Long supplierId) {
        String operation = joinPoint.getSignature().getName();
        String action = convertOperationToAction(operation);
        
        auditLogRepository.save(SystemAuditLog.builder()
            .module("SUPPLIER")
            .action(action)
            .userId(SecurityUtils.getCurrentUserId())
            .userName(SecurityUtils.getCurrentUserName())
            .userEmail(SecurityUtils.getCurrentUserEmail())
            .ipAddress(getClientIpAddress())
            .userAgent(getUserAgent())
            .timestamp(LocalDateTime.now())
            .details(Map.of(
                "operation", operation,
                "supplierId", supplierId,
                "method", joinPoint.getSignature().toShortString(),
                "args", joinPoint.getArgs()
            ))
            .sessionId(getSessionId())
            .build());
    }
    
    private String convertOperationToAction(String operation) {
        switch (operation) {
            case "createSupplier":
                return "CREATE";
            case "updateSupplier":
                return "UPDATE";
            case "deleteSupplier":
                return "DELETE";
            case "approveSupplier":
                return "APPROVE";
            case "suspendSupplier":
                return "SUSPEND";
            default:
                return "OTHER";
        }
    }
}
\`\`\`

## 6. 部署与运维

### 6.1 Docker部署配置
\`\`\`dockerfile
# Dockerfile for Supplier Service
FROM openjdk:17-jre-slim

WORKDIR /app

COPY target/qms-supplier-service-0.0.1-SNAPSHOT.jar app.jar

EXPOSE 8082

ENV JAVA_OPTS="-Xmx2g -Xms1g"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
\`\`\`

\`\`\`yaml
# docker-compose.yml for Supplier Service
version: '3.8'

services:
  supplier-service:
    build: ./supplier-service
    ports:
      - "8082:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/qms_supplier
      - SPRING_REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
    depends_on:
      - postgres
      - redis
      - rabbitmq
  
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=qms_supplier
      - POSTGRES_USER=qms
      - POSTGRES_PASSWORD=qms123
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    ports:
      - "6380:6379"
  
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=guest
      - RABBITMQ_DEFAULT_PASS=guest

volumes:
  postgres_data:
\`\`\`

### 6.2 监控与告警
\`\`\`yaml
# prometheus-supplier-service.yml
groups:
  - name: supplier_service
    interval: 15s
    rules:
      - alert: SupplierServiceHighErrorRate
        expr: rate(http_server_requests_total{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Supplier Service high error rate"
          description: "Error rate is {{ $value }} errors per second"
      
      - alert: SupplierAssessmentPendingTooLong
        expr: time() - qms_supplier_assessment_created_timestamp > 86400 * 7
        for: 1d
        labels:
          severity: warning
        annotations:
          summary: "Supplier assessment pending too long"
          description: "Assessment {{ $labels.assessment_id }} has been pending for {{ $value }} seconds"
      
      - alert: SupplierCertificateExpiringSoon
        expr: qms_supplier_certificate_expiry_date - time() < 86400 * 30
        for: 1d
        labels:
          severity: warning
        annotations:
          summary: "Supplier certificate expiring soon"
          description: "Certificate {{ $labels.certificate_id }} expires in {{ $value }} seconds"
\`\`\`

## 7. 测试策略

### 7.1 单元测试
\`\`\`java
@ExtendWith(MockitoExtension.class)
class SupplierServiceTest {
    
    @Mock
    private SupplierRepository supplierRepository;
    
    @Mock
    private SupplierCategoryRepository categoryRepository;
    
    @Mock
    private FileStorageService fileStorageService;
    
    @InjectMocks
    private SupplierService supplierService;
    
    @Test
    void createSupplier_shouldCreateSupplierSuccessfully() {
        // Arrange
        SupplierCreateDTO dto = new SupplierCreateDTO();
        dto.setSupplierName("Test Supplier");
        dto.setSupplierCode("TEST-001");
        dto.setSupplierType("MANUFACTURER");
        
        SupplierCategory category = new SupplierCategory();
        category.setId(1L);
        
        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));
        when(fileStorageService.uploadDocument(any(), any(), any())).thenReturn("http://test.com/test.pdf");
        
        // Act
        SupplierDTO result = supplierService.createSupplier(dto, null);
        
        // Assert
        assertNotNull(result);
        assertEquals("Test Supplier", result.getSupplierName());
        assertEquals("MANUFACTURER", result.getSupplierType());
    }
    
    @Test
    void createSupplier_shouldThrowExceptionWhenCategoryNotFound() {
        // Arrange
        SupplierCreateDTO dto = new SupplierCreateDTO();
        dto.setCategoryId(1L);
        
        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
        
        // Act & Assert
        assertThrows(EntityNotFoundException.class, () -> {
            supplierService.createSupplier(dto, null);
        });
    }
}
\`\`\`

### 7.2 集成测试
\`\`\`java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class SupplierControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private SupplierRepository supplierRepository;
    
    @Test
    void createSupplier_shouldCreateSupplier() {
        // Arrange
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("supplierName", "Integration Test Supplier");
        body.add("supplierCode", "IT-001");
        body.add("supplierType", "MANUFACTURER");
        body.add("categoryId", "1");
        
        // Act
        ResponseEntity<SupplierDTO> response = restTemplate.postForEntity(
            "/api/suppliers", 
            body, 
            SupplierDTO.class
        );
        
        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("Integration Test Supplier", response.getBody().getSupplierName());
    }
    
    @Test
    void searchSuppliers_shouldReturnSuppliers() {
        // Arrange
        Supplier supplier = new Supplier();
        supplier.setSupplierName("Test Supplier");
        supplier.setSupplierCode("TEST-001");
        supplier.setStatus(SupplierStatus.ACTIVE);
        supplierRepository.save(supplier);
        
        // Act
        ResponseEntity<Page<SupplierListDTO>> response = restTemplate.getForEntity(
            "/api/suppliers/search?keyword=Test", 
            new ParameterizedTypeReference<Page<SupplierListDTO>>() {}
        );
        
        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody().getContent().size() > 0);
    }
}
\`\`\`

## 8. 项目总结

### 8.1 实现要点总结
1. **完整的供应商生命周期管理**: 从注册、评估、绩效监控到风险管控的全流程
2. **多维度评估体系**: 质量、交付、成本、服务、技术、管理的综合评估
3. **智能绩效监控**: 实时绩效跟踪和趋势分析
4. **风险管控机制**: 多层次风险评估和缓解措施管理
5. **协同工作管理**: 供需双方的协作改进平台
6. **数据可视化**: 丰富的图表和报表展示
7. **权限安全控制**: 细粒度的权限管理和数据安全
8. **高性能优化**: 缓存、分片、异步处理等性能优化

### 8.2 技术特色
- **微服务架构**: 独立的供应商管理服务
- **多数据库架构**: PostgreSQL + MongoDB + InfluxDB
- **消息驱动架构**: RabbitMQ事件驱动机制
- **实时监控**: Prometheus + Grafana监控体系
- **容器化部署**: Docker + Kubernetes支持
- **智能分析**: 基于历史数据的趋势分析和预测

### 8.3 业务价值
为舜富精密压铸提供:
1. 完整的供应商质量管理体系
2. 量化的供应商绩效评估工具
3. 智能化的风险预警机制
4. 高效的供需协同平台
5. 数据驱动的供应商决策支持

---

**供应商管理模块详细实现规范完成。接下来继续实现知识库管理模块详细规范。**`,ae=`# 舜富QMS系统 - 质量检验模块详细实现

## 1. 质量检验模块总览

### 1.1 检验模块架构设计

\`\`\`
┌─────────────────────────────────────────────────────────────┐
│               质量检验模块 - 微服务架构                       │
├─────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                 检验业务流程层                            │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │ IQC检验      │ │ IPQC检验      │ │ FQC/OQC检验 │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                 检验管理服务层                           │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │检验计划     │ │检验执行     │ │检验判定     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                 抽样算法服务层                           │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │抽样标准     │ │抽样计算     │ │抽样调整     │       │  │
│  │  │Service      │ │Service      │ │Service      │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                 数据持久化层                             │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │  │
│  │  │IQC检验记录   │ │IPQC检验记录   │ │FQC/OQC检验记录│      │  │
│  │  │PostgreSQL  │ │PostgreSQL   │ │PostgreSQL   │       │  │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2 检验业务流程概览

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                     质量检验业务流程图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ 检验计划  │───▶│ 检验执行  │───▶│ 结果判定  │                   │
│  └──────────┘    └──────────┘    └────┬─────┘                   │
│                                       │                          │
│                          ┌────────────┴────────────┐            │
│                          ▼                         ▼            │
│                   ┌──────────┐              ┌──────────┐          │
│                   │ 合格接收  │              │ 不合格品  │          │
│                   └────┬─────┘              └────┬─────┘          │
│                        │                        │                │
│                        └──────────┬─────────────┘                │
│                                   ▼                              │
│                            ┌──────────┐                          │
│                            │ 质量追溯  │                          │
│                            └────┬─────┘                          │
│                                   ▼                              │
│                            ┌──────────┐                          │
│                            │ 客户交付  │                          │
│                            └──────────┘                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

---

## 2. IQC来料检验模块详细实现

### 2.1 IQC检验流程

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                         IQC检验流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ 来料通知  │───▶│ 检验计划  │───▶│ 现场取样  │                   │
│  └──────────┘    └──────────┘    └──────────┘                   │
│                               │                                │
│                  ┌────────────┴────────────┐                   │
│                  ▼                         ▼                   │
│           ┌──────────┐              ┌──────────┐               │
│           │ 检验项目  │              │ 样品准备  │               │
│           └────┬─────┘              └──────────┘               │
│                 │                                             │
│           ┌────┴────┐                                          │
│           ▼         ▼                                          │
│  ┌──────────┐  ┌──────────┐                                    │
│  │ 尺寸测量  │  │ 材质分析  │                                    │
│  └──────────┘  └──────────┘                                    │
│                  │                                             │
│           ┌──────┴──────┐                                      │
│           ▼              ▼                                      │
│  ┌──────────┐  ┌──────────┐                                    │
│  │ 功能测试  │  │ 外观检验  │                                    │
│  └──────────┘  └──────────┘                                    │
│                  │                                             │
│           ┌──────┴──────┐                                      │
│           ▼              ▼                                      │
│  ┌──────────┐  ┌──────────┐                                    │
│  │ 记录数据  │  │ 结果判定  │                                    │
│  └────┬─────┘  └──────────┘                                    │
│       │                                                      │
│       ▼                                                      │
│  ┌──────────┐                                                │
│  │ 系统记录  │                                                │
│  └──────────┘                                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 2.2 IQC检验核心类设计

\`\`\`java
/**
 * IQC检验记录实体
 */
@Data
@Entity
@Table(name = "iqc_inspection_record")
@DynamicUpdate
public class IQCInspectionRecord {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "inspection_id")
    private Long inspectionId;
    
    @Column(name = "inspection_lot_number", unique = true, nullable = false)
    private String inspectionLotNumber;
    
    @Column(name = "material_id", nullable = false)
    private Long materialId;
    
    @Column(name = "material_code", nullable = false)
    private String materialCode;
    
    @Column(name = "material_name", nullable = false)
    private String materialName;
    
    @Column(name = "supplier_id", nullable = false)
    private Long supplierId;
    
    @Column(name = "supplier_name", nullable = false)
    private String supplierName;
    
    @Column(name = "inspection_type", nullable = false)
    private IQCInspectionType inspectionType; // FIRST_INSPECTION, ROUTINE_INSPECTION
    
    @Column(name = "batch_number", nullable = false)
    private String batchNumber;
    
    @Column(name = "arrival_date", nullable = false)
    private LocalDate arrivalDate;
    
    @Column(name = "inspection_date", nullable = false)
    private LocalDate inspectionDate;
    
    @Column(name = "quantity_received", nullable = false)
    private Integer quantityReceived;
    
    @Column(name = "sample_size", nullable = false)
    private Integer sampleSize;
    
    @Column(name = "inspected_quantity")
    private Integer inspectedQuantity;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "inspection_result", nullable = false)
    private InspectionResult inspectionResult; // ACCEPT, REJECT, CONDITIONAL_ACCEPT
    
    @Column(name = "inspector_id", nullable = false)
    private Long inspectorId;
    
    @Column(name = "inspector_name", nullable = false)
    private String inspectorName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "sampling_standard")
    private SamplingStandard samplingStandard; // MIL_STD_105E, ISO_2859_1, GB_T_2828_1
    
    @Column(name = "inspection_level", nullable = false)
    private String inspectionLevel; // NORMAL, TIGHTENED, RELAXED
    
    @Column(name = "aql_value", nullable = false)
    private String aqlValue;
    
    @Column(name = "quantity_nonconforming")
    private Integer quantityNonconforming;
    
    @Column(name = "nonconforming_rate")
    private Double nonconformingRate;
    
    @Type(type = "json")
    @Column(name = "defect_details", columnDefinition = "jsonb")
    private List<DefectDetail> defectDetails;
    
    @Type(type = "json")
    @Column(name = "test_results", columnDefinition = "jsonb")
    private List<TestResult> testResults;
    
    @Type(type = "json")
    @Column(name = "attachments", columnDefinition = "jsonb")
    private List<Attachment> attachments;
    
    @Column(name = "inspection_notes", columnDefinition = "TEXT")
    private String inspectionNotes;
    
    @Column(name = "next_inspection_plan", columnDefinition = "TEXT")
    private String nextInspectionPlan;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private IQCRecordStatus status; // PLANNED, IN_PROGRESS, COMPLETED, APPROVED
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "created_time", nullable = false, updatable = false)
    private LocalDateTime createdTime;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @Column(name = "updated_time")
    private LocalDateTime updatedTime;
    
    // 关联关系
    @OneToMany(mappedBy = "iqcRecord", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<IQCInspectionItem> inspectionItems = new ArrayList<>();
    
    @OneToMany(mappedBy = "iqcRecord", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<IQCNonconformingRecord> nonconformingRecords = new ArrayList<>();
}

/**
 * IQC检验项目实体
 */
@Data
@Entity
@Table(name = "iqc_inspection_item")
public class IQCInspectionItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "item_id")
    private Long itemId;
    
    @Column(name = "inspection_id", nullable = false)
    private Long inspectionId;
    
    @Column(name = "item_code", nullable = false)
    private String itemCode;
    
    @Column(name = "item_name", nullable = false)
    private String itemName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "inspection_method", nullable = false)
    private InspectionMethod inspectionMethod; // DIMENSIONAL_CHECK, MATERIAL_ANALYSIS, FUNCTIONAL_TEST
    
    @Column(name = "specification_min")
    private String specificationMin;
    
    @Column(name = "specification_max")
    private String specificationMax;
    
    @Column(name = "specification_unit")
    private String specificationUnit;
    
    @Column(name = "measured_value")
    private String measuredValue;
    
    @Column(name = "deviation")
    private String deviation;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "item_result")
    private ItemResult itemResult; // ACCEPT, REJECT, CONDITIONAL_ACCEPT
    
    @Column(name = "remarks")
    private String remarks;
    
    @Column(name = "instrument_id")
    private String instrumentId;
    
    // 关联关系
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inspection_id", insertable = false, updatable = false)
    private IQCInspectionRecord iqcRecord;
}
\`\`\`

### 2.3 IQC检验计划服务

\`\`\`java
/**
 * IQC检验计划服务
 */
@Service
@Slf4j
@Transactional
public class IQCInspectionPlanServiceImpl implements IQCInspectionPlanService {
    
    @Autowired
    private IQCInspectionRecordRepository iqcInspectionRecordRepository;
    
    @Autowired
    private MaterialRepository materialRepository;
    
    @Autowired
    private SamplingService samplingService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 创建IQC检验计划
     */
    @Override
    public IQCInspectionPlanDTO createInspectionPlan(IQCCreatePlanDTO dto) {
        log.info("创建IQC检验计划,批次号: {}", dto.getBatchNumber());
        
        // 1. 验证物料信息
        Material material = getMaterialById(dto.getMaterialId());
        
        // 2. 验证供应商信息
        Supplier supplier = getSupplierById(dto.getSupplierId());
        
        // 3. 生成检验批号
        String inspectionLotNumber = generateInspectionLotNumber();
        
        // 4. 计算抽样方案
        SamplingPlan samplingPlan = calculateSamplingPlan(material, dto);
        
        // 5. 创建检验记录
        IQCInspectionRecord record = new IQCInspectionRecord();
        record.setInspectionLotNumber(inspectionLotNumber);
        record.setMaterialId(material.getMaterialId());
        record.setMaterialCode(material.getMaterialCode());
        record.setMaterialName(material.getMaterialName());
        record.setSupplierId(supplier.getSupplierId());
        record.setSupplierName(supplier.getSupplierName());
        record.setInspectionType(dto.getInspectionType());
        record.setBatchNumber(dto.getBatchNumber());
        record.setArrivalDate(dto.getArrivalDate());
        record.setQuantityReceived(dto.getQuantityReceived());
        record.setSampleSize(samplingPlan.getSampleSize());
        record.setInspectedQuantity(0);
        record.setInspectionResult(InspectionResult.PENDING);
        record.setInspectorId(SecurityUtils.getCurrentUserId());
        record.setInspectorName(SecurityUtils.getCurrentUserName());
        record.setSamplingStandard(samplingPlan.getSamplingStandard());
        record.setInspectionLevel(samplingPlan.getInspectionLevel());
        record.setAqlValue(samplingPlan.getAqlValue());
        record.setStatus(IQCRecordStatus.PLANNED);
        record.setCreatedBy(SecurityUtils.getCurrentUserId());
        record.setCreatedTime(LocalDateTime.now());
        
        // 6. 保存检验记录
        record = iqcInspectionRecordRepository.save(record);
        
        // 7. 创建检验项目
        createInspectionItems(record, dto);
        
        log.info("IQC检验计划创建成功,检验批号: {}", inspectionLotNumber);
        
        return convertToDTO(record);
    }
    
    /**
     * 计算抽样方案
     */
    @Override
    public SamplingPlan calculateSamplingPlan(Material material, IQCCreatePlanDTO dto) {
        log.info("计算IQC抽样方案,物料编码: {}", material.getMaterialCode());
        
        SamplingPlan plan = new SamplingPlan();
        
        // 1. 确定检验标准
        if (material.getInspectionStandard() != null) {
            plan.setSamplingStandard(material.getInspectionStandard());
        } else {
            plan.setSamplingStandard(SamplingStandard.MIL_STD_105E); // 默认标准
        }
        
        // 2. 确定检验等级
        if (material.getInspectionLevel() != null) {
            plan.setInspectionLevel(material.getInspectionLevel());
        } else {
            plan.setInspectionLevel("NORMAL");
        }
        
        // 3. 确定AQL值
        if (material.getAqlValue() != null) {
            plan.setAqlValue(material.getAqlValue());
        } else {
            plan.setAqlValue("2.5");
        }
        
        // 4. 计算批量 (到达数量)
        int lotSize = dto.getQuantityReceived();
        
        // 5. 计算样本量
        int sampleSize = samplingService.calculateSampleSize(
            plan.getSamplingStandard(),
            plan.getInspectionLevel(),
            lotSize
        );
        
        // 6. 根据抽样类型调整
        if (IQCInspectionType.FIRST_INSPECTION == dto.getInspectionType()) {
            sampleSize = (int) (sampleSize * 1.5); // 首检增加50%样本量
        }
        
        plan.setSampleSize(sampleSize);
        plan.setLotSize(lotSize);
        
        log.info("抽样方案计算完成,样本量: {}, AQL: {}", sampleSize, plan.getAqlValue());
        
        return plan;
    }
    
    /**
     * 创建检验项目
     */
    private void createInspectionItems(IQCInspectionRecord record, IQCCreatePlanDTO dto) {
        List<IQCInspectionItem> items = new ArrayList<>();
        
        // 1. 基于物料类型确定检验项目
        if ("ALUMINUM".equals(material.getMaterialGroup())) {
            // 铝合金检验项目
            items.addAll(createAluminumInspectionItems(record, material));
        } else if ("ZINC".equals(material.getMaterialGroup())) {
            // 锌合金检验项目
            items.addAll(createZincInspectionItems(record, material));
        } else if ("MAGNESIUM".equals(material.getMaterialGroup())) {
            // 镁合金检验项目
            items.addAll(createMagnesiumInspectionItems(record, material));
        } else {
            // 其他材料检验项目
            items.addAll(createGeneralInspectionItems(record, material));
        }
        
        // 2. 添加用户自定义检验项目
        if (dto.getCustomItems() != null) {
            items.addAll(createCustomInspectionItems(record, dto.getCustomItems()));
        }
        
        // 3. 批量保存
        iqcInspectionItemRepository.saveAll(items);
        
        log.info("创建检验项目完成,数量: {}", items.size());
    }
    
    /**
     * 创建铝合金检验项目
     */
    private List<IQCInspectionItem> createAluminumInspectionItems(IQCInspectionRecord record, Material material) {
        List<IQCInspectionItem> items = new ArrayList<>();
        
        // 1. 化学成分分析
        IQCInspectionItem chemicalAnalysis = createInspectionItem(
            record, "CHEM_ANALYSIS", "化学成分分析", 
            InspectionMethod.MATERIAL_ANALYSIS, null, null, "%"
        );
        items.add(chemicalAnalysis);
        
        // 2. 力学性能测试
        IQCInspectionItem mechanicalTest = createInspectionItem(
            record, "MECH_TEST", "力学性能测试", 
            InspectionMethod.MATERIAL_ANALYSIS, null, null, "MPa"
        );
        items.add(mechanicalTest);
        
        // 3. 尺寸检验
        IQCInspectionItem dimensionalCheck = createInspectionItem(
            record, "DIMENSIONAL", "尺寸检验", 
            InspectionMethod.DIMENSIONAL_CHECK, null, null, "mm"
        );
        items.add(dimensionalCheck);
        
        // 4. 外观检验
        IQCInspectionItem visualInspection = createInspectionItem(
            record, "VISUAL", "外观检验", 
            InspectionMethod.VISUAL_INSPECTION, null, null, null
        );
        items.add(visualInspection);
        
        // 5. 材料密度检验
        IQCInspectionItem densityTest = createInspectionItem(
            record, "DENSITY", "材料密度检验", 
            InspectionMethod.MATERIAL_ANALYSIS, null, null, "g/cm³"
        );
        items.add(densityTest);
        
        return items;
    }
    
    /**
     * 执行IQC检验
     */
    @Override
    public IQCInspectionResultDTO executeInspection(Long inspectionId, IQCExecuteDTO dto) {
        log.info("执行IQC检验,检验ID: {}", inspectionId);
        
        // 1. 查询检验记录
        IQCInspectionRecord record = getInspectionById(inspectionId);
        
        // 2. 验证状态
        if (IQCRecordStatus.IN_PROGRESS != record.getStatus()) {
            throw new BusinessException("只能执行进行中的检验");
        }
        
        // 3. 更新检验状态
        record.setStatus(IQCRecordStatus.COMPLETED);
        record.setInspectedQuantity(dto.getInspectedQuantity());
        record.setUpdatedBy(SecurityUtils.getCurrentUserId());
        record.setUpdatedTime(LocalDateTime.now());
        
        // 4. 检验项目执行
        executeInspectionItems(record, dto.getItems());
        
        // 5. 检验结果判定
        InspectionResult result = determineInspectionResult(record);
        record.setInspectionResult(result);
        
        // 6. 统计不合格品数量
        int nonconformingCount = countNonconformingItems(record);
        record.setQuantityNonconforming(nonconformingCount);
        record.setNonconformingRate(calculateNonconformingRate(record));
        
        // 7. 保存检验记录
        record = iqcInspectionRecordRepository.save(record);
        
        // 8. 记录不合格品信息
        if (nonconformingCount > 0) {
            createNonconformingRecords(record, nonconformingCount);
        }
        
        // 9. 发送检验完成通知
        sendInspectionCompletedNotification(record);
        
        log.info("IQC检验执行完成,检验批号: {}, 结果: {}", 
            record.getInspectionLotNumber(), result);
        
        return convertToResultDTO(record);
    }
    
    /**
     * 检验结果判定
     */
    private InspectionResult determineInspectionResult(IQCInspectionRecord record) {
        // 1. 查询所有检验项目
        List<IQCInspectionItem> items = iqcInspectionItemRepository.findByInspectionId(record.getInspectionId());
        
        // 2. 统计各结果数量
        long acceptCount = items.stream()
            .filter(i -> ItemResult.ACCEPT == i.getItemResult())
            .count();
        
        long rejectCount = items.stream()
            .filter(i -> ItemResult.REJECT == i.getItemResult())
            .count();
        
        long conditionalAcceptCount = items.stream()
            .filter(i -> ItemResult.CONDITIONAL_ACCEPT == i.getItemResult())
            .count();
        
        // 3. 计算抽样判定
        double rejectRate = (double) rejectCount / items.size();
        double conditionalRate = (double) conditionalAcceptCount / items.size();
        
        // 4. 使用抽样标准进行判定
        SamplingStandard standard = record.getSamplingStandard();
        String aqlValue = record.getAqlValue();
        
        if (standard == SamplingStandard.MIL_STD_105E) {
            return determineByMILStd105E(record, rejectCount, conditionalAcceptCount);
        } else if (standard == SamplingStandard.ISO_2859_1) {
            return determineByISO28591(record, rejectCount, conditionalAcceptCount);
        } else {
            return determineByGBT28281(record, rejectCount, conditionalAcceptCount);
        }
    }
    
    /**
     * MIL-STD-105E抽样判定
     */
    private InspectionResult determineByMILStd105E(IQCInspectionRecord record, 
                                                  int rejectCount, int conditionalCount) {
        // 1. 根据样本量和AQL查询抽样表
        SamplingTable samplingTable = samplingService.getSamplingTable(
            SamplingStandard.MIL_STD_105E,
            record.getInspectionLevel(),
            record.getSampleSize(),
            record.getAqlValue()
        );
        
        // 2. 获取判定界限
        int acceptNumber = samplingTable.getAcceptNumber();
        int rejectNumber = samplingTable.getRejectNumber();
        int conditionalNumber = samplingTable.getConditionalNumber();
        
        // 3. 判定规则
        if (rejectCount >= rejectNumber) {
            return InspectionResult.REJECT;
        } else if (rejectCount <= acceptNumber) {
            return InspectionResult.ACCEPT;
        } else if (conditionalCount <= conditionalNumber) {
            return InspectionResult.ACCEPT;
        } else {
            return InspectionResult.REJECT;
        }
    }
    
    /**
     * 计算不合格率
     */
    private Double calculateNonconformingRate(IQCInspectionRecord record) {
        if (record.getInspectedQuantity() == 0) {
            return 0.0;
        }
        return (double) record.getQuantityNonconforming() / record.getInspectedQuantity() * 100;
    }
    
    /**
     * 创建不合格品记录
     */
    private void createNonconformingRecords(IQCInspectionRecord record, int count) {
        List<IQCNonconformingRecord> nonconformingRecords = new ArrayList<>();
        
        for (int i = 0; i < count; i++) {
            IQCNonconformingRecord nonconforming = new IQCNonconformingRecord();
            nonconforming.setIqcId(record.getInspectionId());
            nonconforming.setLotNumber(record.getInspectionLotNumber());
            nonconforming.setBatchNumber(record.getBatchNumber());
            nonconforming.setMaterialCode(record.getMaterialCode());
            nonconforming.setSupplierName(record.getSupplierName());
            nonconforming.setQuantity(1);
            nonconforming.setNonconformingType("IQC不合格");
            nonconforming.setStatus("待处理");
            nonconforming.setCreatedTime(LocalDateTime.now());
            
            nonconformingRecords.add(nonconforming);
        }
        
        iqcNonconformingRecordRepository.saveAll(nonconformingRecords);
    }
}
\`\`\`

### 2.4 抽样算法服务

\`\`\`java
/**
 * 抽样算法服务
 */
@Service
@Slf4j
public class SamplingServiceImpl implements SamplingService {
    
    // MIL-STD-105E抽样表
    private static final Map<String, SamplingTable> MIL_STD_105E_TABLES = Map.of(
        "NORMAL", loadMILStd105ENormalTable(),
        "TIGHTENED", loadMILStd105ETightenedTable(),
        "RELAXED", loadMILStd105ERelaxedTable()
    );
    
    // ISO 2859-1抽样表
    private static final Map<String, SamplingTable> ISO_2859_1_TABLES = Map.of(
        "GENERAL", loadISO28591GeneralTable(),
        "SPECIAL", loadISO28591SpecialTable()
    );
    
    /**
     * 计算样本量
     */
    @Override
    public int calculateSampleSize(SamplingStandard standard, String inspectionLevel, int lotSize) {
        log.info("计算样本量,标准: {}, 等级: {}, 批量: {}", standard, inspectionLevel, lotSize);
        
        switch (standard) {
            case MIL_STD_105E:
                return calculateMILStd105ESampleSize(inspectionLevel, lotSize);
            case ISO_2859_1:
                return calculateISO28591SampleSize(inspectionLevel, lotSize);
            case GB_T_2828_1:
                return calculateGBT28281SampleSize(inspectionLevel, lotSize);
            default:
                return calculateDefaultSampleSize(lotSize);
        }
    }
    
    /**
     * MIL-STD-105E样本量计算
     */
    private int calculateMILStd105ESampleSize(String inspectionLevel, int lotSize) {
        // 查找样本量码
        String codeLetter = findSampleSizeCode(inspectionLevel, lotSize);
        
        // 根据样本量码查找样本量
        return findSampleSizeByCode(codeLetter);
    }
    
    /**
     * 查找样本量码
     */
    private String findSampleSizeCode(String inspectionLevel, int lotSize) {
        // MIL-STD-105E样本量码表
        Map<Integer, String> codeMap = Map.ofEntries(
            Map.entry(2, "A"), Map.entry(8, "B"), Map.entry(15, "C"),
            Map.entry(25, "D"), Map.entry(50, "E"), Map.entry(90, "F"),
            Map.entry(150, "G"), Map.entry(280, "H"), Map.entry(500, "J"),
            Map.entry(1200, "K"), Map.entry(3200, "L"), Map.entry(10000, "M")
        );
        
        // 找到小于等于批量的最大码
        return codeMap.entrySet().stream()
            .filter(entry -> lotSize <= entry.getKey())
            .findFirst()
            .orElse(Map.entry(Integer.MAX_VALUE, "N"))
            .getValue();
    }
    
    /**
     * 根据样本量码查找样本量
     */
    private int findSampleSizeByCode(String code) {
        // 样本量码对应的样本量
        Map<String, Integer> sampleSizeMap = Map.of(
            "A", 2, "B", 3, "C", 5, "D", 8, "E", 13,
            "F", 20, "G", 32, "H", 50, "J", 80, "K", 125,
            "L", 200, "M", 315, "N", 500
        );
        
        return sampleSizeMap.getOrDefault(code, 2);
    }
    
    /**
     * 抽样方案动态调整
     */
    @Override
    public SamplingPlan adjustSamplingPlan(SamplingPlan currentPlan, SamplingAdjustment adjustment) {
        log.info("调整抽样方案,当前: {}, 调整类型: {}", 
            currentPlan.getInspectionLevel(), adjustment.getType());
        
        SamplingPlan adjustedPlan = new SamplingPlan(currentPlan);
        
        switch (adjustment.getType()) {
            case FROM_NORMAL_TO_TIGHTENED:
                adjustedPlan.setInspectionLevel("TIGHTENED");
                adjustedPlan.setSampleSize((int) (adjustedPlan.getSampleSize() * 1.25));
                break;
                
            case FROM_NORMAL_TO_RELAXED:
                adjustedPlan.setInspectionLevel("RELAXED");
                adjustedPlan.setSampleSize((int) (adjustedPlan.getSampleSize() * 0.8));
                break;
                
            case FROM_TIGHTENED_TO_NORMAL:
                adjustedPlan.setInspectionLevel("NORMAL");
                adjustedPlan.setSampleSize((int) (adjustedPlan.getSampleSize() / 1.25));
                break;
                
            case FROM_RELAXED_TO_NORMAL:
                adjustedPlan.setInspectionLevel("NORMAL");
                adjustedPlan.setSampleSize((int) (adjustedPlan.getSampleSize() / 0.8));
                break;
        }
        
        log.info("抽样方案调整完成,新样本量: {}, 新等级: {}", 
            adjustedPlan.getSampleSize(), adjustedPlan.getInspectionLevel());
        
        return adjustedPlan;
    }
    
    /**
     * 获取抽样表
     */
    @Override
    public SamplingTable getSamplingTable(SamplingStandard standard, String inspectionLevel, 
                                        int sampleSize, String aqlValue) {
        switch (standard) {
            case MIL_STD_105E:
                return MIL_STD_105E_TABLES.get(inspectionLevel)
                    .getBySampleSizeAndAQL(sampleSize, aqlValue);
            case ISO_2859_1:
                return ISO_2859_1_TABLES.get("GENERAL")
                    .getBySampleSizeAndAQL(sampleSize, aqlValue);
            case GB_T_2828_1:
                return getGBT28281Table()
                    .getBySampleSizeAndAQL(sampleSize, aqlValue);
            default:
                return new SamplingTable();
        }
    }
    
    /**
     * 根据历史检验数据自动调整抽样方案
     */
    @Override
    public SamplingPlan autoAdjustBasedOnHistory(Material material, int consecutiveBatches) {
        log.info("基于历史数据自动调整抽样方案,物料: {}, 连续批次: {}", 
            material.getMaterialCode(), consecutiveBatches);
        
        // 1. 查询最近5批次的IQC结果
        List<IQCInspectionRecord> recentRecords = iqcInspectionRecordRepository
            .findByMaterialIdOrderByInspectionDateDesc(
                material.getMaterialId(), 
                LocalDate.now().minusMonths(1)
            )
            .stream()
            .limit(5)
            .collect(Collectors.toList());
        
        if (recentRecords.isEmpty()) {
            return getDefaultSamplingPlan(material);
        }
        
        // 2. 计算最近批次的不合格率
        double avgNonconformingRate = recentRecords.stream()
            .mapToDouble(IQCInspectionRecord::getNonconformingRate)
            .average()
            .orElse(0.0);
        
        // 3. 判断是否需要调整
        SamplingPlan currentPlan = getDefaultSamplingPlan(material);
        SamplingAdjustment adjustment = determineAdjustment(
            currentPlan, avgNonconformingRate, consecutiveBatches
        );
        
        if (adjustment != null) {
            return adjustSamplingPlan(currentPlan, adjustment);
        }
        
        return currentPlan;
    }
    
    /**
     * 判断抽样调整
     */
    private SamplingAdjustment determineAdjustment(SamplingPlan currentPlan, 
                                                  double nonconformingRate, 
                                                  int consecutiveBatches) {
        // 连续5批次不合格率低于0.65%,考虑放宽
        if (nonconformingRate < 0.65 && 
            consecutiveBatches >= 5 && 
            "NORMAL".equals(currentPlan.getInspectionLevel())) {
            return SamplingAdjustment.fromNormalToRelaxed();
        }
        
        // 连续5批次不合格率超过2.5%,考虑加严
        if (nonconformingRate > 2.5 && 
            consecutiveBatches >= 5 && 
            "NORMAL".equals(currentPlan.getInspectionLevel())) {
            return SamplingAdjustment.fromNormalToTightened();
        }
        
        // 连续20批次不合格率低于0.1%,放宽到严格
        if (nonconformingRate < 0.1 && 
            consecutiveBatches >= 20 && 
            "TIGHTENED".equals(currentPlan.getInspectionLevel())) {
            return SamplingAdjustment.fromTightenedToNormal();
        }
        
        // 连续10批次不合格率超过4%,放宽到严格
        if (nonconformingRate > 4 && 
            consecutiveBatches >= 10 && 
            "RELAXED".equals(currentPlan.getInspectionLevel())) {
            return SamplingAdjustment.fromRelaxedToNormal();
        }
        
        return null;
    }
}
\`\`\`

---

## 3. IPQC制程检验模块详细实现

### 3.1 IPQC检验流程

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                         IPQC检验流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ 工单创建  │───▶│ SPC监控  │───▶│ 参数监控  │                   │
│  └──────────┘    └──────────┘    └──────────┘                   │
│                  │          │                                 │
│                  ▼          ▼                                 │
│           ┌──────────┐ ┌──────────┐                            │
│           │ 首件检验  │ │ 过程检验  │                            │
│           └─────────┘ └─────────┘                            │
│                  │          │                                 │
│                  ▼          ▼                                 │
│           ┌──────────┐ ┌──────────┐                            │
│           │ 过程参数  │ │ 质量参数  │                            │
│           │ 控制     │ │ 监控     │                            │
│           └─────────┘ └─────────┘                            │
│                  │          │                                 │
│                  └──────────┼───────────┐                      │
│                           ▼            ▼                      │
│                    ┌──────────┐ ┌──────────┐                  │
│                    │ 数据收集  │ │ 结果判定  │                  │
│                    └──────────┘ └──────────┘                  │
│                                │                              │
│                                ▼                              │
│                         ┌──────────┐                          │
│                         │ 过程改进  │                          │
│                         └──────────┘                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 3.2 IPQC SPC监控服务

\`\`\`java
/**
 * IPQC SPC监控服务
 */
@Service
@Slf4j
public class IPCSPCMonitoringServiceImpl implements IPCSPCMonitoringService {
    
    @Autowired
    private spcControlPointRepository spcControlPointRepository;
    
    @Autowired
    private SPCAlertService spcAlertService;
    
    @Autowired
    private ProductionProductionMonitoringService productionMonitoringService;
    
    /**
     * 实时SPC监控
     */
    @Scheduled(fixedDelay = 5000) // 5秒监控一次
    public void monitorSPCPoints() {
        log.debug("开始IPQC SPC实时监控");
        
        // 1. 查询当前生产中的SPC控制点
        List<SPCControlPoint> activePoints = spcControlPointRepository
            .findActiveProductionSPCPoints();
        
        // 2. 监控每个控制点
        for (SPCControlPoint point : activePoints) {
            monitorSPCPoint(point);
        }
        
        log.debug("IPQC SPC监控完成,监控点数量: {}", activePoints.size());
    }
    
    /**
     * 监控单个SPC控制点
     */
    private void monitorSPCPoint(SPCControlPoint point) {
        try {
            // 1. 获取最新测量值
            Double latestValue = getLatestSPCValue(point);
            
            if (latestValue == null) {
                return; // 暂无数据
            }
            
            // 2. 存储SPC数据
            storeSPCData(point, latestValue);
            
            // 3. 检测异常
            if (detectSPCAnomaly(point, latestValue)) {
                // 触发SPC异常告警
                spcAlertService.triggerSPCAnomalyAlert(point, latestValue);
            }
            
            // 4. 更新控制图
            updateControlChart(point, latestValue);
            
        } catch (Exception e) {
            log.error("SPC监控异常,控制点ID: {}", point.getControlPointId(), e);
        }
    }
    
    /**
     * SPC异常检测
     */
    private boolean detectSPCAnomaly(SPCControlPoint point, Double value) {
        List<SPCControlPoint> recentPoints = spcControlPointRepository
            .findRecentSPCPoints(point.getCharacteristicId(), 20);
        
        if (recentPoints.size() < 10) {
            return false; // 数据不足
        }
        
        // 1. 超出控制限
        if (isBeyondControlLimits(point, value)) {
            return true;
        }
        
        // 2. 连续异常模式
        if (hasPatternViolation(recentPoints, value)) {
            return true;
        }
        
        // 3. 趋势检测
        if (hasTrendViolation(recentPoints)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * 趋势检测
     */
    private boolean hasTrendViolation(List<SPCControlPoint> points) {
        if (points.size() < 8) {
            return false;
        }
        
        // 1. 连续6点递增或递减
        if (hasConsecutiveTrend(points, 6)) {
            return true;
        }
        
        // 2. 14点交替上下
        if (hasAlternatingPattern(points, 14)) {
            return true;
        }
        
        // 3. 连续7点在中心线同一侧
        if (hasConsecutiveSide(points, 7)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * 趋势分析
     */
    private TrendAnalysis analyzeTrend(List<SPCControlPoint> points) {
        TrendAnalysis analysis = new TrendAnalysis();
        
        if (points.size() < 10) {
            return analysis;
        }
        
        // 1. 计算线性趋势
        LinearTrend linearTrend = calculateLinearTrend(points);
        analysis.setLinearTrend(linearTrend);
        
        // 2. 计算CUSUM累积和控制
        CUSUMAnalysis cusum = calculateCUSUM(points);
        analysis.setCusumAnalysis(cusum);
        
        // 3. 计算移动极差
        MovingRangeAnalysis mrAnalysis = calculateMovingRange(points);
        analysis.setMovingRangeAnalysis(mrAnalysis);
        
        return analysis;
    }
    
    /**
     * 线性趋势分析
     */
    private LinearTrend calculateLinearTrend(List<SPCControlPoint> points) {
        double n = points.size();
        double sumX = 0;
        double sumY = 0;
        double sumXY = 0;
        double sumXX = 0;
        
        for (int i = 0; i < n; i++) {
            double x = i + 1;
            double y = points.get(i).getMeasurementValue();
            
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
        }
        
        // 计算斜率
        double slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        
        // 计算截距
        double intercept = (sumY - slope * sumX) / n;
        
        // 计算相关系数
        double correlation = calculateCorrelation(points, slope, intercept);
        
        LinearTrend trend = new LinearTrend();
        trend.setSlope(slope);
        trend.setIntercept(intercept);
        trend.setCorrelation(correlation);
        trend.setTrendType(determineTrendType(slope));
        
        return trend;
    }
    
    /**
     * CUSUM累积和控制图分析
     */
    private CUSUMAnalysis calculateCUSUM(List<SPCControlPoint> points) {
        CUSUMAnalysis cusum = new CUSUMAnalysis();
        
        // 计算样本均值
        double targetMean = calculateSampleMean(points);
        
        // 计算过程标准差
        double processStdDev = calculateProcessStdDev(points);
        
        // 计算CUSUM值
        List<Double> cusumValues = new ArrayList<>();
        double sum = 0;
        
        for (int i = 0; i < points.size(); i++) {
            double value = points.get(i).getMeasurementValue();
            sum += (value - targetMean);
            cusumValues.add(sum);
        }
        
        cusum.setTargetMean(targetMean);
        cusum.setProcessStdDev(processStdDev);
        cusum.setCusumValues(cusumValues);
        
        // 检测CUSUM报警
        cusum.setAlarmDetected(hasCUSUMAlarm(cusumValues, processStdDev));
        
        return cusum;
    }
    
    /**
     * 移动极差分析
     */
    private MovingRangeAnalysis calculateMovingRange(List<SPCControlPoint> points) {
        MovingRangeAnalysis mrAnalysis = new MovingRangeAnalysis();
        
        List<Double> movingRanges = new ArrayList<>();
        
        for (int i = 1; i < points.size(); i++) {
            double range = Math.abs(points.get(i).getMeasurementValue() - 
                                   points.get(i - 1).getMeasurementValue());
            movingRanges.add(range);
        }
        
        mrAnalysis.setMovingRanges(movingRanges);
        mrAnalysis.setAverageRange(calculateAverage(movingRanges));
        mrAnalysis.setRangeStdDev(calculateMovingRangeStdDev(movingRanges));
        
        return mrAnalysis;
    }
    
    /**
     * Xbar-R控制图分析
     */
    @Override
    public XbarRControlChart analyzeXbarRControlChart(List<SPCControlPoint> points) {
        XbarRControlChart chart = new XbarRControlChart();
        
        if (points.isEmpty()) {
            return chart;
        }
        
        // 1. 分组数据 (假设样本数为4)
        int subgroupSize = 4;
        List<Double> subgroupAverages = new ArrayList<>();
        List<Double> subgroupRanges = new ArrayList<>();
        
        for (int i = 0; i < points.size(); i += subgroupSize) {
            List<SPCControlPoint> subgroup = points.subList(
                i, Math.min(i + subgroupSize, points.size())
            );
            
            double subgroupAverage = subgroup.stream()
                .mapToDouble(SPCControlPoint::getMeasurementValue)
                .average()
                .orElse(0.0);
            
            double subgroupRange = calculateSubgroupRange(subgroup);
            
            subgroupAverages.add(subgroupAverage);
            subgroupRanges.add(subgroupRange);
        }
        
        // 2. 计算控制限
        double grandAverage = calculateAverage(subgroupAverages);
        double averageRange = calculateAverage(subgroupRanges);
        
        double a2 = getA2Factor(subgroupSize);
        double d3 = getD3Factor(subgroupSize);
        double d4 = getD4Factor(subgroupSize);
        
        // Xbar控制限
        chart.setXbarGrandAverage(grandAverage);
        chart.setXbarUcl(grandAverage + a2 * averageRange);
        chart.setXbarLcl(grandAverage - a2 * averageRange);
        
        // R控制限
        chart.setRangeAverage(averageRange);
        chart.setRangeUcl(d4 * averageRange);
        chart.setRangeLcl(d3 * averageRange);
        
        // 3. 分析数据点
        analyzeControlChartData(chart, subgroupAverages, subgroupRanges);
        
        return chart;
    }
    
    /**
     * 控制数据点分析
     */
    private void analyzeControlChartData(XbarRControlChart chart, 
                                        List<Double> xbarValues, 
                                        List<Double> rValues) {
        List<ControlPointAnalysis> xbarAnalyses = new ArrayList<>();
        List<ControlPointAnalysis> rAnalyses = new ArrayList<>();
        
        // 分析Xbar数据点
        for (int i = 0; i < xbarValues.size(); i++) {
            ControlPointAnalysis analysis = analyzeControlPoint(
                xbarValues.get(i), 
                chart.getXbarLcl(), 
                chart.getXbarUcl()
            );
            analysis.setDataPointIndex(i);
            analysis.setChartType("XBAR");
            xbarAnalyses.add(analysis);
        }
        
        // 分析R数据点
        for (int i = 0; i < rValues.size(); i++) {
            ControlPointAnalysis analysis = analyzeControlPoint(
                rValues.get(i), 
                chart.getRangeLcl(), 
                chart.getRangeUcl()
            );
            analysis.setDataPointIndex(i);
            analysis.setChartType("R");
            rAnalyses.add(analysis);
        }
        
        chart.setXbarPointAnalyses(xbarAnalyses);
        chart.setRangePointAnalyses(rAnalyses);
        
        // 总结分析
        chart.setOverallAnalysis(generateOverallAnalysis(xbarAnalyses, rAnalyses));
    }
    
    /**
     * 生成总体分析
     */
    private ControlChartOverallAnalysis generateOverallAnalysis(
        List<ControlPointAnalysis> xbarAnalyses, 
        List<ControlPointAnalysis> rAnalyses) {
        
        ControlChartOverallAnalysis analysis = new ControlChartOverallAnalysis();
        
        // 统计异常点
        long xbarAbnormalCount = xbarAnalyses.stream()
            .filter(ControlPointAnalysis::isAbnormal)
            .count();
        
        long rAbnormalCount = rAnalyses.stream()
            .filter(ControlPointAnalysis::isAbnormal)
            .count();
        
        analysis.setTotalPoints(xbarAnalyses.size());
        analysis.setXbarAbnormalCount(xbarAbnormalCount);
        analysis.setRangeAbnormalCount(rAbnormalCount);
        analysis.setTotalAbnormalCount(xbarAbnormalCount + rAbnormalCount);
        
        // 判断过程能力
        analysis.setProcessCapability(determineProcessCapability(
            xbarAbnormalCount + rAbnormalCount, 
            xbarAnalyses.size() + rAnalyses.size()
        ));
        
        return analysis;
    }
    
    /**
     * 判断过程能力
     */
    private ProcessCapability determineProcessCapability(long abnormalCount, long totalPoints) {
        if (totalPoints == 0) {
            return ProcessCapability.INSUFFICIENT_DATA;
        }
        
        double abnormalRate = (double) abnormalCount / totalPoints;
        
        if (abnormalRate == 0) {
            return ProcessCapability.EXCELLENT;
        } else if (abnormalRate <= 0.01) {
            return ProcessCapability.GOOD;
        } else if (abnormalRate <= 0.05) {
            return ProcessCapability.ADEQUATE;
        } else {
            return ProcessCapability.POOR;
        }
    }
}
\`\`\`

---

## 4. FQC/OQC出厂检验模块详细实现

### 4.1 FQC/OQC检验流程

\`\`\`
┌─────────────────────────────────────────────────────────────────┐
│                      FQC/OQC检验流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ 生产完成  │───▶│ 检验准备  │───▶│ 成品抽样  │                   │
│  └──────────┘    └──────────┘    └──────────┘                   │
│                               │                                │
│                  ┌────────────┴────────────┐                   │
│                  ▼                         ▼                   │
│           ┌──────────┐              ┌──────────┐               │
│           │ 外观检验  │              │ 功能测试  │               │
│           └──────────┘              └──────────┘               │
│                  │                        │                │
│           ┌──────┴──────┐               ┌─┴────┐            │
│           ▼              ▼               ▼      ▼             │
│  ┌──────────┐  ┌──────────┐     ┌──────────┐ ┌──────────┐      │
│  │ 性能测试  │  │ 包装检验  │     │ 安全测试  │ │ 认证检查  │      │
│  └──────────┘  └──────────┘     └──────────┘ └──────────┘      │
│                  │                        │                │
│           ┌──────┴──────┐               ┌─┴────┐            │
│           ▼              ▼               ▼      ▼             │
│  ┌──────────┐  ┌──────────┐     ┌──────────┐ ┌──────────┐      │
│  │ 记录数据  │  │ 结果判定  │     │ 出厂批准  │ │ 质量追溯  │      │
│  └──────────┘  └──────────┘     └──────────┘ └──────────┘      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
\`\`\`

### 4.2 FQC/OQC检验服务

\`\`\`java
/**
 * FQC/OQC检验服务
 */
@Service
@Slf4j
public class FQCInspectionServiceImpl implements FQCInspectionService {
    
    @Autowired
    private FQCInspectionRecordRepository fqcInspectionRecordRepository;
    
    @Autowired
    private FinishedGoodsRepository finishedGoodsRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private SamplingService samplingService;
    
    /**
     * 创建FQC检验计划
     */
    @Override
    public FQCInspectionDTO createInspection(FQCCreateDTO dto) {
        log.info("创建FQC检验,产品: {}, 批次: {}", dto.getProductId(), dto.getBatchNumber());
        
        // 1. 验证生产信息
        FinishedGoods finishedGoods = getFinishedGoodsByBatch(dto.getBatchNumber());
        
        // 2. 确定检验标准
        InspectionStandard standard = determineInspectionStandard(finishedGoods, dto);
        
        // 3. 计算抽样方案
        SamplingPlan samplingPlan = calculateSamplingPlan(finishedGoods, standard);
        
        // 4. 创建检验记录
        FQCInspectionRecord record = createInspectionRecord(
            finishedGoods, dto, standard, samplingPlan
        );
        
        // 5. 创建检验项目
        createInspectionItems(record, finishedGoods);
        
        // 6. 保存记录
        record = fqcInspectionRecordRepository.save(record);
        
        log.info("FQC检验计划创建成功,检验ID: {}", record.getInspectionId());
        
        return convertToDTO(record);
    }
    
    /**
     * 确定检验标准
     */
    private InspectionStandard determineInspectionStandard(FinishedGoods finishedGoods, FQCCreateDTO dto) {
        // 1. 优先使用物料指定的检验标准
        if (finishedGoods.getInspectionStandard() != null) {
            return finishedGoods.getInspectionStandard();
        }
        
        // 2. 根据客户要求确定
        Customer customer = customerRepository.findById(finishedGoods.getCustomerId()).orElse(null);
        if (customer != null && customer.getInspectionStandard() != null) {
            return customer.getInspectionStandard();
        }
        
        // 3. 默认标准
        return InspectionStandard.MIL_STD_105E;
    }
    
    /**
     * 计算FQC抽样方案
     */
    private SamplingPlan calculateSamplingPlan(FinishedGoods finishedGoods, InspectionStandard standard) {
        SamplingPlan plan = new SamplingPlan();
        plan.setSamplingStandard(standard);
        
        // FQC通常使用常规检验等级
        plan.setInspectionLevel("NORMAL");
        
        // 根据产品类型确定AQL
        if ("CRITICAL".equals(finishedGoods.getQualityLevel())) {
            plan.setAqlValue("0.65"); // 关键件0.65
        } else if ("IMPORTANT".equals(finishedGoods.getQualityLevel())) {
            plan.setAqlValue("1.5"); // 重要件1.5
        } else {
            plan.setAqlValue("2.5"); // 一般件2.5
        }
        
        // 批量为生产数量
        int lotSize = finishedGoods.getProductionQuantity();
        plan.setLotSize(lotSize);
        
        // 计算样本量
        int sampleSize = samplingService.calculateSampleSize(
            standard, plan.getInspectionLevel(), lotSize
        );
        plan.setSampleSize(sampleSize);
        
        return plan;
    }
    
    /**
     * 执行FQC检验
     */
    @Override
    public FQCInspectionResultDTO executeInspection(Long inspectionId, FQCExecuteDTO dto) {
        log.info("执行FQC检验,检验ID: {}", inspectionId);
        
        // 1. 查询检验记录
        FQCInspectionRecord record = getInspectionById(inspectionId);
        
        // 2. 执行检验
        executeFQCInspection(record, dto);
        
        // 3. 检验结果判定
        InspectionResult result = determineFQCResult(record);
        record.setInspectionResult(result);
        
        // 4. 更新记录
        record = fqcInspectionRecordRepository.save(record);
        
        // 5. 处理检验结果
        handleInspectionResult(record);
        
        log.info("FQC检验执行完成,检验ID: {}, 结果: {}", 
            inspectionId, result);
        
        return convertToResultDTO(record);
    }
    
    /**
     * FQC检验判定
     */
    private InspectionResult determineFQCResult(FQCInspectionRecord record) {
        List<FQCInspectionItem> items = fqcInspectionItemRepository.findByInspectionId(record.getInspectionId());
        
        // 统计检验结果
        long acceptCount = items.stream()
            .filter(i -> ItemResult.ACCEPT == i.getItemResult())
            .count();
        
        long rejectCount = items.stream()
            .filter(i -> ItemResult.REJECT == i.getItemResult())
            .count();
        
        long conditionalAcceptCount = items.stream()
            .filter(i -> ItemResult.CONDITIONAL_ACCEPT == i.getItemResult())
            .count();
        
        // 根据抽样标准判定
        return determineBySamplingStandard(record, rejectCount, conditionalAcceptCount);
    }
    
    /**
     * OQC出厂检验
     */
    @Override
    public OQCInspectionResultDTO performOQCInspection(Long productId, OQCExecuteDTO dto) {
        log.info("执行OQC出厂检验,产品ID: {}", productId);
        
        // 1. 验证产品信息
        Product product = getProductById(productId);
        
        // 2. 创建OQC检验记录
        OQCInspectionRecord record = createOQCRecord(product, dto);
        
        // 3. 执行OQC检验项目
        executeOQCInspectionItems(record, dto.getItems());
        
        // 4. OQC结果判定
        InspectionResult result = determineOQCResult(record);
        record.setInspectionResult(result);
        
        // 5. 出厂批准
        if (InspectionResult.ACCEPT == result) {
            approveForShipping(record);
        }
        
        // 6. 保存记录
        oqcInspectionRecordRepository.save(record);
        
        log.info("OQC出厂检验完成,产品ID: {}, 结果: {}", productId, result);
        
        return convertOQCToResultDTO(record);
    }
    
    /**
     * 出厂批准
     */
    private void approveForShipping(OQCInspectionRecord record) {
        log.info("产品出厂批准,批号: {}", record.getBatchNumber());
        
        // 1. 生成产品证书
        generateProductCertificate(record);
        
        // 2. 更新产品状态
        updateProductStatus(record);
        
        // 3. 记录追溯信息
        recordTraceabilityInformation(record);
        
        // 4. 发送通知
        sendOQCApprovedNotification(record);
    }
    
    /**
     * 生成产品证书
     */
    private void generateProductCertificate(OQCInspectionRecord record) {
        ProductCertificate certificate = new ProductCertificate();
        certificate.setCertificateId(generateCertificateNumber());
        certificate.setBatchNumber(record.getBatchNumber());
        certificate.setProductId(record.getProductId());
        certificate.setProductName(record.getProductName());
        certificate.setInspectionDate(record.getInspectionDate());
        certificate.setInspectorId(record.getInspectorId());
        certificate.setCertificateType("CONFORMANCE_CERTIFICATE");
        certificate.setIssueDate(LocalDate.now());
        certificate.setValidUntil(LocalDate.now().plusYears(1));
        certificate.setStatus("VALID");
        
        productCertificateRepository.save(certificate);
        
        record.setCertificateId(certificate.getCertificateId());
    }
}
\`\`\`

---

## 5. 质量检验模块集成与扩展

### 5.1 自动化检测设备集成

\`\`\`java
/**
 * 自动化检测设备集成服务
 */
@Service
@Slf4j
public class AutoInspectionDeviceIntegrationServiceImpl implements AutoInspectionDeviceIntegrationService {
    
    @Autowired
    private EquipmentManagementService equipmentService;
    
    @Autowired
    private InspectionResultService inspectionResultService;
    
    /**
     * 集成自动检测设备
     */
    @Override
    public void integrateWithDevice(String deviceType, String deviceId, AutoInspectionDTO dto) {
        log.info("集成自动检测设备,设备类型: {}, 设备ID: {}", deviceType, deviceId);
        
        try {
            // 1. 验证设备连接
            validateDeviceConnection(deviceId);
            
            // 2. 处理检测数据
            processInspectionData(deviceId, dto);
            
            // 3. 更新检验记录
            updateInspectionRecord(dto);
            
            // 4. 发送通知
            sendAutoInspectionNotification(dto);
            
        } catch (Exception e) {
            log.error("自动检测设备集成异常,设备ID: {}", deviceId, e);
            sendDeviceErrorAlert(deviceId, e.getMessage());
        }
    }
    
    /**
     * 自动视觉检测数据处理
     */
    private void processVisualInspectionData(String deviceId, AutoInspectionDTO dto) {
        // 1. 解析图像数据
        BufferedImage image = parseImageData(dto.getImageData());
        
        // 2. 图像预处理
        BufferedImage processedImage = preprocessImage(image);
        
        // 3. 缺陷检测
        List<DefectDetection> defects = detectDefects(processedImage);
        
        // 4. 缺陷分类
        classifyDefects(defects);
        
        // 5. 生成检验结果
        generateAutoInspectionResults(deviceId, dto, defects);
    }
    
    /**
     * 自动测量数据处理
     */
    private void processMeasurementData(String deviceId, AutoInspectionDTO dto) {
        // 1. 解析测量数据
        MeasurementData measurementData = parseMeasurementData(dto.getMeasurementData());
        
        // 2. 数据处理
        MeasurementResult result = processMeasurement(measurementData);
        
        // 3. 结果判定
        MeasurementDecision decision = judgeMeasurementResult(result);
        
        // 4. 记录检验结果
        recordAutoMeasurementResult(deviceId, dto, decision);
    }
}
\`\`\`

### 5.2 智能质量预测

\`\`\`java
/**
 * 智能质量预测服务
 */
@Service
@Slf4j
public class IntelligentQualityPredictionServiceImpl implements IntelligentQualityPredictionService {
    
    @Autowired
    private MachineLearningService mlService;
    
    @Autowired
    private QualityRiskService qualityRiskService;
    
    /**
     * 质量风险预测
     */
    @Override
    public QualityRiskPrediction predictQualityRisk(QualityPredictionInputDTO input) {
        log.info("预测质量风险,产品: {}, 批次: {}", input.getProductId(), input.getBatchNumber());
        
        QualityRiskPrediction prediction = new QualityRiskPrediction();
        
        // 1. 基于历史数据预测
        double historicalRisk = predictByHistoricalData(input);
        prediction.setHistoricalRisk(historicalRisk);
        
        // 2. 基于工艺参数预测
        double processRisk = predictByProcessParameters(input);
        prediction.setProcessRisk(processRisk);
        
        // 3. 基于设备状态预测
        double equipmentRisk = predictByEquipmentCondition(input);
        prediction.setEquipmentRisk(equipmentRisk);
        
        // 4. 基于原材料预测
        double materialRisk = predictByMaterialQuality(input);
        prediction.setMaterialRisk(materialRisk);
        
        // 5. 综合风险计算
        double overallRisk = calculateOverallRisk(prediction);
        prediction.setOverallRisk(overallRisk);
        
        // 6. 风险等级判定
        prediction.setRiskLevel(determineRiskLevel(overallRisk));
        
        // 7. 生成建议措施
        prediction.setRecommendations(generateRecommendations(prediction));
        
        return prediction;
    }
    
    /**
     * 基于机器学习的质量预测
     */
    private double predictByMachineLearning(QualityPredictionInputDTO input) {
        // 1. 特征工程
        List<Double> features = extractFeatures(input);
        
        // 2. 模型预测
        double prediction = mlService.predictQualityRisk(features);
        
        return prediction;
    }
    
    /**
     * 特征提取
     */
    private List<Double> extractFeatures(QualityPredictionInputDTO input) {
        List<Double> features = new ArrayList<>();
        
        // 1. 历史特征
        features.add(input.getHistoricalDefectRate());
        features.add(input.getHistoricalComplaintRate());
        
        // 2. 工艺特征
        features.add(input.getProcessTemperature());
        features.add(input.getProcessPressure());
        features.add(input.getProcessSpeed());
        
        // 3. 设备特征
        features.add(input.getEquipmentAge());
        features.add(input.getMaintenanceScore());
        
        // 4. 材料特征
        features.add(input.getMaterialQualityScore());
        features.add(input.getSupplierScore());
        
        // 5. 人员特征
        features.add(input.getOperatorExperience());
        features.add(input.getTrainingScore());
        
        return features;
    }
    
    /**
     * 生成建议措施
     */
    private List<QualityRecommendation> generateRecommendations(QualityRiskPrediction prediction) {
        List<QualityRecommendation> recommendations = new ArrayList<>();
        
        // 1. 高风险预警
        if (prediction.getOverallRisk() > 70) {
            recommendations.add(createHighRiskRecommendation(prediction));
        }
        
        // 2. 中等风险建议
        if (prediction.getOverallRisk() > 40) {
            recommendations.add(createMediumRiskRecommendation(prediction));
        }
        
        // 3. 低风险提醒
        if (prediction.getOverallRisk() > 20) {
            recommendations.add(createLowRiskRecommendation(prediction));
        }
        
        return recommendations;
    }
}
\`\`\`

---

## 总结

本详细实现规范为舜富QMS系统的质量检验模块提供了:

1. **IQC来料检验**: 完整的来料检验流程、抽样算法、检验判定机制
2. **IPQC制程检验**: 实时SPC监控、多种控制图分析、趋势检测、CUSUM控制
3. **FQC/OQC出厂检验**: 成品检验流程、出厂批准、产品证书生成、质量追溯
4. **自动化集成**: 自动检测设备集成、视觉检测、自动测量数据处理
5. **智能预测**: 基于机器学习的质量风险预测、历史数据分析、智能建议

所有实现采用微服务架构,支持实时监控、智能分析、自动化处理,为舜富压铸行业提供完整的质量管理解决方案。
`,ie=`# 舜富 QMS 系统菜单重构方案\r
\r
## 1. 重构背景与设计思路\r
\r
根据《舜富QMS系统完整解决方案》的需求文档，系统涵盖了从基础数据、质量策划（APQP/PPAP）、过程控制、客诉管理、持续改进到体系审核等完整的质量生命周期，共计超过30个核心业务模块。本次菜单重构旨在将这些模块结构化，遵循**从基础到应用**、**从预防到售后**以及**IATF 16949质量体系标准**的业务脉络进行合理归类，确保用户操作层级扁平化、业务闭环清晰。\r
\r
---\r
\r
## 2. 一级与二级菜单结构规划\r
\r
### 1. 首页 / 工作台 (Dashboard)\r
- 个人工作台 (待办任务、检验预警、消息通知)\r
- 质量驾驶舱 (质量大屏看板)\r
\r
### 2. 基础数据 (Basic Data)\r
*对应文档：基础数据与质量主数据_需求文档*\r
- 客户档案\r
- 供应商档案\r
- 客供关系映射\r
- 物料分类\r
- 物料档案\r
- 工艺路线\r
- 生产班组\r
- 地点存储\r
- 计量单位\r
- 顾客特殊要求(CSR)\r
- 模具与工装档案\r
\r
### 3. 质量主数据 (Quality Master Data)\r
*对应文档：基础数据与质量主数据_需求文档、抽样标准及调整规则、计量器具管理、材料管理体系*\r
- 缺陷现象库\r
- 缺陷原因库\r
- 检验项目\r
- 检验方法\r
- 抽样方案\r
- 检验模板\r
- 检验方案\r
- 检验计划模型\r
- 计量器具台账\r
- 追溯条码与标签模板\r
\r
### 4. 质量策划 (Plan)\r
*对应文档：第7章 APQP/PPAP管理模块*\r
- APQP项目管理\r
- FMEA管理\r
- 控制计划\r
- PPAP管理\r
\r
### 5. 质量执行与控制 (Do)\r
*结合供应商、生产及出货阶段的检验与控制*\r
- **5.1 供应商质量管理 (SQM & IQC)**\r
  - 供应商准入与评估\r
  - 供应商PPAP管理\r
  - IQC来料检验\r
  - 进料不良异常处理\r
  - 供应商绩效考核\r
  - 供应商索赔与违约管理\r
- **5.2 生产过程控制 (IPQC)**\r
  - 首件/巡检/末件检验任务\r
  - 压铸工艺参数监控\r
  - 铸件检验与质量档案\r
  - 围堵单管理\r
  - 防错装置验证点检\r
- **5.3 最终检验与出货 (FQC/OQC)**\r
  - FQC终检任务\r
  - OQC出货检验\r
  - 不合格品报废申请与审理\r
  - 让步接收(特采)单\r
  - 返工/返修单管理\r
- **5.4 实验室管理 (Lab)**\r
  - 实验室送检任务\r
  - 实验室检测执行\r
  - 检测仪器设备监控\r
\r
### 6. 质量检查与评价 (Check)\r
*常态化指标监控、审核评价与客户反馈收集*\r
- QRQC快速反应\r
- SPC控制与分析\r
- MSA测量系统分析\r
- 客户满意度调查\r
- 分层过程审核\r
- 体系审核跟踪\r
- 管理评审执行记录\r
\r
### 7. 质量改进与行动 (Act)\r
*异常处理闭环与持续改进机制*\r
- 客诉/客退登记与处理\r
- 8D报告管理与追踪\r
- 纠正与预防措施管理\r
- 变化点申请与评估\r
\r
### 8. 数字化追溯 (Digital Traceability)\r
*对产品全生命周期的人机料法环测信息进行正向、逆向追溯及分析监控*\r
- **8.1 追溯查询**\r
  - 全链路追溯查询\r
  - 产品谱系图\r
  - 时序逻辑视图\r
- **8.2 正向与逆向分析**\r
  - 物料流追踪\r
  - 质量溯源分析\r
  - 相似性风险预警\r
- **8.3 统计与监控**\r
  - 追溯完整度报告\r
  - 供应链协调报告\r
\r
### 9. 质量成本管理 (Cost of Quality)\r
*财务与质量交叉模块，用于量化质量损失与改善收益*\r
- 质量成本科目定义\r
- 质量成本预算与计划\r
- 质量成本数据中心\r
- 质量成本核算单\r
- 成效与改善报告看板\r
\r
### 10. 知识库与培训 (Knowledge & Training)\r
*对应文档：第18章 知识库、20章 文档控制、22章 培训管理*\r
- 受控文档管理\r
- 质量经验库\r
- 培训管理\r
\r
### 11. 系统设置与集成 (System Settings)\r
*对应文档：第29-36章 安全权限与集成联动*\r
- 组织架构\r
- 角色权限\r
- 业务流转审批流配置\r
- 模块集成监控层\r
- 系统操作日志\r
- 审计追踪\r
- 系统参数\r
- 系统模板\r
- 数据应用\r
- 系统更新日志\r
- 系统公告\r
- 系统配置\r
- 菜单管理\r
- 系统监控\r
- 数据字典\r
---\r
\r
## 3. 设计亮点与预期收益\r
\r
1. **基于 PDCA 闭环模型**：主业务菜单按照 \`策划(Plan) -> 执行(Do) -> 检查(Check) -> 改进(Act)\` 重新组织，实现从先期防范、检验控制、审核监控到改善行动的闭环管理。\r
2. **深度集成压铸行业特性**：将**压铸工艺参数监控**和**铸件质量档案**融入过程执行层，强化核心制造过程的质量把控。\r
3. **补强实验室业务版图**：纳入**送检任务管理**与**实验室检测**模块，填补了在测试评价方面等关键业务的空缺。\r
4. **异常管理与持续改善并重**：QRQC、SPC、8D以及CAPA分别在“检查”与“改进”环节发挥关键作用，保障缺陷问题被强制闭环追踪。\r
5. **底层易拓展性强**：底层支撑与数据集成层独立设置，支持未来便捷接入更多第三方系统的监控入口与分析应用。\r
`,se=`# 供应商档案 (Supplier Archive) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：供应商档案管理\r
**所属子系统**：基础数据管理模块\r
**目标**：对企业的各类供应商（原材料、设备、服务等）进行统一的主数据维护，满足多工厂化组织层级的数据管控需求，并加强对供应商相关资质证明文件的监管。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 整体布局\r
页面结构维持系统的统一交互规范，采用典型的“条件查询 + 数据操作 + 列表展示”的主体布局结构。\r
\r
### 2.2 搜索区设计\r
- **所属组织**：支持多选的下拉组织选择器，控制数据视界。\r
- **供应商编码**：输入框检索。\r
- **供应商名称**：输入框检索。\r
- **供应商等级**：A/B/C 三级下拉筛选。\r
- **供应类型**：下拉单选（原材料 / 设备 / 服务 / 其他）。\r
- **状态**：启用/禁用状态筛选。\r
\r
### 2.3 操作栏功能\r
- 支持常规的：新增、编辑、删除（批量）、状态变更（启用/禁用）、刷新。\r
- **导入功能**：集成“下载模板”与“文件上传”下拉操作，支持将Excel格式的供应商名单批量录入系统。\r
- **导出功能**：前端/后端导出过滤后的列表台账。\r
\r
## 3. 核心功能设计\r
### 3.1 多组织适配\r
- 融合 \`orgId\` 机制处理视图数据域。\r
- 新增与调整操作中，“所属组织”为强制前置字段。\r
- 列表对不同组织属性做颜色视觉隔离，例如“集团”层级和具体工厂使用不同色块。\r
\r
### 3.2 资质证明及有效期预警管理\r
- 由于供应商通常需要具备特种资质或 ISO 体系认证，系统特别增加了“资质附件管理”区块。\r
- 新增 **\`资质证明 (qualifications)\`**：上传营业执照、认证报告等文件的组件。\r
- 新增 **\`资质有效期 (qualificationExpiry)\`**：支持选择有效截止日期。\r
- **自动预警评估**：利用前端 \`computed\` (基于 dayjs) 或后端定时任务，动态计算当前时间是否已超过资质有效期。若识别已过期，表单编辑界面将展示红色 \`<a-alert>\` 强提醒，督促采购或质量人员及时联系供应商进行证件更新。\r
\r
## 4. 数据模型 (Data Model)\r
核心实体 \`Supplier\` 属性定义：\r
- \`id\`: 唯一主键\r
- \`orgId\`: 所属组织标识\r
- \`supplierCode\`: 供应商编码\r
- \`supplierName\`: 供应商名称\r
- \`supplierLevel\`: 供应商等级\r
- \`supplyType\`: 供应类型\r
- \`creditLevel\`: 信用分/级别的量化考核值\r
- \`cooperationYears\`: 合作年限\r
- \`creditCode\`: 统一社会信用代码\r
- \`legalPerson\`: 法人代表\r
- \`phone\` / \`email\` / \`address\`: 基础联系信息\r
- \`status\`: 生命周期状态标识\r
- \`qualifications\`: 资质证明附件集合\r
- \`qualificationExpiry\`: 资质有效期 (Date)\r
\r
## 5. 约束与规则\r
- **关联限制**：已被来料检验（IQC）单据引用的供应商不可被物理删除。\r
- **过期限制**：在部分深层次业务（如发放下单）中，若遇到资质已过期供应商可拦截报警（本页面为基础定义，拦截动作落地于其他业务链）。\r
`,oe="# 储存地点管理 (Storage Location) - 详细设计文档\r\n\r\n## 1. 模块概述\r\n**模块名称**：库位/储存地点关联管理\r\n**所属子系统**：基础数据 / 辅仓储模块\r\n**目标**：统一定义和精细化管理厂区内的储位三维空间资源，建立容积率模型，同时针对高危及特定物料记录强制性的现场环控条件（如温湿度、消防要求等），辅助IQC验收入库和现场质检防呆预警。\r\n\r\n## 2. 界面布局与交互设计\r\n### 2.1 查询与操作\r\n- 具有标准的多维度搜索栏目（编码、名称、地点类型——包括仓库、车间、室外等）。\r\n- 操作按钮提供常规的增改删导体系，批量状态控制等。\r\n\r\n### 2.2 数据表格特色组件 (进度条)\r\n- **容量可视化机制**：表格内引入并重点打磨了 **容量使用情况 (`capacity`)** 的 `a-progress` 进度条列设计。\r\n  - 根据 `已用容量 / 总容量` 动态计算百分比。\r\n  - 若超出安全阈值 (例如 80% 变为警告活跃态，>90% 变为异常红色警告态)，直观呈现库区的爆仓压力。\r\n\r\n## 3. 核心功能设计\r\n### 3.1 环境控制体系 (Environmental Storage Conditions)\r\n此页面表单针对 QMS 典型的储藏变异情况额外新增了多个质量前置限定字段：\r\n- **温湿度范围录入 (`temperature`, `humidity`)**：限制例如部分电子料对 `18-25℃ / 40-60%` 绝对湿度的强需求登记。\r\n- **危化品及环安限制录入 (`ventilation`, `fireLevel`)**：下拉选择如防火等级 A/B/C 及对应的通风环境等级。\r\n\r\n### 3.2 空间分配机制\r\n- 提供全量的三维容量 `totalCapacity` 记录。\r\n- 该容量模块预留了外接出入库实时接口对接，计算出的 `usedCapacity` 可做前端阻断（例如超出容量禁止新建入库任务，这在需求链内预留了扩展锚点）。\r\n\r\n### 3.3 表单组块分段\r\n由于字段涵盖业务、环境、物理三维度，其添加/编辑表单使用 `a-divider` （分隔线）进行了业务语义化分割为：\r\n1. 基本定义段 (名称/类型/尺寸)\r\n2. 责任分配信息段 (部门/责任人/电话)\r\n3. 存储环控条件段 (温湿度/防火等)\r\n\r\n## 4. 数据模型 (Data Model)\r\n核心实体 `StorageLocation` 属性定义：\r\n- `id`: 唯一编号\r\n- `locationCode`: 物理储存编码 (如：WH001)\r\n- `locationName`: 名称\r\n- `locationType`: 分类（`warehouse`, `workshop`, `office`, `outdoor` 等）\r\n- `departmentId`: 运维挂靠部门\r\n- `managerId`: 行政/质量看守责任人\r\n- `totalCapacity`: 总体积或安全存放面积数\r\n- `usedCapacity`: 目前统计被占据数值\r\n- `phone`, `address`: 地理通信信息\r\n- `temperature`: 指导存储温度设定\r\n- `humidity`: 指导存储湿度设定\r\n- `ventilation`: 通风安全度级别\r\n- `fireLevel`: 必须满足的防火等级预设\r\n- `specialRequirements`: 人工补充的其他条件（如防潮、隔离存放等）\r\n- `status`: 状态\r\n\r\n## 5. 约束与规则\r\n- **可用性检验**：对环境要求极其严苛且状态标记为禁用的区域，后续 WMS 服务不允许下发转移物料到该片区的指令。\r\n- **空间合理性**：表单录入时，总容量 (`totalCapacity`) 不允许录入负数。\r\n",le=`# 客供关系映射 详细设计说明书\r
\r
## 1. 文档信息\r
\r
- **模块名称**：基础数据 / 客供关系映射\r
- **产品版本**：v1.1.0\r
- **当前状态**：设计中\r
- **目标受众**：开发人员、测试人员、实施团队\r
\r
## 2. 业务背景与目标\r
\r
在制造业供应链质量协同管理（SQM/CQM）中，客户、企业内部、供应商三方的系统经常处于独立运转状态，导致物料编码、质量标准名称、追溯批次等信息出现“各说各话”的孤岛现象。\r
\r
本模块的核心目标是：\r
1. **打破数据孤岛**：建立跨企业边界的数据对照与翻译机制。\r
2. **全生命周期追溯**：将客户物料打通内部系统再延伸至源头供应商，实现“客户 -> 成品 -> 工序 -> 原材料 -> 供应商”的端到端正反向追溯。\r
3. **统一质量语言**：将客户特殊要求（CTQ）等外部标准映射为内部可执行、可检验的标准化检验项目（Inspection Item）。\r
\r
## 3. 功能架构设计\r
\r
本模块包含三大核心子业务：\r
\r
1. **物料编码映射（双向）**\r
   - 实现外部系统物料编码（客户/供应商）与内部 QMS 标准物料编码的绑定。\r
2. **CTQ标准协同**\r
   - 实现客户特殊特性（CC/SC/一般特性）与内部质量检验标准的同步关联。\r
3. **追溯关系配置**\r
   - 定义产品从供应商原材料经过各生产工序直至交付客户的逻辑追溯链路图。\r
\r
## 4. 页面与交互设计\r
\r
页面采用“左侧条件过滤+右侧数据操作”或直接使用“Tabs页签切换”的设计模式。已采用 \`Tabs页签\` 的结构将三个子业务有效隔离并聚合在一个管理入口内。\r
\r
### 4.1 Tab 1：物料编码映射\r
- **查询区**：支持按客户/供应商、外部物料编码、内部物料编码、状态进行筛选。\r
- **列表区**：展示映射方向、客供名称、外部编码名称、内部编码名称及状态。\r
- **操作区**：支持新增、编辑、查看、批量启用/禁用及单个/批量删除功能。\r
- **表单设计**：\r
  - **映射方向**：单选（客户方向 / 供应商方向）。\r
  - **客户/供应商**：下拉选择（带搜索过滤）。\r
  - **外部物料/名称**：文本输入（对接系统的外部物料唯一标识）。\r
  - **内部标准物料**：下拉选择内部物料库数据。\r
  - **状态/备注**：启用禁用开关及详情备注。\r
\r
### 4.2 Tab 2：CTQ 标准协同\r
- **查询区**：支持按客户名称、CTQ 特性名称检索。\r
- **列表区**：展示客户名称、CTQ 特性、严重等级（关键、重要、一般）、关联的内部物料及检验项、标准描述及同步状态。\r
- **操作区**：支持同步（一键将CTQ生成为内部检验方案的检验项目）和详细查看。\r
\r
### 4.3 Tab 3：追溯关系配置\r
- **查询区**：按成品物料、客户名称搜索。\r
- **列表区**：展示产品全链路追溯路径。以组件（例：\`a-steps\`）直观呈现：\`供应商\` -> \`原材料\` -> \`生产工序\` -> \`成品\` -> \`客户\`的层级关系。\r
- **操作区**：支持可视化追溯链路查看与编辑追溯链配置。\r
\r
## 5. 数据模型设计\r
\r
为了支撑上述业务功能，数据库需要设计以下相关的物理表。\r
\r
### 5.1 物料编码映射表（\`qms_material_mapping\`）\r
\r
**说明**：用于存储外部单位（客户或供应商）物料信息与内部标准物料档案的对照关系。\r
\r
| 字段名称 | 物理字段名 | 数据类型 | 约束 | 描述说明 |\r
| :--- | :--- | :--- | :--- | :--- |\r
| 主键ID | \`id\` | VARCHAR(64) | PK | 唯一标识 |\r
| 租户ID | \`tenant_id\` | VARCHAR(64) | INDEX | 多租户隔离 |\r
| 映射方向 | \`direction\` | VARCHAR(20) | NOT NULL | \`customer\`=客户方向; \`supplier\`=供应商方向 |\r
| 客供ID | \`partner_id\` | VARCHAR(64) | INDEX | 关联客供关系档案表主键 |\r
| 外部物料编码 | \`external_code\` | VARCHAR(100) | NOT NULL | 外部系统物料编码 |\r
| 外部物料名称 | \`external_name\` | VARCHAR(200) | | 外部系统物料名称 |\r
| 内部物料ID | \`internal_material_id\` | VARCHAR(64) | INDEX | 关联基础数据-内部物料表主键 |\r
| 状态 | \`status\` | VARCHAR(10) | DEFAULT '1' | \`1\`=启用, \`0\`=禁用 |\r
| 备注说明 | \`remark\` | VARCHAR(500) | | 备注 |\r
| 创建人 | \`create_by\` | VARCHAR(64) | | 创建者ID |\r
| 创建时间 | \`create_time\` | DATETIME | | 记录创建时间 |\r
| 更新人 | \`update_by\` | VARCHAR(64) | | 更新者ID |\r
| 更新时间 | \`update_time\` | DATETIME | | 记录更新时间 |\r
\r
### 5.2 CTQ特性标准映射表（\`qms_ctq_mapping\`）\r
\r
**说明**：存储接收到的客户特殊要求，并记录其与系统内部质检模型的匹配状态。\r
\r
| 字段名称 | 物理字段名 | 数据类型 | 约束 | 描述说明 |\r
| :--- | :--- | :--- | :--- | :--- |\r
| 主键ID | \`id\` | VARCHAR(64) | PK | 唯一标识 |\r
| 客户ID | \`customer_id\` | VARCHAR(64) | INDEX | 关联客户档案主键 |\r
| 关联物料ID | \`material_id\` | VARCHAR(64) | INDEX | 受影响的产品物料主键 |\r
| CTQ特性名称 | \`ctq_name\` | VARCHAR(100) | NOT NULL | 客户方定义的特性名称 |\r
| 严重等级 | \`severity\` | VARCHAR(20) | NOT NULL | \`critical\`=关键(CC), \`major\`=重要(SC), \`minor\`=一般 |\r
| 标准及要求描述| \`standard_desc\` | TEXT | | 客户提供的公差或检验标准 |\r
| 内部检验项ID | \`insp_item_id\` | VARCHAR(64) | INDEX | 映射到的内部检验项ID (可为空) |\r
| 同步状态 | \`sync_status\` | VARCHAR(20) | DEFAULT 'pending'| \`pending\`=待同步, \`synced\`=已同步 |\r
| 创建人 | \`create_by\` | VARCHAR(64) | | 创建者ID |\r
| 创建时间 | \`create_time\` | DATETIME | | |\r
\r
### 5.3 全链路追溯节点配置表（\`qms_traceability_link\`）\r
\r
**说明**：用于配置一条产品的宏观追溯依赖链条，供业务追踪展示及正反向检索时使用。\r
\r
| 字段名称 | 物理字段名 | 数据类型 | 约束 | 描述说明 |\r
| :--- | :--- | :--- | :--- | :--- |\r
| 主键ID | \`id\` | VARCHAR(64) | PK | 唯一标识 |\r
| 客户ID | \`customer_id\` | VARCHAR(64) | INDEX | 交付对象（客户） |\r
| 成品物料ID | \`product_material_id\` | VARCHAR(64) | INDEX | 最终交付成品 |\r
| 关联生产工序ID| \`process_route_id\` | VARCHAR(64) | INDEX | 生产流转路径/工艺 |\r
| 原材料物料ID | \`raw_material_id\` | VARCHAR(64) | INDEX | 主要追溯的原材料 |\r
| 供应商ID | \`supplier_id\` | VARCHAR(64) | INDEX | 原材料供应商 |\r
| 配置状态 | \`status\` | VARCHAR(10) | DEFAULT '1' | \`1\`=有效, \`0\`=失效 |\r
| 数据版本号 | \`version\` | INT | DEFAULT 1 | 乐观锁及配置变更版本控制 |\r
\r
## 6. 核心接口设计 (API)\r
\r
### 6.1 物料编码映射 API\r
- **获取映射分页列表**：\`GET /api/v1/basic-data/material-mappings\`\r
- **创建物料映射**：\`POST /api/v1/basic-data/material-mappings\`\r
- **更新物料映射**：\`PUT /api/v1/basic-data/material-mappings/{id}\`\r
- **删除物料映射**：\`DELETE /api/v1/basic-data/material-mappings/{id}\`\r
- **批量更新状态**：\`PATCH /api/v1/basic-data/material-mappings/status\`\r
\r
### 6.2 CTQ 与检验标准 API\r
- **获取CTQ列表**：\`GET /api/v1/basic-data/ctq-mappings\`\r
- **执行CTQ标准同步**：\`POST /api/v1/basic-data/ctq-mappings/{id}/sync\`\r
  - *逻辑描述*：将 CTQ 标准快速写入检验项目库（Insp Item），并将生成的 \`insp_item_id\` 回写至本表，状态置为 \`synced\`。\r
\r
### 6.3 追溯关系 API\r
- **获取追溯配置连列表**：\`GET /api/v1/basic-data/traceability-links\`\r
- **获取某个成品的完整追溯视图**：\`GET /api/v1/basic-data/traceability-links/view/{productMaterialId}\`\r
\r
## 7. 权限与安全说明\r
\r
1. **功能权限**：\r
   - 客户维度的配置需校验用户是否具有“客诉管理/客户协同”模块权限。\r
   - 供应商维度的配置需校验用户是否具有“供应商管理(SQM)”模块操作权限。\r
2. **数据权限**：\r
   - 使用 \`tenant_id\` 进行 SaaS 多租户数据隔离。\r
   - 表单中所有涉及外部传参处，应对 \`internal_material_id\` 以及 \`partner_id\` 的合法性及其当前业务状态（是否停用）进行数据强校验，避免脏数据写入。\r
`,ce=`# 客户档案 (Customer Archive) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：客户档案管理\r
**所属子系统**：基础数据管理模块\r
**目标**：维护企业所有客户的主数据信息，支持多组织数据隔离、资质附件管理与批量数据导入，为销售、发货及客诉等后续业务提供基础数据支撑。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 整体布局\r
页面采用标准的“上中下”上下分层布局：\r
- **顶部查询区 (Search Card)**：提供多种组合查询条件。\r
- **中部操作栏 (Toolbar)**：提供全局业务操作按钮。\r
- **下部数据区 (Table Container)**：以分页表格形式展示客户台账列表。\r
\r
### 2.2 搜索区设计\r
包含以下检索条件：\r
- **所属组织**：多选下拉框 (选项：集团、合肥工厂、芜湖工厂)，用于按组织域过滤客户。\r
- **客户编码**：文本精确/模糊检索。\r
- **客户名称**：文本精确/模糊检索。\r
- **客户等级**：下拉选择 (A级、B级、C级)。\r
- **客户类型**：下拉选择 (国内、海外、内部交易)。\r
- **状态**：下拉选择 (启用、禁用)。\r
\r
### 2.3 操作栏设计\r
- **新增**：打开新增客户的抽屉或弹窗。\r
- **编辑**：选中单条记录后激活，打开编辑表单。\r
- **删除**：批量删除选定的记录。\r
- **状态操作**：下拉菜单支持“批量启用”和“批量禁用”。\r
- **导入**：下拉菜单包含“下载导入模板”和“上传Excel文件”。\r
- **导出**：将目前查询结果导出为 Excel。\r
- **刷新**：重新加载当前表格数据。\r
\r
## 3. 核心功能设计\r
### 3.1 多组织支持 (Multi-Organization)\r
- 在数据模型中增加 \`orgId\` 字段。\r
- 列表页展示“所属组织”列，通过 \`Tag\` 标签使用不同颜色做视觉区分（集团为紫色，合肥工厂为蓝色，芜湖工厂为青色）。\r
- 搜索表单支持按组织维度圈定数据可见范围。\r
- 新增/编辑表单中，必须指定该客户档案归属的组织。\r
\r
### 3.2 资质附件管理\r
- 在新增及编辑表单中，添加了独立的“资质附件管理”区块。\r
- 使用 \`a-upload\` 组件实现多文件上传及列表展示管理。\r
- 保存时附件记录序列化并随主对象保存。\r
\r
### 3.3 导入与导出\r
- **导入**：利用不可见的 \`<input type="file">\` 实现文件选择，拦截系统默认行为，使用前端 FileReader 解析或上传给后端接口。\r
- **导出**：封装通用工具方法，将当前在前端的展示数据转换为 CSV 或 Excel 格式供用户下载保存。\r
\r
## 4. 数据模型 (Data Model)\r
核心实体 \`Customer\` 属性定义：\r
- \`id\`: 唯一主键\r
- \`orgId\`: 所属组织标识 (Group / 1 / 2)\r
- \`customerCode\`: 客户编码\r
- \`customerName\`: 客户名称\r
- \`customerLevel\`: 客户等级\r
- \`customerType\`: 客户类型\r
- \`creditLevel\`: 信用等级\r
- \`contactPerson\`: 联系人\r
- \`phone\`: 联系电话\r
- \`address\`: 联系地址\r
- \`remark\`: 备注\r
- \`status\`: 状态 (0: 禁用, 1: 启用)\r
- \`attachments\`: 资质附件列表 (Array)\r
\r
## 5. 约束与规则\r
- **唯一性约束**：同一组织下的客户编码必须唯一。\r
- **必填项验证**：所属组织、客户编码、客户名称、联系人等为必填字段。\r
- **权限控制**：编辑和删除操作需具备对应的数据权限，只能看到分配的组织的数据。\r
`,pe=`# 顾客特殊要求(CSR)管理 详细设计说明书\r
\r
## 1. 文档信息\r
\r
- **模块名称**：基础数据 / 顾客特殊要求(CSR)管理\r
- **产品版本**：v1.2.0\r
- **当前状态**：开发中\r
- **目标受众**：开发人员、测试人员、实施团队\r
- **关联模块**：客供关系映射（CTQ标准协同 Tab）、CTQ 参数配置\r
\r
## 2. 业务背景与目标\r
\r
### 2.1 问题陈述\r
在汽车零部件制造的质量管理体系（IATF 16949）中，CTQ（关键质量特性）管理了标准化的技术参数，但对于客户特殊要求（CSR）的管控仍停留在纸面协议：\r
- **碎片化**：不同客户的 CSR 散落在 PDF 手册、邮件、会议纪要等载体中，缺乏统一管理。\r
- **依赖人工**：工程师需要"记得"某个客户要求每 500 件做全尺寸检验、质量记录保留 15 年、A类客诉 24 小时内回复 D3 等条款——极易遗忘或遗漏。\r
- **无法拦截**：即使知道有 CSR 要求，系统也无法在业务流程中自动校验和拦截，导致违规出货、超期回复等风险。\r
\r
### 2.2 建设目标\r
1. **结构化解析**：将纸面 CSR 协议分解为可枚举、可追踪的系统条款（Clause）。\r
2. **流程干预**：通过映射矩阵将条款与 QMS 业务流程节点（IQC/IPQC/OQC/客诉/APQP 等）绑定，在触发条件达成时执行拦截、预警或模板切换等系统动作。\r
3. **合规可视**：通过看板实时监控全厂 CSR 达成情况，暴露超期和风险项。\r
4. **CTQ 联动**：将 CTQ 参数配置与 CSR 源条款建立关联关系，当 CSR 协议升级时自动提醒 CTQ 同步更新。\r
\r
## 3. 核心模型架构\r
\r
模块采用**三层设计模型**：\r
\r
\`\`\`\r
┌──────────────────────────────────────────────────────────────┐\r
│  第一层：输入解析层 (Requirement Repository)                    │\r
│  ─ 管理客户 CSR 协议文件，分解为结构化条款                        │\r
│  ─ 维护：客户、版本、类型、严格度、标准约束                        │\r
├──────────────────────────────────────────────────────────────┤\r
│  第二层：关联映射层 (Process Mapping Matrix)                    │\r
│  ─ 配置条款与业务流程节点的挂载关系                               │\r
│  ─ 定义：适用工厂/物料范围、触发条件、执行动作                      │\r
├──────────────────────────────────────────────────────────────┤\r
│  第三层：触发执行层 (Automated Action Engine)                   │\r
│  ─ 部署于业务流程入口的拦截器                                    │\r
│  ─ 执行：警告拦截、强制锁定、超期计时、模板切换                     │\r
└──────────────────────────────────────────────────────────────┘\r
\`\`\`\r
\r
## 4. 功能架构设计\r
\r
本模块包含三大核心子业务，以 Tabs 页签聚合在同一管理入口（\`/basic-data/csr-management\`）：\r
\r
1. **CSR 条款维护空间 (Requirement Repository)**\r
   - 以客户维度管理 CSR 协议源文件及版本。\r
   - 将协议分解为结构化条款，定义类型、严格度和标准约束。\r
\r
2. **业务流程映射矩阵 (Process Mapping Matrix)**\r
   - 配置条款与 QMS 业务流程节点的挂载关系和触发条件。\r
   - 将静态条款转化为可执行的系统规则。\r
\r
3. **合规性监控看板 (Compliance Dashboard)**\r
   - 可视化展示全厂 CSR 达成率、覆盖率、风险告警等指标。\r
\r
4. **CTQ 标准协同（嵌入客供关系映射 Tab）**\r
   - 在"客供关系映射"页面的"CTQ标准协同"Tab 中增加"来源 CSR"超链接跳转。\r
   - CSR 协议版本变更时，在 CTQ 列表顶部弹出联动提醒横幅。\r
\r
## 5. 页面与交互设计\r
\r
### 5.1 CSR 条款维护空间\r
\r
- **操作工具栏**：新增条款、导入（支持 PDF/Word 附件解析）、导出。\r
- **查询区**：支持按客户名称/条款关键字 + 类型下拉筛选。\r
- **列表区**：展示客户、版本、类别、严格度（带 Tag 色彩区分）、标准约束、条款描述。\r
- **操作列**：编辑、配置映射（跳转映射矩阵）、删除（带二次确认）。\r
- **表单弹窗**（新增/编辑）：\r
  - **关联客户**：文本输入（后期改为下拉关联客户档案）。\r
  - **要求版本**：文本输入，格式如 \`V2024.1\`。\r
  - **要求类别**：下拉选择（体系要求 / 过程要求 / 交付要求）。\r
  - **严格度等级**：下拉选择（一般 / 重要 / 强控）。\r
  - **标准约束**：文本输入（如 \`24h\`、\`15 Years\`、\`每 500 件\`）。\r
  - **条款内容描述**：多行文本域。\r
  - **相关附件**：文件上传组件。\r
\r
### 5.2 业务流程映射矩阵\r
\r
- **查询区**：支持按物料/工厂/客户/条款关键字搜索。\r
- **列表区**：展示业务线/工厂、客户代码、适用范围、引用条款协议、干预流程节点、触发条件（紫色 Tag）、执行动作（红/青/橙 Tag）。\r
- **配置弹窗**：\r
  - **选择客户**：关联客户实体。\r
  - **引用条款协议**：级联选择，先选客户后选条款。\r
  - **干预的业务单据/流程**：下拉选择 QMS 中的触发点（IQC、车间报工、不合格品处置、OQC、APQP/FMEA 文档管理）。\r
  - **关联物料/产品族**：多选，留空表示适用全部。\r
  - **触发条件**：文本输入（如"报工数量达到 500"）。\r
  - **执行动作结果**：下拉（警告并拦截流程 / 自动切换报告模板 / 后台计时及超期预警）。\r
\r
### 5.3 合规性监控看板\r
\r
- **指标统计卡片（4张）**：\r
  - 生效条款总数（蓝色）。\r
  - 条款覆盖率（绿色，百分比）。\r
  - 任务按时完成率（黄色，百分比）。\r
  - 超期/告警风险项（红色，绝对数）。\r
- **CSR 达成率监控趋势（折线+柱状复合图）**：\r
  - 左 Y 轴：条款覆盖率 & 任务按时完成率（折线，平滑曲线+面积填充）。\r
  - 右 Y 轴：外审发现点（柱状图）。\r
  - X 轴：按月展示近半年数据。\r
- **条款类型分布（环形饼图）**：\r
  - 体系要求 / 过程要求 / 交付要求 的数量占比。\r
  - 圆角扇区 + 标签显示百分比。\r
- **实时风险告警列表**：\r
  - 字段：客户、条款描述、严格度、触发条件、状态（超期/即将触发/即将到期）、剩余时间。\r
  - 支持穿透到相关业务单据。\r
\r
### 5.4 CTQ 标准协同 — CSR 联动增强（嵌入客供关系映射页面）\r
\r
- **CSR 版本联动提醒横幅**：\r
  - 在 CTQ 标准协同 Tab 顶部，当检测到关联的 CSR 协议版本升级时，展示黄色 \`a-alert\` 提醒条。\r
  - 内容："客户 **{客户名}** 的 CSR 协议已从 \`旧版本\` 更新至 \`新版本\`，请核对并同步更新以下 CTQ 参数阈值。"\r
  - 提供"查看受影响的 CTQ →"快捷链接，点击自动过滤。\r
- **"来源 CSR"列**：\r
  - 表格新增"来源 CSR"列，显示为蓝色超链接。点击后路由跳转至 \`/basic-data/csr-management\`。\r
  - 未关联的 CTQ 显示灰色"未关联"。\r
- **"CSR 版本"列**：\r
  - 绿色 Tag 表示版本一致。红色 Tag + ⚠ 叹号图标表示版本已过时。\r
  - 鼠标悬停显示 Tooltip："CSR 协议版本已更新，请核查本项参数"。\r
- **CTQ 详情弹窗增强**：\r
  - 底部新增"来源 CSR"描述行，含超链接跳转、版本号 Tag 和过期警告文字。\r
\r
## 6. 数据模型设计\r
\r
### 6.1 实体关系概览\r
\r
\`\`\`\r
qms_csr_protocol (协议主表)\r
    │\r
    ├── 1:N ──→ qms_csr_clause (条款明细表)\r
    │               │\r
    │               └── 1:N ──→ qms_csr_process_mapping (业务流程映射表)\r
    │                               │\r
    │                               └── 1:N ──→ qms_csr_trigger_log (触发执行记录表)\r
    │\r
    └── 1:N ──→ qms_csr_protocol_attachment (协议附件表)\r
\r
qms_ctq_mapping (已有CTQ映射表)\r
    │\r
    └── N:1 ──→ qms_csr_clause (通过 csr_clause_id 外键关联)\r
\`\`\`\r
\r
### 6.2 CSR 协议主表（\`qms_csr_protocol\`）\r
\r
**说明**：记录各个客户不同版本的 CSR 协议声明或合同。一个客户可拥有多个版本的协议。\r
\r
| 字段名称     | 物理字段名      | 数据类型      | 约束            | 描述说明                                    |\r
| :----------- | :-------------- | :------------ | :-------------- | :------------------------------------------ |\r
| 主键ID       | \`id\`            | VARCHAR(64)   | PK              | 唯一标识                                    |\r
| 租户ID       | \`tenant_id\`     | VARCHAR(64)   | INDEX           | 多租户隔离                                  |\r
| 客户ID       | \`customer_id\`   | VARCHAR(64)   | NOT NULL, INDEX | 关联客户档案表(\`qms_customer\`)主键           |\r
| 协议编号     | \`protocol_no\`   | VARCHAR(50)   | NOT NULL, UQ    | 协议唯一编号                                |\r
| 版本号       | \`version\`       | VARCHAR(20)   | NOT NULL        | 版本号 (如 V1.0, V2024.1)                   |\r
| 状态         | \`status\`        | VARCHAR(20)   | DEFAULT 'DRAFT' | DRAFT=草稿, ACTIVE=生效中, ARCHIVED=已归档  |\r
| 生效日期     | \`valid_from\`    | DATE          | NOT NULL        | 协议生效起始日期                            |\r
| 失效日期     | \`valid_to\`      | DATE          |                 | 协议失效日期（空=长期有效）                  |\r
| 协议摘要     | \`summary\`       | VARCHAR(500)  |                 | 协议整体概要描述                            |\r
| 创建人       | \`create_by\`     | VARCHAR(64)   |                 | 创建者ID                                    |\r
| 创建时间     | \`create_time\`   | DATETIME      | DEFAULT NOW()   | 记录创建时间                                |\r
| 更新人       | \`update_by\`     | VARCHAR(64)   |                 | 更新者ID                                    |\r
| 更新时间     | \`update_time\`   | DATETIME      |                 | 记录更新时间                                |\r
| 逻辑删除标记 | \`deleted\`       | TINYINT(1)    | DEFAULT 0       | 0=正常, 1=已删除                            |\r
\r
**索引设计**：\r
- \`idx_protocol_customer\`: (\`tenant_id\`, \`customer_id\`)\r
- \`idx_protocol_status\`: (\`tenant_id\`, \`status\`)\r
- \`uq_protocol_no\`: (\`tenant_id\`, \`protocol_no\`) UNIQUE\r
\r
### 6.3 协议附件表（\`qms_csr_protocol_attachment\`）\r
\r
**说明**：存储与 CSR 协议关联的附件文件信息（PDF/Word 等原始手册）。\r
\r
| 字段名称     | 物理字段名       | 数据类型      | 约束            | 描述说明                         |\r
| :----------- | :--------------- | :------------ | :-------------- | :------------------------------- |\r
| 主键ID       | \`id\`             | VARCHAR(64)   | PK              | 唯一标识                         |\r
| 协议ID       | \`protocol_id\`    | VARCHAR(64)   | NOT NULL, INDEX | 关联 \`qms_csr_protocol.id\`       |\r
| 文件名称     | \`file_name\`      | VARCHAR(200)  | NOT NULL        | 原始文件名                       |\r
| 文件路径     | \`file_path\`      | VARCHAR(500)  | NOT NULL        | 文件存储路径或对象存储 Key       |\r
| 文件大小     | \`file_size\`      | BIGINT        |                 | 文件大小（字节）                 |\r
| 文件类型     | \`file_type\`      | VARCHAR(20)   |                 | 文件 MIME 类型（pdf/docx 等）    |\r
| 上传人       | \`upload_by\`      | VARCHAR(64)   |                 | 上传者ID                         |\r
| 上传时间     | \`upload_time\`    | DATETIME      | DEFAULT NOW()   | 上传时间                         |\r
\r
### 6.4 协议条款明细表（\`qms_csr_clause\`）\r
\r
**说明**：将 CSR 协议源文件拆解为结构化、原子化、可追踪的业务约束条款。每条协议可拥有多个条款。\r
\r
| 字段名称       | 物理字段名        | 数据类型       | 约束              | 描述说明                                             |\r
| :------------- | :---------------- | :------------- | :---------------- | :--------------------------------------------------- |\r
| 主键ID         | \`id\`              | VARCHAR(64)    | PK                | 唯一标识                                             |\r
| 协议ID         | \`protocol_id\`     | VARCHAR(64)    | NOT NULL, INDEX   | 关联 \`qms_csr_protocol.id\`                           |\r
| 条款编号       | \`clause_no\`       | VARCHAR(30)    | NOT NULL          | 条款序号或编码（如 CSR-001）                         |\r
| 要求类别       | \`req_type\`        | VARCHAR(30)    | NOT NULL          | SYSTEM=体系要求, PROCESS=过程要求, DELIVERY=交付要求 |\r
| 严格度等级     | \`severity_level\`  | VARCHAR(20)    | DEFAULT 'NORMAL'  | NORMAL=一般, IMPORTANT=重要, CRITICAL=强控           |\r
| 标准约束       | \`standard_value\`  | VARCHAR(100)   |                   | 提取的核心阈值（如 24h, 15Years, 500pcs, 100%）      |\r
| 条款描述       | \`description\`     | VARCHAR(2000)  | NOT NULL          | 条款具体的原始业务描述文本                           |\r
| 显示排序       | \`sort_order\`      | INT            | DEFAULT 0         | 列表排序                                             |\r
| 状态           | \`status\`          | VARCHAR(20)    | DEFAULT 'ACTIVE'  | ACTIVE=生效, DISABLED=停用                           |\r
| 创建人         | \`create_by\`       | VARCHAR(64)    |                   | 创建者ID                                             |\r
| 创建时间       | \`create_time\`     | DATETIME       | DEFAULT NOW()     | 记录创建时间                                         |\r
| 更新人         | \`update_by\`       | VARCHAR(64)    |                   |                                                      |\r
| 更新时间       | \`update_time\`     | DATETIME       |                   |                                                      |\r
\r
**索引设计**：\r
- \`idx_clause_protocol\`: (\`protocol_id\`)\r
- \`idx_clause_type_severity\`: (\`req_type\`, \`severity_level\`)\r
\r
### 6.5 业务流程映射矩阵表（\`qms_csr_process_mapping\`）\r
\r
**说明**：定义 CSR 条款应该在何时(When)、在何处(Where)、针对什么范围(Scope)、执行何种动作(Action)的系统逻辑配置。每条条款可挂载多条映射规则。\r
\r
| 字段名称         | 物理字段名          | 数据类型      | 约束            | 描述说明                                                                 |\r
| :--------------- | :------------------ | :------------ | :-------------- | :----------------------------------------------------------------------- |\r
| 主键ID           | \`id\`                | VARCHAR(64)   | PK              | 唯一标识                                                                 |\r
| 条款ID           | \`clause_id\`         | VARCHAR(64)   | NOT NULL, INDEX | 关联 \`qms_csr_clause.id\`                                                 |\r
| 工厂组织ID       | \`factory_id\`        | VARCHAR(64)   | NOT NULL, INDEX | 适用的工厂/组织 ID                                                       |\r
| 物料范围类型     | \`material_scope_type\`| VARCHAR(20)  | DEFAULT 'ALL'   | ALL=全部, CATEGORY=按分类, SPECIFIC=指定物料                             |\r
| 物料范围值       | \`material_scope_val\`| JSON          |                 | 具体的物料分类 ID 或物料 ID 数组 (JSON Array)                            |\r
| 业务节点         | \`business_node\`     | VARCHAR(50)   | NOT NULL        | 被干预的 QMS 业务节点枚举：IQC_INSPECTION, PROCESS_REPORT, CUSTOMER_COMPLAINT, OQC_INSPECTION, DOC_CONTROL |\r
| 触发条件         | \`trigger_condition\` | VARCHAR(500)  |                 | 触发条件表达式（SpEL / JSON 格式供引擎解析）                             |\r
| 触发条件描述     | \`trigger_desc\`      | VARCHAR(200)  |                 | 面向用户的触发条件自然语言描述                                           |\r
| 执行动作类型     | \`action_type\`       | VARCHAR(30)   | NOT NULL        | BLOCK=警告拦截, SWITCH_TEMPLATE=切换模板, START_TIMER=超期计时预警       |\r
| 执行动作参数     | \`action_params\`     | JSON          |                 | 动作附加参数（如模板ID、SLA时长等）                                      |\r
| 是否启用         | \`is_active\`         | TINYINT(1)    | DEFAULT 1       | 1=启用, 0=停用                                                          |\r
| 创建人           | \`create_by\`         | VARCHAR(64)   |                 | 创建者ID                                                                 |\r
| 创建时间         | \`create_time\`       | DATETIME      | DEFAULT NOW()   |                                                                          |\r
| 更新人           | \`update_by\`         | VARCHAR(64)   |                 |                                                                          |\r
| 更新时间         | \`update_time\`       | DATETIME      |                 |                                                                          |\r
\r
**关键枚举说明**：\r
\r
\`business_node\` 枚举值：\r
\r
| 枚举值                | 含义              | 典型触发场景                     |\r
| :-------------------- | :---------------- | :------------------------------- |\r
| IQC_INSPECTION        | 来料检验单        | 来料送检时检查是否符合特殊要求   |\r
| PROCESS_REPORT        | 车间报工/过程检验 | 报工数量累计达到阈值时触发       |\r
| CUSTOMER_COMPLAINT    | 不合格品处置/客诉 | 客诉单创建时启动 SLA 计时        |\r
| OQC_INSPECTION        | 出货检验          | 出货审核时校验强控项是否全部通过 |\r
| DOC_CONTROL           | APQP/FMEA文档管理 | 新建质量记录时标记保留期限       |\r
\r
\`action_type\` 枚举值：\r
\r
| 枚举值           | 含义            | 执行效果                                                   |\r
| :--------------- | :-------------- | :--------------------------------------------------------- |\r
| BLOCK            | 警告拦截        | 阻断当前业务操作，强控项（CRITICAL）锁定出货               |\r
| SWITCH_TEMPLATE  | 切换模板        | 强制当前检验单加载指定的客户专用检验模板                   |\r
| START_TIMER      | 超期计时预警    | 后台启动倒计时，到期未完成则升级告警或锁定流程             |\r
\r
**索引设计**：\r
- \`idx_mapping_clause\`: (\`clause_id\`)\r
- \`idx_mapping_factory_node\`: (\`factory_id\`, \`business_node\`)\r
- \`idx_mapping_active\`: (\`is_active\`)\r
\r
### 6.6 触发与执行记录表（\`qms_csr_trigger_log\`）\r
\r
**说明**：记录管控引擎在实际业务流中的触发命中日志。用于合规看板的达成率计算、告警列表展示、以及外审证据追溯。\r
\r
| 字段名称         | 物理字段名         | 数据类型      | 约束            | 描述说明                                                     |\r
| :--------------- | :----------------- | :------------ | :-------------- | :----------------------------------------------------------- |\r
| 主键ID           | \`id\`               | VARCHAR(64)   | PK              | 唯一标识                                                     |\r
| 映射规则ID       | \`mapping_id\`       | VARCHAR(64)   | NOT NULL, INDEX | 关联 \`qms_csr_process_mapping.id\`                             |\r
| 业务单据号       | \`business_bill_no\` | VARCHAR(50)   | NOT NULL        | 触发该动作的具体业务单据号（客诉单号、IQC单号等）            |\r
| 业务单据类型     | \`business_bill_type\`| VARCHAR(30)  | NOT NULL        | 单据类型枚举（与 business_node 对应）                        |\r
| 触发时间         | \`trigger_time\`     | DATETIME      | DEFAULT NOW()   | 引擎命中规则的时间                                           |\r
| 执行动作         | \`action_executed\`  | VARCHAR(30)   | NOT NULL        | 实际执行的动作类型                                           |\r
| 动作执行结果     | \`action_result\`    | VARCHAR(50)   | NOT NULL        | TRIGGERED_BLOCK=拦截生效, TIMER_STARTED=计时已启动, WARNING_SENT=警告已发出 |\r
| 最晚达成时间     | \`deadline_time\`    | DATETIME      |                 | 针对计时类控制：最晚要求完成时间                             |\r
| 实际完成时间     | \`close_time\`       | DATETIME      |                 | 实际任务闭环完成时间                                         |\r
| 是否违规         | \`is_violated\`      | TINYINT(1)    | DEFAULT 0       | 0=正常达成, 1=违规（超期或未通过），用于计算达成率           |\r
| 操作人           | \`operator\`         | VARCHAR(64)   |                 | 触发时的操作人                                               |\r
| 备注             | \`remark\`           | VARCHAR(500)  |                 | 处理说明或超期原因                                           |\r
\r
**索引设计**：\r
- \`idx_trigger_mapping\`: (\`mapping_id\`)\r
- \`idx_trigger_time\`: (\`trigger_time\`)\r
- \`idx_trigger_violated\`: (\`is_violated\`)\r
- \`idx_trigger_bill\`: (\`business_bill_no\`, \`business_bill_type\`)\r
\r
### 6.7 已有 CTQ 映射表改造（\`qms_ctq_mapping\` 增加字段）\r
\r
**说明**：在已有的 CTQ 特性标准映射表中，新增以下字段以建立与 CSR 条款的关联关系。\r
\r
| 新增字段名称       | 物理字段名          | 数据类型     | 约束   | 描述说明                                       |\r
| :----------------- | :------------------ | :----------- | :----- | :--------------------------------------------- |\r
| CSR条款ID          | \`csr_clause_id\`     | VARCHAR(64)  | INDEX  | 关联 \`qms_csr_clause.id\`（可为空=未关联CSR）   |\r
| CSR协议版本快照    | \`csr_version_snapshot\`| VARCHAR(20)|        | 关联当时的 CSR 协议版本号，用于版本比对提醒     |\r
\r
**版本联动逻辑**：\r
- 后端定时任务/协议版本变更事件触发后，查询所有 \`csr_clause_id\` 不为空的 CTQ 记录。\r
- 比对 \`csr_version_snapshot\` 与当前协议最新 \`version\`，若不一致则标记为"版本过时"。\r
- 前端在 CTQ 列表顶部展示黄色提醒横幅。\r
\r
## 7. 核心接口设计 (API)\r
\r
### 7.1 CSR 协议管理 API\r
| 方法   | 路径                                            | 描述               |\r
| :----- | :---------------------------------------------- | :----------------- |\r
| GET    | \`/api/v1/csr/protocols\`                         | 获取协议列表（分页）|\r
| POST   | \`/api/v1/csr/protocols\`                         | 创建协议           |\r
| PUT    | \`/api/v1/csr/protocols/{id}\`                    | 更新协议           |\r
| DELETE | \`/api/v1/csr/protocols/{id}\`                    | 删除协议（逻辑删除）|\r
| POST   | \`/api/v1/csr/protocols/{id}/attachments\`        | 上传附件           |\r
\r
### 7.2 CSR 条款管理 API\r
| 方法   | 路径                                            | 描述                 |\r
| :----- | :---------------------------------------------- | :------------------- |\r
| GET    | \`/api/v1/csr/protocols/{protocolId}/clauses\`    | 获取协议下所有条款   |\r
| POST   | \`/api/v1/csr/clauses\`                           | 创建条款             |\r
| PUT    | \`/api/v1/csr/clauses/{id}\`                      | 更新条款             |\r
| DELETE | \`/api/v1/csr/clauses/{id}\`                      | 删除条款             |\r
\r
### 7.3 业务流程映射 API\r
| 方法   | 路径                                            | 描述                   |\r
| :----- | :---------------------------------------------- | :--------------------- |\r
| GET    | \`/api/v1/csr/process-mappings\`                  | 获取映射矩阵列表       |\r
| POST   | \`/api/v1/csr/process-mappings\`                  | 创建映射规则           |\r
| PUT    | \`/api/v1/csr/process-mappings/{id}\`             | 更新映射规则           |\r
| PATCH  | \`/api/v1/csr/process-mappings/{id}/toggle\`      | 启用 / 停用映射规则     |\r
\r
### 7.4 合规性看板 API\r
| 方法   | 路径                                            | 描述                             |\r
| :----- | :---------------------------------------------- | :------------------------------- |\r
| GET    | \`/api/v1/csr/dashboard/stats\`                   | 获取统计卡片数据                 |\r
| GET    | \`/api/v1/csr/dashboard/trend\`                   | 获取达成率趋势图数据（按月）     |\r
| GET    | \`/api/v1/csr/dashboard/distribution\`            | 获取条款类型分布数据             |\r
| GET    | \`/api/v1/csr/dashboard/alerts\`                  | 获取当前风险告警列表             |\r
\r
### 7.5 引擎执行 API（内部调用）\r
| 方法   | 路径                                            | 描述                                       |\r
| :----- | :---------------------------------------------- | :----------------------------------------- |\r
| POST   | \`/api/v1/csr/engine/evaluate\`                   | 业务流程入口拦截判定（内部RPC）             |\r
| GET    | \`/api/v1/csr/trigger-logs\`                      | 获取触发记录（带分页和过滤）               |\r
\r
### 7.6 CTQ-CSR 联动 API（扩展已有接口）\r
| 方法   | 路径                                            | 描述                                       |\r
| :----- | :---------------------------------------------- | :----------------------------------------- |\r
| GET    | \`/api/v1/ctq-mappings/csr-version-alerts\`       | 获取 CSR 版本变更提醒列表                   |\r
| PUT    | \`/api/v1/ctq-mappings/{id}/csr-link\`            | 更新 CTQ 的 CSR 来源关联                    |\r
\r
## 8. 引擎执行方案\r
\r
### 8.1 统一拦截接口\r
后端所有关键业务方法（提交报工、提交出货审核、提交客诉回复等）引入 \`CsrActionEngine.evaluate(context)\` 拦截点。\r
\r
### 8.2 上下文组装\r
\`\`\`java\r
CsrEvaluationContext context = CsrEvaluationContext.builder()\r
    .customerId("C001")\r
    .materialId("M001")\r
    .factoryId("F001")\r
    .businessNode(BusinessNode.OQC_INSPECTION)\r
    .businessBillNo("OQC-20260226-001")\r
    .additionalParams(Map.of("quantity", 500))\r
    .build();\r
\`\`\`\r
\r
### 8.3 引擎处理链路\r
1. **规则过滤**：查询 \`qms_csr_process_mapping\` 中符合工厂、客户、物料且 \`is_active=1\` 的规则集合。\r
2. **条件求值**：解析 \`trigger_condition\` 表达式，结合上下文参数判定是否命中。\r
3. **动作分发**：\r
   - \`BLOCK\` + \`CRITICAL\`：抛出强控异常，前端阻断提交，写入 trigger_log。\r
   - \`SWITCH_TEMPLATE\`：返回需挂载的模板 ID 给前端动态渲染。\r
   - \`START_TIMER\`：投递延时消息进消息队列，写入 trigger_log 的 \`deadline_time\`。\r
\r
### 8.4 初版策略模板（简化实现）\r
初版引擎采用硬编码的策略模板降低复杂度：\r
\r
| 策略模板             | 触发条件参数         | 动作参数                |\r
| :------------------- | :------------------- | :---------------------- |\r
| 时间限制类           | SLA时长（小时）      | 超期后升级邮件/红灯     |\r
| 频次触发类           | 累积数量阈值         | 拦截出货/触发全检       |\r
| 文件模板类           | 无（节点触发即生效） | 目标模板 ID             |\r
\r
后期再扩展更自由的规则引擎（如支持 SpEL 表达式）。\r
\r
## 9. 权限与安全说明\r
\r
1. **功能权限**：\r
   - CSR 条款增、删、改需具有"基础数据:CSR管理:编辑"角色权限。\r
   - 映射规则启用/停用需具有"基础数据:CSR管理:配置"角色权限。\r
   - 合规看板为只读视图，仅需"基础数据:CSR管理:查看"权限。\r
2. **数据权限**：\r
   - 使用 \`tenant_id\` 进行 SaaS 多租户数据隔离。\r
   - 工厂维度配置的映射规则，仅对该工厂组织下的用户可见。\r
3. **安全规范**：\r
   - 附件上传需校验文件类型白名单（PDF、DOCX、XLSX），限制单文件最大 20MB。\r
   - \`trigger_condition\` 表达式执行需在沙箱环境中解析，防止注入风险。\r
\r
## 10. 前端目录结构\r
\r
\`\`\`\r
src/views/basic-data/csr-management/\r
├── index.vue                              # 主入口：Tabs 容器\r
└── components/\r
    ├── RequirementRepository.vue           # Tab1: CSR 条款维护空间\r
    ├── ProcessMappingMatrix.vue            # Tab2: 业务流程映射矩阵\r
    └── ComplianceDashboard.vue             # Tab3: 合规性监控看板\r
\r
src/views/basic-data/CustomerSupplierMapping.vue\r
└── Tab2: CTQ标准协同 (已内嵌 CSR 来源关联 + 版本联动提醒)\r
\`\`\`\r
\r
## 11. 路由与菜单配置\r
\r
| 路由路径                         | 组件                                   | 菜单位置           |\r
| :------------------------------- | :------------------------------------- | :----------------- |\r
| \`/basic-data/csr-management\`     | \`csr-management/index.vue\`             | 基础数据 → 顾客特殊要求(CSR) |\r
| \`/basic-data/customer-supplier-mapping\` | \`CustomerSupplierMapping.vue\`    | 基础数据 → 客供关系映射 (已有) |\r
`,ue="# 工艺路线管理 (Process Route) - 详细设计文档\r\n\r\n## 1. 模块概述\r\n**模块名称**：工艺路线与工序检验挂载管理\r\n**所属子系统**：基础数据 / IPQC模块 (过程检验)\r\n**目标**：统筹定义某一款产品对应的完整生产流转工艺过程。它是车间 IPQC (过程检验)、首检、末检的锚点基座。通过该模型可以在特定的工序卡点强行织入检验逻辑。\r\n\r\n## 2. 界面布局与交互设计\r\n### 2.1 主子表联动网格 (Master-Detail Grid)\r\n- **主表视图**：提供工艺路线的基础清单（包括编码、路线名称、挂接物料编号及目前管控状态）。\r\n- **嵌套行展开视图 (`expandedRowRender`)**：利用 Vue 的 Table Slot 机制，实现点击主表某路线的”+”展开后，无需跳转即可全景预览属于该关联项的所有**工序明细表 (Steps)**。\r\n\r\n### 2.2 复杂页签式表单 (Tabbed Modal Forms)\r\n新增与编辑器抛弃了堆叠平铺，改用 `a-tabs` 结构：\r\n- **Tab 1: 基本信息**：填写路线的纲领信息与多版本（`Version`）号控制字段。同时可在这里挂接需要此条工艺的对应物料产品。\r\n- **Tab 2: 工序明细**：\r\n  - 属于动态行联动的内嵌编辑表格。\r\n  - 支持随时通过 `handleAddStep` 插入新工序。\r\n  - 内嵌输入框管理其：序号 (opSeq)、工序工步名称 (opName) 及对应的 工作段 (workCenter)。\r\n\r\n### 2.3 高阶路由重定向编辑\r\n- 除了 Modal 快捷编辑，还设计了跨路由挂载项（在操作列加入了专用的编辑、查看超链接，触发 `vue-router` 跳转到高等级的全屏级详情页面`/basic-data/process-route/edit/:id` 进行重量级排布修改）。\r\n\r\n## 3. 核心功能设计\r\n### 3.1 工序的检验组装插拔 (Inspection Configuration)\r\n在 Tab 2 工序明细维护中，核心杀手锏功能：\r\n- 单层工序列具有“检验配置”能力。\r\n- 前端显性放置 `FirstInsp` (首件校验)、`PatrolInsp` (巡检校验)、`FinalInsp` (末件校验) 的彩色能力标识微标签 (Tags)。\r\n- 提供【配置】按钮，它触发引荐组件 `<OperationInspConfigModal>`，实现在特定的一条工艺序位内注入不同维度的抽样或必检计划模板联动。\r\n\r\n### 3.2 灵活的路线与物料结合\r\n- **下拉模糊过滤物料**：`a-select` 中启用 `show-search` 并且实现了自定义了 `filter-option` 回调逻辑，支撑跨数层级的下拉联想补全。\r\n- 一条工艺路线可以服务于某些特性类同的多个SKU或独立使用。支持强大的版本管控（如新路线验证期设为 Draft 草稿，确认量产设为 Active 生效）。\r\n\r\n## 4. 数据模型 (Data Model)\r\n核心属于典型的【主从表设计】(1对多)：\r\n\r\n**主实体 `Route Master`**:\r\n- `id`: 表记录主键\r\n- `code`: 工艺唯一编码\r\n- `name`: 工艺名称\r\n- `materialId`: 默认适配挂载的产品外键\r\n- `version`: 生效版本号控制 (如 V1.0、V2.0)\r\n- `description`: 技术备忘信息\r\n- `status`: 生命周期（`Draft` / `Active` / `Obsolete`）\r\n\r\n**子实体 `Route Steps` (工序)**:\r\n- `id`: 工步内码\r\n- `opSeq`: 技术加工执行流水序号 (10, 20, 30 ...用以留空插位)\r\n- `opName`: 工艺名 (如：压铸、熔炼、组装)\r\n- `workCenter`: 要求生产落地的实际车间/机器设备组识别号\r\n- `hasFirstInsp` / `hasPatrolInsp` / `hasFinalInsp`: 是否挂载三检配置规则的布尔标记位 (Boolean)\r\n\r\n## 5. 约束与规则\r\n- **序列排序约束**：进入的生产操作时序(`opSeq`)应该符合自增要求（非必须连续，但业务上需要）。\r\n- **生效态数据拦截**：如果一条路线的 `status` 为已生效运行 (`Active`) ，修改其底下的抽检首检校验计划必须伴有高等级放行或直接拦截提示建议升级 `version` 版本以作变动追溯。\r\n",de=`# 物料/产品档案 (Material & Product Archive) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：物料产品档案管理\r
**所属子系统**：基础数据管理模块 / 质量主数据（融合）\r
**目标**：统管工厂中各种流转实体（含原物料、半成品、产成品）的基本属性；它是整个质量管理系统(QMS)的最高频被引用对象；支持关联各类质量特有标准设定。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 高级版块布局（左树右表联动）\r
引入了复杂的组合视图：\r
- **左侧分类导航树**：完全复用来自《物料分类管理》的分类拓扑树（即：原材料、半成品、成品分支）。\r
- **点击穿透**：当用户在左侧选中了某分类分支（如“成品”），右侧的表格内容区将**立刻只过滤并呈现**归属于该分类标识（包括其子类）的所有具体物料 SKU 条目。\r
- **树搜索**：左侧树自带过滤搜索，避免由于分类层级过多导致的浏览困难。\r
\r
### 2.2 右侧核心管理面板\r
包含标准的快速信息检索区和工具栏：\r
- **组合搜索**：支持“所属组织”组织层级、“物料编码”、“物料名称”字段检索。\r
- **数据导入导出**：通过工具栏按钮直接响应大批量的料号 Excel 上传解析以及输出台账诉求。\r
- **表格核心列**：物料编码、规格型号、单位、来源模式（自制/外购），以及最为特殊的统计列：**工艺路线数**。\r
\r
## 3. 核心功能与集成设计\r
### 3.1 跨模块的质量设置融合\r
本模块在基础属性CRUD外，通过弹窗/抽屉（Drawer）的方式承载并外接了多个高阶的质量主数据：\r
- **检验规格 (Spec Drawer)**：从列表的“更多/动作”或详细页可以针对某项物料开启配置其专有检测属性定义。\r
- **工艺路线 (Route Drawer)**：物料具体的生产流转经由工序设定，表格中以显性的蓝色超链接直观显现该物料拥有几条流线。\r
- **检验方案 (Plan Drawer)**：快捷地挂载此物料在各类特定事件（入库、过程、成品环节）触发时应响应的质检执行计划配置方案。\r
\r
### 3.2 多组织维度的管控\r
- 数据表含有 \`orgId\` 业务标识字段。\r
- 支持同一套物理编码的物料在不同工厂间不同的属性隔离描述呈现。由于涉及到各组织，所以在数据入库及查询环节均强制通过组织维度的校验。\r
\r
## 4. 数据模型 (Data Model)\r
基础物料实体 \`Material\` 属性定义：\r
- \`id\`: 唯一识别号\r
- \`orgId\`: 所属组织控制标识\r
- \`code\`: 物料/产品编码 (SKU)\r
- \`name\`: 物料/产品名称\r
- \`spec\`: 规格参数信息\r
- \`category\`: 归属分类引用标识\r
- \`unit\`: 计量单位 (pcs, kg, set等)\r
- \`source\`: 获取来源类别 (Buy:外购 / Make:自制)\r
- \`remark\`: 其他描述提示情况\r
\r
## 5. 约束与规则\r
- **多业务交错控制**：被生产单据或入库流水等已经占用的实体物料通常从业务上被判定为不可直接清除。\r
- **分类依赖限制**：新增物料时只能选择末级最细的可用分类节点进行挂靠绑定。\r
`,me=`# 物料分类管理 (Material Category) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：物料分类管理\r
**所属子系统**：基础数据管理模块\r
**目标**：管理公司所有物料的分组架构及分类树节点，通过直观的层级结构组织物料主数据，以便规范和加速整个供应链数据链的搜索与统计属性归类。\r
\r
## 2. 界面布局与交互设计 (重构说明)\r
为了大幅提升层级数据的可视化与可操作性，对页面进行了深度的 **“左树右表”** (Split-Layout) 布局改造。\r
\r
### 2.1 左侧分类树 (Tree Panel)\r
- **展示**：使用树状结构全量或异步渲染物料的层级关系（如：原材料 -> 金属材料）。\r
- **搜索**：顶部提供针对树节点的实时文本搜索过滤能力，便于在庞大的分类目录中快速定位。\r
- **操作互动**：\r
  - 左键单击：高亮选中该节点，并**联动右侧表格**，使其仅展示所选分类及所有下挂子分类的数据。\r
  - 右键单击：弹出快捷环境菜单 (Context Menu)，支持直接针对于此级别进行：**新增子分类**、**编辑此分类**、**删除此分类** 等极速操作。\r
- **清除重置**：树顶部含有“清除筛选”按钮，恢复查看平铺的全部分类台账。\r
\r
### 2.2 右侧内容面板 (Content Panel)\r
- 同常规的管理视图一致，但在数据获取时会额外挂载来自左侧所选层级的依赖参数。\r
- 包含了常规工具栏操作、搜索面板、及带有分类完整层级信息的表格 (\`a-table\`)。\r
\r
## 3. 核心功能设计\r
### 3.1 树与表格的数据联动\r
- 左侧树与右侧表格使用一套基础的数据源加工而成。\r
- 左树发生 \`select\` 事件时，更新上下文 \`selectedTreeKeys\`。\r
- 表格的 \`DataSource\` 设定为基于该 Key 向下递归查找所有子节点 ID 并执行集合内 \`.filter()\` 保留满足条件的条目。\r
\r
### 3.2 级联删除机制\r
- 树形结构数据中极易遇到存在关联子层级的情况。\r
- 在用户尝试触发删除操作时，系统会自动评估 (基于 \`getDescendantIds\` 获取数量)。\r
- 若其存在子类别，将明确在对话框气泡中提示：“分类X下有 N 个子分类，删除后子分类也将被删除”，确认后执行**深度遍历级联删除**以保证数据的干净与一致性。\r
\r
## 4. 数据模型 (Data Model)\r
核心实体 \`Category\` 属性定义：\r
- \`id\`: 分类主键\r
- \`categoryName\`: 分类名称\r
- \`categoryCode\`: 规范化分类编码 (大写字符 + 下划线构型)\r
- \`parentId\`: 上级分类ID（指向自身实体的外键指针，为空表示根节点）\r
- \`sortOrder\`: 同级内的显示排序权重\r
- \`description\`: 说明备注\r
- \`status\`: 控制节点是否可以在后续物料档案创建时被正常引用\r
\r
## 5. 约束与规则\r
- **编码规范**：分类编码被严格校验，只允许大写英文字母和下划线组成。\r
- **循环依赖防范**：在设置上级分类时，不能选择其自身或其子分类作为父级以致死循环（本期简化处理，但在后端需严格防范）。\r
`,ge=`# 生产班组档案 (Production Team) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：生产班组管理\r
**所属子系统**：基础数据管理模块 / 人事辅助核算\r
**目标**：统管车间内的人员组织构架最小单元——“班组”。记录其归属部门、排班体系以及人员规模，为后续质量巡检打卡归属以及生产绩效统计提供维度分析依据。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 查询与检索\r
系统提供了轻量级的查询卡片：\r
- **班组编码 / 班组名称**：用于精确或模糊锁定特定班组。\r
- **所属部门**：下拉列表筛选（例如拉取生产一部、二部、质量部数据）。\r
- **状态**：启用/禁用。\r
\r
### 2.2 表格与色彩展示\r
- 对 **工作班次 (Work Shift)** 进行了色彩和文字的自定义渲染，利用不同颜色区分 “白班 (day)”、“夜班 (night)”、“混合班 (mixed)” 等高频变动排班体系。\r
\r
## 3. 核心功能设计\r
### 3.1 跨模块联动设计\r
- 在新增/编辑界面的中不仅定义基础文字，还深度嵌入了企业组织构架。\r
- **挂靠部门 (\`departmentId\`)**：强制所选班组归属于具体的粗粒度车间或生产部门。\r
- **挂靠主管 (\`leaderId\`)**：指定班组长的人员ID（依赖从人员主数据里抓取的数据）。\r
\r
### 3.2 规模及排班扩展控制\r
- 引入了 \`workShift\` 字段以支持灵活的排班约束录入（白班/夜班/早班等）。\r
- 通过 \`memberCount\` (固定或预估考勤基数) 定量此班组的大致规模。\r
- 支持填报详细的班组工作职责（\`responsibilities\`）和具体工作地点区域。\r
\r
### 3.3 查看及展示组件\r
- 配置了高颜值的 \`a-descriptions\` 组件支持在不进入可编辑表单的模式下，以三列宽度的平铺弹窗模式呈现班组全貌档案概览。\r
\r
## 4. 数据模型 (Data Model)\r
核心实体 \`ProductionTeam\` 属性定义：\r
- \`id\`: 唯一识别号\r
- \`teamCode\`: 班组编码（如：TEAM001）\r
- \`teamName\`: 班组命名\r
- \`departmentId\`: 直属部门的外键引用\r
- \`leaderId\`: 当前生效班长/负责人的外键引用\r
- \`workShift\`: 轮班班次制度约束\r
- \`memberCount\`: 满编或现有人数配置\r
- \`phone\`: 内部通联方式\r
- \`workLocation\`: 工作物理地点\r
- \`responsibilities\`: 团队主责定位\r
- \`remark\`: 补充备注说明\r
- \`status\`: 数据启用标识 (1/0)\r
\r
## 5. 约束与规则\r
- **关联数据清理控制**：已有排班或生产作业单挂靠的班组不能被彻底清除，只允许修改状态归档为禁用。\r
`,Te="# 计量单位管理 (Unit Management) - 详细设计文档\r\n\r\n## 1. 模块概述\r\n**模块名称**：计量单位管理\r\n**所属子系统**：基础数据管理模块\r\n**目标**：统一定义和管理系统中使用的所有商品、物料及包装的计量单位，支持国际标准的单位类型分类（重量、长度、体积、面积等），并支持设定基准单位及复杂的换算比率，为库存换算、BOM计算及采购入库提供底层支撑。\r\n\r\n## 2. 界面布局与交互设计\r\n### 2.1 整体布局\r\n页面采用了标准化的“表单查询 + 工具栏 + 数据表格”三段式卡片布局。\r\n\r\n### 2.2 搜索区设计\r\n- **单位编码**：文本检索。\r\n- **单位名称**：文本检索。\r\n- **单位类型**：下拉选择（重量、长度、体积、数量、面积、时间）。\r\n- **状态**：启用/禁用筛选。\r\n\r\n### 2.3 数据表格展示\r\n- 关键展示字段包括单位的编码、名称以及分类的单位类型。\r\n- **视觉优化**：利用 `a-tag` 将不同单位类型渲染为不同颜色（例如：重量显示为紫色，长度蓝色，数量绿色等）。\r\n- 增加了“换算基准单位”与“换算系数”两列，以及是否为“首选/基准单位”的标签。\r\n\r\n## 3. 核心功能设计\r\n### 3.1 换算基准体系\r\n- **是否基准单位 (`isBaseUnit`)**：表单中可单选，用于定义某一类量的绝对基准（如重量基准为“KG”）。\r\n- **换算基准单位 (`baseUnitId`)**：针对非基准单位，要求必须选择同类型的基准单位进行挂靠关联。\r\n- **换算系数 (`conversionFactor`)**：提供极高精度的数字输入组件，定义1个当前单位等于多少个基准单位（例如，“吨”挂靠“千克”，系数设为 1000）。\r\n\r\n### 3.2 CRUD 与批量操作\r\n- **新增/编辑**：由对话框 (Modal) 承接，支持基准单位联动的规则校验。\r\n- **状态管理**：支持单选或批量勾选执行“启用/禁用”操作。\r\n- **导出 (Export)**：工具栏内置导出 CSV 表格能力，方便主数据报表拉取。\r\n\r\n## 4. 数据模型 (Data Model)\r\n核心实体 `Unit` 属性定义：\r\n- `id`: 唯一标识符\r\n- `unitCode`: 单位编码（验证规则：大写字母加下划线，如 `KG`, `PCS`）\r\n- `unitName`: 描述名称（如：千克，个）\r\n- `unitType`: 单位类型 (`weight`, `length`, `volume`, `count`, `area`, `time`)\r\n- `baseUnitId`: 换算基准单位 ID（自身外键）\r\n- `conversionFactor`: 换算乘数系数（精确至6位小数）\r\n- `isBaseUnit`: 标识本单位是否作为类型的基准点 (1/0)\r\n- `sortOrder`: 下拉排列顺序\r\n- `description`: 描述说明\r\n- `status`: 生命周期状态\r\n\r\n## 5. 约束与规则\r\n- **防呆控制**：同一 `unitType` 分类下，原则上只能有一个启用的基准单位（逻辑实现落地后端时拦截）。\r\n- **递归防范**：在选择 `baseUnitId` 时，可选池需要过滤掉自身，且强制展示 `isBaseUnit=1` 的单位列表，防止出现循环换算定义。\r\n",Ae=`# 基础数据与质量主数据模块 - 需求说明书(PRD)\r
\r
## 1. 概述\r
本文档基于现已完成的“基础数据”与“质量主数据”系统代码与模块进行梳理生成，旨在固化已有研发成果。同时，结合《舜富QMS系统完整解决方案》的宏观设计，给出当前实现与理想方案之间的差距分析，为下一阶段迭代提供参考。\r
\r
---\r
\r
## 2. 差距分析 (Gap Analysis)\r
\r
对比《解决方案》中涉及主数据相关章节（如分册7、分册8），目前已实现的模块能够支撑核心的前期检验和基础生产管理需求，满足了最核心的质量标准配置，但在更深入的防错预防、智能化方面存在部分缺失需求：\r
\r
1. **抽样标准的动态检验规则缺失（涉及第17章）**\r
   - **已实现**：静态的抽样参数配置（支持正常/加严/放宽，支持AQL值及Ac/Re判断）。\r
   - **缺失点**：缺乏“放宽/加严/正常/免检”之间自动转换的**业务规则引擎与计数器配置**（如：连续10批合格转放宽、连续5批下2批不合格转加严等自动化转移逻辑配置）。\r
2. **MSA与SPC的深度主数据配置缺失（涉及第16章）**\r
   - **已实现**：计量器具台账列表（实现基础设备追踪）。\r
   - **缺失点**：缺乏量具“校准计划模板”与量具“Gage R&R研究”（重复性、再现性分析）的参数化模板配置；缺失SPC相关的控制图类型、控制界限(UCL/LCL)的定义与异常判定规则配置。\r
3. **QRQC、CAPA配套的基础知识与工作流主数据未完全建立（涉及第9、11、18章）**\r
   - **说明**：当前已完成基础的缺陷分类（现象与原因），但针对CAPA根因分析（如5Why模板、鱼骨图模板）和QRQC报警级别与多部门团队的基础架构等依赖数据未做体系化的配置页。\r
\r
3. **基础数据层面的多组织架构支撑缺失 (Multi-Organization)**\r
   - **已实现**：当前的客户、供应商、物料、工序等基础数据属于扁平化的全局数据，未区分组织维度。\r
   - **缺失点**：作为集团型制造业，基础数据（特别是物料、BOM、工序）通常存在“集团级主数据”与“工厂级/组织级业务数据”的区别。目前系统缺少了字段级的\`orgId\`归属隔离机制，以及“分配/下发”至特定厂区的业务逻辑。\r
4. **进阶业务功能与体验的缺失 (UI及易用性)**\r
   - **数据导入能力**：当前缺少Excel批量导入功能，导致基础数据初始化工作量大。\r
   - **分类层级展示**：目前物料分类、缺陷原因分类采用下拉或列表展示，当层级过深时，缺乏高级的“左树右表”布局结构支持。\r
   - **文件控制流**：客户档案材料（如营业执照）、供应商资质证明（SQE准入证明）目前缺少文件对象存储与附件管理机制集成。\r
\r
> **结论**：如上所述，在支持基本检验的“人、机、料、法”等静态基础数据上基本满足核心流转需求；但在高阶的动态规则、数据隔离（多组织）以及部分用户体验（如左树右表、附件管理、批量导入）上存在改进空间。\r
\r
---\r
\r
## 3. 已实现业务需求列表 (需求清单)\r
\r
### 3.1 基础数据模块 (Basic Data)\r
\r
基础数据主要用于规范系统运行所需的静态业务对象，确保后续检验、客诉、供应商分析的一致性。\r
\r
#### 3.1.1 客户与供应商管理\r
* **客户档案管理 (CustomerArchive)**：维护企业客户的基本信息和合作状态，支撑OQC阶段及客诉模块的关联。\r
* **供应商档案管理 (SupplierArchive)**：维护供应商的基本资质、联络人等信息，为IQC来料检验提供货源关联支持。\r
* **客供关系映射 (CustomerSupplier)**：针对包含特殊供应链关系的企业，维护两者联动的映射结构。\r
\r
#### 3.1.2 物料与工艺结构\r
* **物料分类管理 (MaterialCategory)**：支持对物料建立多层级的树状分类体系（如原材料、半成品、成品等）。\r
* **物料/产品主数据 (MaterialProduct)**：对具体的铝合金、锌合金、外协件及产成品进行编码和业务属性定义。\r
* **工艺路线管理 (ProcessRoute)**：建立标准工序的先后执行顺序，为IPQC（首件、巡检、末件）提供基于工序的质量控制节点。\r
\r
#### 3.1.3 生产辅助基础\r
* **生产班组信息 (ProductionTeam)**：维护各生产车间的班组构成，用于检验任务和生产任务的责任人定界。\r
* **库位划分 (StorageLocation)**：维护物料的存放区域与货位体系。\r
* **单位体系 (UnitManagement)**：定义系统的度量衡主数据（如PC、KG、M 等），确保库存、抽样与检验单位的统一。\r
\r
---\r
\r
### 3.2 质量主数据模块 (Quality Master Data)\r
\r
质量主数据聚焦于检验管控所必需的准则和特征，是驱动IQC~OQC四级检验运作的核心引擎。\r
\r
#### 3.2.1 缺陷定义及管理\r
* **缺陷现象库 (DefectPhenomenon)**：对可能发生的不良表现（如表面划伤、尺寸超差、压铸气孔等）进行标准化定义，支持多维度查询。\r
* **缺陷原因库 (DefectCause)**：对触发缺陷的结构性原因建立知识树，便于后续不合格品分析和CAPA追溯。\r
\r
#### 3.2.2 检验特征基础数据\r
* **检验项目管理 (InspectionItem)**：定义独立的检验要素（如：外径长度、硬度值、外观颜色），支持集团/多工厂级别的组织隔离。\r
* **检验方法管理 (InspectionMethod)**：定义对应的测试和测量手段（如三坐标测量、光谱分析、目视检验等）。\r
\r
#### 3.2.3 抽样体系及判定标准\r
* **抽样方案配置 (SamplingPlan)**：\r
  * 支持多维度的抽样模式：基于国标（GB/T 2828.1等）根据批量与AQL自动推导样本量和Ac/Re、固定数量抽样、百分比抽样、全检。\r
  * 根据检验水平（I、II、III、S1-S4等）和检验类型（正常、加严、放宽）进行全方位判定支持。\r
\r
#### 3.2.4 检验方案及模板引擎集\r
* **检验模板设计 (InspTemplate)**：抽象出一套通用的检验标准集合模板，可复用于具备相似特性的产品/物料。\r
* **检验方案设计 (InspScheme)**：定义了高度灵活的验证逻辑单元，将检验项目、检验方法、相关缺陷代码与抽样方案打包整合。\r
* **检验计划模型 (InspPlan)**：在检验方案之上绑定触发条件（如特定供应商、特定物料组、具体产线工序等），在执行层指导任务的自动生成逻辑。\r
\r
#### 3.2.5 器具及仪器设备\r
* **计量器具台账 (GaugeLedger)**：管理质量检测所涉及的各类量具的状态、检定周期、精度等级及保管员，为后续MSA铺平基础。\r
\r
---\r
\r
## 4. 后续演进计划 (Roadmap)\r
\r
根据GAP分析结果，针对基础数据与质量主数据的演进路线图建议如下：\r
\r
### 阶段一：动态规则完善 (近期)\r
* **动态抽样规则引擎**：增加检验批次计数器与转移规则配置模块（支持在正常、加严、放宽、免检间自动转换）。\r
* **自动化触发集成**：将检验计划与动态抽样规则引擎结合，在生成检验任务时自动推导当前的抽样严格度。\r
\r
### 阶段二：配置化MSA与SPC (中期)\r
* **测量系统分析中心**：在现有的计量器具台账基础上，增加Gage R&R研究配置模板与数据采集模型，形成MSA基础配置数据。\r
* **统计过程控制主数据**：建立SPC控制图类型、判定规则（判异规则）等基础配置，为未来的SPC过程监控做好支撑准备。\r
* **多组织与权限隔离改造**：在所有基础数据（物料、客户、供应商）中增加 \`org_id\` 租户级或工厂级隔离，支持按组织查看不同工厂下的物料。\r
\r
### 阶段三：CAPA及QRQC数据基础建设与UI重构 (远期)\r
* **高级UI重构与树状结构**：针对含有层级结构的基础数据（如物料分类、缺陷原因等），优化为“左树右表”的左右分栏交互。增加各基础数据的Excel模板下载与批量导入能力。\r
* **根因分析模型配置**：搭建5Why模板、鱼骨图分类等分析模型基础数据源。\r
* **高阶报警与工作流策略**：搭建QRQC缺陷分级策略配置，为后续触发不同部门快速响应的报警级别及升级规则打通数据关联。\r
* **资质附件管理体系**：打通文件服务系统，在供应商、客户档案中集成资质证书附件的上传与有效期预警。\r
`,Ce=`# 不良现象与字典库 (Defect Phenomenon / Cause) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：质量缺陷与失效原因特征库\r
**所属子系统**：质量主数据模块 (Quality Master Data)\r
**目标**：为产品检测中所有不符合项 (NC) 提供标准化的话术代码库和严重程度标识，避免车间工人与质检人员手写随意字句所造成的不利分析汇总局面；以及管理常见的根因分析 (RCA) 中的故障特征。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 不良现象库 (Defect Phenomenon List)\r
采用多维检索栏与表格方式：\r
- 提供严重等级 (\`severity\`) 以及 缺陷/失效分类（\`processType\` 例如外观不良、尺寸不良等）的过滤支持。\r
- 通过 Tag 给不同的质量严重程度赋予显性颜色控制（如：**CR (致命色:红)**、**MA (主要:橘色)**、**MI (次要:蓝)**）。\r
\r
### 2.2 编辑与管理关联项模块\r
- 不仅仅是录入基本文字，也包括对不良现象在后续应用时的图片、缺陷指导手册的引用配置编辑组件。\r
\r
## 3. 核心功能设计\r
### 3.1 不良特征定义机制\r
为防止数据“泛滥”，建立了不良字典。在检验环节记录数据时：只有从这里定义了特征之后（或动态添加），该特征才能通过 “检验项目关联表”（参考检验项目关联项功能）自动拉到相应的品质表单中。\r
\r
### 3.2 不良原因分析源映射 (Defect Cause)\r
通过同步开发的分析页，将不良表象与其背后的产生机制（例如操作问题、材料问题、设计问题建立分类）。配合使用构成异常质量的 “现象→原因对策” 的闭环知识系统基础。\r
\r
## 4. 数据模型 (Data Model)\r
**不良现象实体 (\`DefectPhenomenon\`)**:\r
- \`code\`: 失效模型专有的代号\r
- \`name\`: 即现象呈现，例如：生锈、偏移、划痕\r
- \`severity\`: 失效严重等级 (\`CR\`: 严重缺陷, \`MA\`: 主要缺陷, \`MI\`: 次要缺陷)\r
- \`processType\`: 所属环节种类域\r
- \`description\`: 具体定义解释\r
\r
## 5. 约束与规则\r
- 严重度 \`severity\` 是作为核心流程驱动（触发评审）和系统汇总（拉出柏拉图及扣分权数）最关键的数据节点，不可进行粗糙变更。如果修改一个原本是次要的缺陷为致命，将会引流并放大历史表单问题的数据评估级别。\r
`,Re=`# 抽样方案管理 (Sampling Plan) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：AQL 抽样规则与方案 (Sampling Plan)\r
**所属子系统**：质量主数据模块 (Quality Master Data)\r
**目标**：定义复杂的批量到样本转换计算规则，支持国际通用标准(如 GB/T 2828.1) 和内控百分比或全检方式，决定各检测批次放行和拒收 (Ac/Re) 阀值的底层模型。\r
\r
## 2. 界面布局与交互设计 \r
### 2.1 深度的 “左菜单右详情” 经典布局\r
页面为了适应多规则子级的渲染，构建了类似 IDE 的导航框架配置模式：\r
- **左侧边栏 (Left Panel)**：主方案导航。\r
  - 列出包含 GB/T2828.1 或 百分比 等大类母方案。\r
  - 含有悬浮快捷键及过滤功能，点击卡片（支持选中底色高亮）可以异步加载对应大类的诸多规则。\r
- **右侧工作台 (Right Panel)**：规则矩阵与详细子表展示区。\r
  - 结合主大类显示 \`planCode\`，可以向该方案下派生增添 “规则 (Rules)”。\r
  - 以 \`Nested Table\` 嵌套表格形式渲染不同规则组合下的判定细则。\r
\r
## 3. 核心功能设计\r
### 3.1 丰富的抽样标准匹配策略\r
支持由业务枚举定义的抽样模型 (\`samplingMethod\`)：\r
- **STANDARD_BASED**: 国标/行业计算判定 (使用 AQL 查询矩阵)\r
- **FIXED_QUANTITY**: 强制固定抽样个数 (例如来多少固定抽 10 件)\r
- **PERCENTAGE**: 百分比折算量 (例如10%)\r
- **FULL_INSPECTION**: 全检 (100%覆盖)\r
\r
### 3.2 矩阵抽样明细规则网格\r
这是本页面的主要亮点组件，用于渲染 AQL 规则的核心精髓：\r
针对给定的 \`inspectionLevel\` (检验等级如：II、S1、S2) 和 \`inspectionType\` (类型如正常、加严、放宽)：\r
配置一个批量查询表格。例如：\r
- 当交收数量段在 \`[batchSizeMin, batchSizeMax]\` 间。\r
- 采用某字码 (\`sampleSizeCode\`)，确定应取样总数。\r
- 然后配置 \`Ac（接收阀值数量）\` 和 \`Re（拒收阈值）\`。系统将以此矩阵精确执行批次判断逻辑。\r
\r
## 4. 数据模型 (Data Model)\r
数据结构上为 方案主干 -> 子规则设定 -> 阈值明细段 的三级树状体系：\r
\r
**Plan 层 (\`SamplingPlan\`)**:\r
- \`id\`, \`orgId\`\r
- \`planCode\`, \`planName\`\r
- \`samplingMethod\`: （国标、固定数、百分比等算法）\r
- \`description\`\r
\r
**Rule 层 (与Plan为 1:N)**:\r
- \`ruleCode\`, \`ruleName\`\r
- \`inspectionLevel\`: (I, II, III级等)\r
- \`inspectionType\`: (正常/加严/放宽)\r
- \`aqlValue\`: (0.65, 1.0, 1.5, 等)\r
\r
**Detail 层 (批量到样本矩阵段，与Rule为 1:N)**:\r
- \`batchSizeMin\`, \`batchSizeMax\`\r
- \`sampleSizeCode\`: 样本容量指示符字母\r
- \`acceptanceNumber\` (Ac)\r
- \`rejectionNumber\` (Re)\r
\r
## 5. 约束与规则\r
- **规则交叉检查**：对于同一个检验级别、检验类型和 AQL 下的 \`[batchSizeMin, batchSizeMax]\` 交收批次范围，不应该有任何覆盖或断层死角的重叠空间。\r
- **关联锁定限制**：在部分业务场景下，如果一个 AQL 方案或其中的规则已经被业务检验任务直接或间接作为计算快照锁定使用，不能执行删去（Delete），仅能采取废弃挂起动作。\r
`,Se=`# 检验方法管理 (Inspection Method) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：检验方法与操作规范资源管理 (Inspection Method)\r
**所属子系统**：质量主数据模块 (Quality Master Data)\r
**目标**：统管质量系统内涵盖的一切测定动作及 SOP(标准操作程序)的索引数据，为主测数据（检验项目）提供作业指导文本或附件支持。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 查询与检索\r
系统采用了简单的卡片轻量检索：\r
- **方法名称 / 附件ID / 组织筛选**。\r
- 操作区支持典型的增、删、改、导出。\r
\r
### 2.2 表格与文字展示\r
- 默认在主表格将步骤核心文本以文本切省 \`ellipsis=true\` 方式进行渲染，便于直接快览部分核心步骤（例如需要特殊的蓝牙数显卡尺连接校准步骤提示）。\r
\r
## 3. 核心功能设计\r
### 3.1 集团/组织数据下放\r
同检验项目类似，方法库同样建立在集团下发与各工厂自建组合的体系中。\r
新增/编辑表单要求定义 \`orgId\` 域，方便集团推行大一统检验要求时能在不同工厂被共享。\r
\r
### 3.2 检验SOP的绑定机制\r
建立针对此方法的详尽多步流控制：\r
- 字段 \`operationText\` 提供大量人工指令（如 1.校准...2.放置...3.读取...）的支持。\r
- 字段 \`attachmentId\` 支持关联物理上的多媒体指导文档，使得在后续 IPQC（首检/巡检）触屏应用端能够快速调起说明书。\r
\r
## 4. 数据模型 (Data Model)\r
核心实体 \`InspectionMethod\` 属性定义：\r
- \`id\`: 实例主键\r
- \`orgId\`: 归属组织域 (null为集团总管)\r
- \`methodName\`: 工具操作方案命名 (如: 蓝牙卡尺检定法)\r
- \`attachmentId\`: 绑定对应服务端的文件管理服务器凭证ID（关联SOP）\r
- \`operationText\`: 特定的手写检测作业书说明详情。\r
\r
## 5. 约束与规则\r
- **重名排他验证**：为防范工厂下建操作标准引起混乱，新增和修改方法提交前引入异步唯一性鉴别。判断方式为：同 \`orgId\` 作用域下，\`methodName\` 不可发生完全一致冲突重复。\r
`,ye="# 检验模板管理 (Inspection Template) - 详细设计文档\r\n\r\n## 1. 模块概述\r\n**模块名称**：质量检验模板管理 (Inspection Template)\r\n**所属子系统**：质量主数据模块 (Quality Master Data)\r\n**目标**：统一定义各工序、各类型检验（IQC/IPQC/FQC/OQC）在执行检验动作时的具体“表单外观”及验证特征清单。它是连接底层的“检验项目(Inspection Item)”和高层的“检验方案(Inspection Plan)”的中间载体，决定了一线质检员会看到怎样的检测记录页面结构。\r\n\r\n## 2. 界面布局与交互设计\r\n### 2.1 高级查询面板\r\n页面顶部区域内置了多维检索栏目，满足快速筛查的需求：\r\n- **组织过滤**：可按照归属地（例如：集团、芜湖工厂、合肥工厂）筛选。\r\n- **阶段过滤**：按照特定的检验阶段 (`IQC来料`, `IPQC过程`, `FQC成品`, `OQC出货`) 进行目标靶向过滤查询。\r\n- **基础状态查询**：内置了类似于生命周期的状态（草稿、审批中、已批准、已作废）筛选器。\r\n \r\n### 2.2 表格与操作设计\r\n- **丰富的数据列表**：一目了然地展示模板的编码、名称、版本、关联细项数量(`detailCount`)及最新同步状态。\r\n- **受控的操作机制**：操作列遵循了严格的文件受控策略，使用了下拉菜单 (`更多`) 来折叠低频的审批和流转动作操作（“提交审批”、“审批通过”、“历史版本管理”等）。\r\n\r\n## 3. 核心功能设计\r\n### 3.1 严格的版本历程追溯台账 (History Version Tracking)\r\n此功能是本页面最大的亮点，引入了深度贴合军工及汽车制造行业要求的 **版本追踪树** 弹窗：\r\n- 用户点击 “查看历史版本”，将弹出带左侧对齐锚点的 `a-timeline` 时间轴。\r\n- 直观渲染该模板的升版历程。包括某版本于何时被谁（Updater）以何种摘要（changeSummary，如：“调整了某项外观不良校验逻辑”）生成。\r\n- **版本快速回滚**：针对作废的历史快照（`OBSOLETE`），提供【恢复此版本】这一快捷路径按钮。此操作并不会去篡改现有生效版本，而是将其底层数据镜像一份，克隆生成最新编号的新一轮 `DRAFT` (草稿)版本，极大地减少了工程师重建模板工作量。\r\n\r\n### 3.2 组织下沉体系\r\n- 检验模板同样融入了集团 (`Group`，数据结构里一般表现为 `orgId: 'ORG001'`等类似顶层标识）和工厂 (`Factory`) 两套体系。下级工厂通常不允许直接篡改乃至删除带有上级标识的标准模板定义，仅能将其**复制 (Copy)** 下来做自我工厂级属性扩展。\r\n\r\n## 4. 数据模型 (Data Model)\r\n核心实体 `InspectionTemplate` 定义：\r\n- `id`: 表主记录标识\r\n- `orgId`: 指向数据所有的权限组或厂区域内码。\r\n- `code`: 系统内校验或导入时认定的逻辑编码\r\n- `name`: 模板可视化命名（如：IQC电子元器件检验单模板）\r\n- `inspType`: 检验大类域字典标识（`IQC`, `IPQC`, `FQC`, `OQC`）\r\n- `status`: 生命周期（`DRAFT`, `IN_APPROVAL`, `APPROVED`, `OBSOLETE`）\r\n- `version`: 当前生效管控的字面字符串（如：`V1.0`, `V2.1`）\r\n- `detailCount`: 下级装配检测项的数据规模反馈量。\r\n\r\n**历史节点模型 (History Node)**:\r\n- `version`: 关联子版本\r\n- `updateTime`, `updater`: 操作归属人日志\r\n- `changeSummary`: 用于技术变更(ECO)关联说明的简讯。\r\n\r\n## 5. 约束与规则\r\n- **生命周期锁定 (Status Guard)**：数据在 `DRAFT` (草稿阶段) 才可以做核心编辑 (`handleEdit`) 和清理废除 (`handleDelete`) 的动作。一旦状态机跃迁到其它任何形态，界面即进入强制只读与拦截态。\r\n- **关联锁定限制**：任何处在 `APPROVED` 已发布状态被 `InspPlan` (方案主数据表) 关联依赖的特征模板，必须通过版本升级 (New Version) 的方式处理维护。不允许直接撤下或破坏其内部已装嵌的校验项目，保证历史质检订单打开时的追溯呈现完备性。\r\n",Ie=`# 检验计划模型 详细设计文档\r
\r
## 1. 模块概述\r
\r
**检验计划模型（Inspection Plan Model）**是 QMS 系统中连接"业务/生产执行"与"质量检验标准"的核心调度神经枢纽。\r
向上，它承接来自 ERP/MES 等系统的各类单据动作（如采购收货、工单开工）及时间调度任务；向下，它将具体的《检验方案》（包含项目明细、抽样规则等）分发为可执行的《检验任务记录》。\r
\r
### 1.1 核心目标\r
- **业务解耦：** 将检验标准与业务单据触发逻辑剥离，提升质量标准的复用性。\r
- **动态调度：** 支持事件驱动、时间周期驱动、数量批次驱动等多维度的触发机制。\r
- **柔性适配：** 提供"参数覆盖（Parameter Overrides）"功能，允许在计划层面对同一标准方案的不同应用场景（如A客户与B客户对同一工序的公差要求不同）进行微调。\r
- **全生命周期管控：** 实现计划的版本管理（草稿->生效->作废）与多组织（集团到工厂）的继承下发机制。\r
\r
---\r
\r
## 2. 核心架构与业务流程\r
\r
### 2.1 业务触发流程架构\r
\r
\`\`\`mermaid\r
graph TD\r
    A[业务动作/调度] -->|触发器引擎| B(检验计划匹配)\r
    B --> C{是否匹配到生效的计划?}\r
    C -- 是 --> D[加载具体检验方案详情]\r
    D --> E[应用计划层的 Parameter Overrides 参数覆盖]\r
    E --> F[生成最终的 检验任务记录/派工单]\r
    F --> G[附加 Quick Response 快速响应监控]\r
\`\`\`\r
\r
### 2.2 多组织业务支持模型\r
- **集团级：** 制订基础检验方案（Scheme）与标准检验计划模板（Org为空）。\r
- **工厂级：** 复制集团模板生成本地计划（Org对应具体工厂ID），可重新分配执行人、覆盖部分公差、调整触发频次等，形成独立版本的本地计划记录。\r
\r
---\r
\r
## 3. 数据模型设计 (数据库表结构)\r
\r
模型采用主从表结构设计，以支撑高复杂度的层级定义。\r
\r
### 3.1 主表：\`qms_insp_plan\` (检验计划主表)\r
\r
| 字段名 (Field) | 类型 (Type) | 必填 | 默认值 | 描述 (Description) |\r
| --- | --- | :---: | --- | --- |\r
| \`id\` | VARCHAR(36) | Y | UUID | 主键 |\r
| \`org_id\` | VARCHAR(36) | N | NULL | 归属组织ID。NULL代表集团级，有值代表具体工厂 |\r
| \`scheme_id\` | VARCHAR(36) | Y | - | 关联的检验方案主键（FK） |\r
| \`plan_code\` | VARCHAR(50) | Y | - | 检验计划编码（如：PLN-HFC-001），唯一约束 |\r
| \`plan_name\` | VARCHAR(100)| Y | - | 检验计划名称 |\r
| \`version\` | VARCHAR(20) | Y | 'V1.0' | 版本号 |\r
| \`plan_status\` | VARCHAR(20) | Y | 'DRAFT' | 状态枚举：DRAFT(草稿), ACTIVE(生效), SUSPENDED(挂起), OBSOLETE(作废) |\r
| \`insp_type\` | VARCHAR(20) | Y | - | 检验类别：IQC, IPQC, FQC, OQC, PATROL |\r
| \`material_id\` | VARCHAR(36) | N | - | 关联的特定物料（仅在特定物料需设定专属计划时使用） |\r
| \`trigger_type\` | VARCHAR(20) | Y | - | 触发类型枚举：EVENT(事件), TIME(周期), QUANTITY(数量), MANUAL(手动) |\r
| \`executor_id\` | VARCHAR(36) | N | - | 默认执行人（检验员）ID |\r
| \`backup_executor_id\` | VARCHAR(36)| N | - | 备选执行人ID |\r
| \`reviewer_id\` | VARCHAR(36) | N | - | 审核人/主管ID |\r
| \`defect_disposition\`| VARCHAR(50)| N | - | 默认不良处理方式：SCRAP, REWORK, CONCESSION, RETURN_SUPPLIER |\r
| \`copy_from_id\`| VARCHAR(36) | N | - | 继承来源计划的ID（用于追溯工厂是复用了哪个集团模板） |\r
| \`is_latest_version\`| BOOLEAN | Y | true | 标识是否为最新版本，用于列表过滤 |\r
| \`create_time\` | DATETIME | Y | NOW() | 创建时间 |\r
| \`update_time\` | DATETIME | Y | NOW() | 更新时间 |\r
\r
### 3.2 触发器配置子表：\`qms_insp_plan_trigger\`\r
*为保证良好的拓展性，将三种触发模式相关的详情放在独立的子表中，或作为JSON列存储在主表，此处设计为物理子表。*\r
\r
| 字段名 (Field) | 类型 (Type) | 必填 | 描述 (Description) |\r
| --- | --- | :---: | --- |\r
| \`plan_id\` | VARCHAR(36) | Y | 关联 \`qms_insp_plan.id\` (PK, FK) |\r
| \`erp_doc_type\` | VARCHAR(50) | N | 【事件触发】ERP业务单据类型（如：PURCHASE_RECEIVE, PRODUCTION_ORDER）|\r
| \`erp_doc_status\` | VARCHAR(50) | N | 【事件触发】触发动作节点（如：SUBMITTED, IN_WAREHOUSE）|\r
| \`custom_event_name\` | VARCHAR(100)| N | 【事件触发】外部自定义事件名称标识符 |\r
| \`cron_expression\` | VARCHAR(50) | N | 【周期触发】Cron 表达式（如 \`0 0 8 * * ?\`）|\r
| \`frequency_type\` | VARCHAR(20) | N | 【周期触发】可视化频率分类（HOURLY, DAILY, WEEKLY, MONTHLY）|\r
| \`frequency_value\` | INT | N | 【周期触发】频率步长值 |\r
| \`quantity_threshold\`| INT | N | 【数量触发】触发阈值 |\r
| \`quantity_unit\` | VARCHAR(20) | N | 【数量触发】触发单位（PIECES件, MOLD模, BATCH批次） |\r
| \`match_description\` | VARCHAR(255)| N | 触发匹配逻辑描述/备注说明 |\r
\r
### 3.3 参数覆盖明细表：\`qms_insp_plan_override\`\r
*针对具体检验计划中，需要修改关联方案原定义的数据上限/下限/目标值而设立的映射表。*\r
\r
| 字段名 (Field) | 类型 (Type) | 必填 | 描述 (Description) |\r
| --- | --- | :---: | --- |\r
| \`id\` | VARCHAR(36) | Y | 主键 |\r
| \`plan_id\` | VARCHAR(36) | Y | 关联 \`qms_insp_plan.id\` |\r
| \`scheme_detail_id\` | VARCHAR(36) | Y | 关联方案中某项目的ID \`qms_insp_scheme_detail.id\` |\r
| \`insp_item_name\` | VARCHAR(100)| N | (冗余)检验项目名，方便显示检索 |\r
| \`target_value\` | DECIMAL(10,4)| N | 新的目标值 |\r
| \`upper_limit\` | DECIMAL(10,4)| N | 新的规格上限 |\r
| \`lower_limit\` | DECIMAL(10,4)| N | 新的规格下限 |\r
| \`gauge_type_id\` | VARCHAR(36) | N | 变更选用的量检具类型ID |\r
| \`override_reason\` | VARCHAR(255)| N | 调整参数的原因 |\r
\r
### 3.4 快速响应配置表：\`qms_insp_plan_qr\` (Quick Response)\r
*配置与此检验计划相关的高级警报通知体系。*\r
\r
| 字段名 (Field) | 类型 (Type) | 必填 | 描述 (Description) |\r
| --- | --- | :---: | --- |\r
| \`plan_id\` | VARCHAR(36) | Y | 关联主键 \`qms_insp_plan.id\` (PK) |\r
| \`enabled\` | BOOLEAN | Y | 是否开启快速响应监控 |\r
| \`response_level\` | VARCHAR(20) | N | 响应等级：NORMAL(普通), HIGH(高), CRITICAL(紧急) |\r
| \`email_alert\` | BOOLEAN | Y | 是否开启邮件通知 |\r
| \`email_recipients\` | VARCHAR(1000)| N | 邮件接收人清单（JSON Array结构存储或分号隔开） |\r
| \`dingtalk_alert\` | BOOLEAN | Y | 是否开启钉钉/企微通知 |\r
| \`dingtalk_recipients\`| VARCHAR(1000)| N | 钉钉Webhook或接收人群组清单（JSON） |\r
\r
### 3.5 快速响应锁定不良现象关联表：\`qms_insp_plan_qr_phenomenon\`\r
*触发极速响应的特定的严重不良现象。*\r
\r
| 字段名 (Field) | 类型 (Type) | 必填 | 描述 (Description) |\r
| --- | --- | :---: | --- |\r
| \`id\` | VARCHAR(36) | Y | 主键 |\r
| \`plan_id\` | VARCHAR(36) | Y | 关联 \`qms_insp_plan.id\` |\r
| \`phenomenon_id\` | VARCHAR(36) | Y | 关联不良现象基础库的现象ID |\r
\r
---\r
\r
## 4. 重点业务状态机 (State Machine)\r
计划存在生命周期内的状态变更限制：\r
\r
1. **DRAFT（草稿状态）**：新建或编辑时的默认状态，该状态下检验规则引擎不会匹配到本计划。\r
2. **ACTIVE（生效状态）**：已确认的计划，发布后供各个触发执行层引擎调度使用。\r
3. **SUSPENDED（挂起状态）**：临时暂停此计划引发的后续检验任务。可被恢复回 ACTIVE 操作。\r
4. **OBSOLETE（作废状态）**：标识此版本已经过时或永不使用。\r
* **发布新版本**：从生效或挂起状态直接创建一个 Version +1 的 DRAFT 数据行，并且可以选择同步将当前行变更为 OBSOLETE 状态。\r
\r
---\r
\r
## 5. UI交互及前端组件规划指引\r
在前端系统 \`InspPlanModelList.vue\` 和 \`InspPlanModelEdit.vue\` 中涉及的交互：\r
- **列表查询：** 支持 \`planStatus\`, \`triggerType\`, 组织树 的快捷查询拦截。\r
- **动态表单支持：** \`TriggerType\` 控制了事件、周期、数量驱动三个组件的表单项显示与隐藏切换。\r
- **行内编辑器：** 在"参数覆盖(Overrides)"选项卡，直接采用可横向滚动的轻量化表格对上限/下限进行局部修改。\r
- **复制多态性：** 当组织选择继承时，模态框可以选择"完全复制"或"仅继承部分基础架构"，前端在重新构造对象抛给后端保存时实施相应的节点切除操作。\r
\r
---\r
\r
## 6. 后端接口设计要求 (API 概览)\r
\r
- \`POST /api/v1/inspection-model/plans\`: 创建新版本的检验计划。接收复杂的嵌套JSON（含有触发器属性、覆盖集合、QR配置对象）。\r
- \`GET /api/v1/inspection-model/plans/{id}\`: 深层联合查询（Join查询），完整反显所有关联子表、覆盖配置对象。\r
- \`PUT /api/v1/inspection-model/plans/{id}\`: 更新特定的草稿。\r
- \`POST /api/v1/inspection-model/plans/{id}/status\`: 执行状态扭转（如 DRAFT->ACTIVE，或者发起作废行为）。\r
- \`POST /api/v1/inspection-model/plans/{id}/copy\`: 处理全量或部分配置的复制接口生成副本。\r
`,Ee="# 检验项目管理 (Inspection Item) - 详细设计文档\r\n\r\n## 1. 模块概述\r\n**模块名称**：检验项目管理 (Inspection Item)\r\n**所属子系统**：质量主数据模块 (Quality Master Data)\r\n**目标**：用于统一定义 QMS 系统中所有可能被用于测量的最小检测单元。支持不同数据类型（计量型/计数型）、不同的量测分类及严格的多工厂组织权限隔离机制。\r\n\r\n## 2. 界面布局与交互设计\r\n### 2.1 整体布局\r\n采用经典的上栏查询、中栏工具、下栏数据的管理界面。\r\n- **高级过滤扩展**：由于检验项目的属性特征复杂，查询区域支持基础检索并提供了“展开/收起”功能的辅助区，可按数据类型、所属组织域等多条件进一步复合过滤。\r\n\r\n### 2.2 表格与色彩展示\r\n- **所属组织过滤控制**：引入多选的组织选择器（合肥工厂、芜湖工厂等）。通过 `a-tag` 将跨越组织（如“集团”项目）和车间级别的项目以醒目色彩划分。\r\n- **参数标记机制**：利用小巧醒目的标签 (`flags`) 快速呈现该检验项目是否承接 SPC 或者实验测试业务的核心挂载点（`isSpcDefault` 和 `isLabTestDefault`）。\r\n- **数据约束识别**：为 `计量型（Quantitative）` 提供浅蓝色标识，对 `计数型（Qualitative）` 提供紫色标识处理，并依据类型强制关联是否有计量单位 (UOM)。\r\n\r\n## 3. 核心功能设计\r\n### 3.1 跨级权限的编辑拦截机制\r\n- 系统的组织采用集团化分布。用户 `orgId` 若无跨级编辑权限，当点击诸如“集团级”标准检验项目时，操作列的编辑和删除会被拦截（逻辑 `canEdit()` 控制），只能只读查看或应用该标准项，而不能直接修改母版数据。\r\n\r\n### 3.2 不良缺陷挂勾模型 (Defect Phenomenon Link)\r\n- 增加了“不良现象” (Defect Phenomenon) 关联页签维护功能。针对某个质检项目可能导致的所有失效现象（如测表面外观时导致“划伤”、“破损”现象），支持进行先验绑定，缩短后续开具不合格单 (NC) 的选取时间。\r\n\r\n## 4. 数据模型 (Data Model)\r\n核心实体 `InspectionItem` 属性定义：\r\n- `id`: 项目内部主键\r\n- `code`: 项目唯一编码\r\n- `name`: 检测特征名称\r\n- `orgId`: 归属组织 (集团则为 null)\r\n- `category`: 分类，含：尺寸(`dimension`)、外观(`appearance`)、理化(`physical_chemical`)、功能(`functional`)\r\n- `dataType`: 数据定性方式 (`quantitative` 或 `qualitative`)\r\n- `uom`: 单位（仅当 `dataType` 为计量型强绑定）\r\n- `defaultMethodId`: 缺省验证和操作指导参考的方法卡ID\r\n- `status`: 生命周期\r\n\r\n## 5. 约束与规则\r\n- **强类型录入检查**：若 `dataType` 选为 `qualitative` 此时 UOM 输入框为被完全禁用。\r\n- **跨模块限制**：一旦该检验项目在生效的抽样方案体系或检验模板内被调用，系统逻辑底座原则上不允许再做删除动作（只能转为 obsolete/disabled 归档）。\r\n",ve=`# 质量检验计划与方案方案 (Inspection Plan & Scheme) - 详细设计文档\r
\r
## 1. 模块概述\r
**模块名称**：质量检验计划管理 (Inspection Plan/Scheme)\r
**所属子系统**：质量主数据模块 (Quality Master Data)\r
**目标**：统筹 IQC、IPQC、FQC 与 OQC 等全工艺制程检验的纲领性顶层设计。它是最重要的高维聚合主数据。它将之前单独定义的【检验项目】、【检验方法】和【AQL 抽样规则】按照某种逻辑组合并打包为一个供一线使用的一体化检验套件。\r
\r
## 2. 界面布局与交互设计\r
### 2.1 高级查询与状态总览\r
使用了完整的查询面版：\r
- **方案状态过滤**：草稿(Draft), 审批中(In Approval), 已批准(Approved), 已作废(Obsolete)。\r
- **多组织归属过滤 (\`orgIds\`)**：支持使用 Multi-select 联合查询多个归属地（集团、合肥工厂等）下的质量预案。\r
\r
### 2.2 独创的副本复制向导 (Clone/Copy Modal)\r
由于检验预案往往极其繁复庞大（包含成百上千条特征规格校验），在 UI 交互中设计了专属的【复制方案】组件功能：\r
- 提供源名称提示。\r
- 提供输入新的 \`目标编码\` 和 \`目标名称\` 的表单卡，并**可以变更归属组织域**（即集团标准的方案允许被轻松复制为特定地方工厂的执行标准草稿）。\r
\r
## 3. 核心功能设计\r
### 3.1 工作流级生命周期管理\r
该页面抛弃了简单的“启用/禁用”，通过引入标准的文件受控审批概念：\r
1. **DRAFT (草稿)**：系统独家用此状态，保证只有该状态的计划方案可以被“编辑”。\r
2. **IN_APPROVAL (审批中)**：方案经编撰人员提交后的状态锁定。\r
3. **APPROVED (执行态/已批准)**：允许被应用到各类产线出货端。一旦进入此状态，本页面内的任何编辑动作都会被直接拉黑防呆，防止执行期篡改标准。\r
4. **OBSOLETE (作废)**。\r
\r
### 3.2 集团与工厂层级的重用继承保护（Group vs Factory）\r
- **隔离规则**：对属于集团级定义 (\`orgId === null\`) 的原版检验方案，所有厂级质量人员可以在列表中查看，但绝对**不允许直接编辑和删除**（即使用户尝试点击或破解触发编辑API，也会被代码 \`canEdit\` 或表单级的守卫给拦截）。\r
- **破局方式**：工厂用户可通过上文提到的**『一键复制』**将高级别通用标准拷贝，衍生出本厂特有的 DRAFT 版再进行改写与使用。\r
\r
### 3.3 检验明细的模板挂载与深度定制\r
- **模板引用与快速加载**：在新增或编辑检验方案时，支持在基础信息区域直接关联已配置好的【检验模板 (\`templateId\`)】。关联后，系统可将该检验模板下挂载的海量“标准检验项明细”一键快速加载、引入到当前检验方案中。\r
- **自定义后续编辑**：被加载进方案的检验明细，实质上脱离了原模板的强绑定束缚，变为了当前方案的实例级数据。质量主观或测试配置工程师随后可在**方案编辑详情**的“明细列表”页签下，针对这些衍生引入的项目，任意进行继续编辑调整（如设定是否强制实验室测试、单独剥离或增加部分特征），使得计划具备极其灵活的微调能力，兼顾了规范性和灵活性。\r
\r
## 4. 数据模型 (Data Model)\r
此页为高维路由枢纽，核心实体 \`InspectionPlan\` 表字段概念包括：\r
- \`id\`: 表主键\r
- \`orgId\`: 数据控制域隔离字段\r
- \`planCode\`: 检验大纲号\r
- \`planName\`: 方案中文全称\r
- \`version\`: 技术版本号(管控追溯)\r
- \`inspType\`: 检验过程类型（\`IQC/IPQC/FQC/OQC\`）\r
- \`templateName\`: 引用的底层检测表原始模板外键名称\r
- \`status\`: 生命周期。\r
\r
> **关联特性**：在这个抽象记录的下方（通过进入编辑/查看的方案详细页面），将挂接着多对多形态的 \`检验特征列表\`、对应的 \`AQL 放行细则\` 以及 \`特定料号库\` 匹配规则。\r
\r
## 5. 约束与规则\r
- **变更追溯**：正在使用的 \`APPROVED\` 状态绝不允许覆盖修改。任何技术调整必须通过修改原本生成 \`OBSOLETE\` 或重新生成递进高版本号的副本。\r
- **引用防呆**：如果某个物料主数据的免检配置或检验绑定已指配到了该方案，则此方案必须处于 \`APPROVED\` 安全状态。\r
`,De="# 量检具台账与类型管理 (Gauge Ledger) - 详细设计文档\r\n\r\n## 1. 模块概述\r\n**模块名称**：量检具管理台账与层级树\r\n**所属子系统**：质量主数据模块 (Quality Master Data) / 检验支持模块\r\n**目标**：构建全厂测量系统资产（卡尺、硬度仪、三坐标等设备）的全生命周期管理跟踪卡。支持设备的层级分类、高精度测量属性配置并核心支撑MSA（测量系统分析）的依赖前提和定期设备送校提醒。\r\n\r\n## 2. 界面布局与交互设计\r\n### 2.1 “左树右表” 复杂布局 (Split Layout)\r\n页面布局采用了高频的高级左树右表结构：\r\n- **左侧容器 (Left Panel - Tree)**：使用 `a-tree` 组建渲染量检具分类树。\r\n  - 支持节点过滤搜索（如输入“卡尺”过滤树状节点）。\r\n  - 在每个节点上支持悬浮动作组（新增子类、编辑本类、删除大类）。\r\n- **右侧工作台 (Right Panel - Ledger List)**：设备明细列表。\r\n  - 只有在选中左侧设备类目后，右侧才会呈现挂属于此品类或此族系下的设备实体。\r\n  - 带有醒目的表头展示目前选中的大类其精度或“是否需MSA”。\r\n\r\n### 2.2 视觉驱动的阈值警告\r\n在量检具中，“校准到期监控”是最为关键的质量管理动作。\r\n- 在表格和详情中渲染 `nextCalDate` 时加入强校验逻辑：\r\n  - 如果日期已逾期 ( `<0 days` )：使用红色警报 `red`\r\n  - 如果在即将逾期范围内 ( `<14 days` )：使用警戒色 `orange`\r\n  - 正常在案：绿色 `green`\r\n\r\n## 3. 核心功能设计\r\n### 3.1 量检具类型属性定义 (Gauge Type Tree)\r\n类型不仅仅是个文本标签，他附带两大质量属性：\r\n- `precision` (分辨率/精度)：如0.01mm，这个精度将直接预设到新建的具体卡尺上。\r\n- `isMsaRequired` (是否需要MSA校验)：布尔值控制，如果是，未来在进行 GR&R 试验分析时，该类的设备才会被强制要求挑选出做验证。\r\n\r\n### 3.2 周期性校验 (Calibration Cycle)\r\n这部分由核心的生命周期字段控制：\r\n- `status`: 在用、校准中、封存、报废。\r\n- 如果设备状态被标记为`CALIBRATING`(校准中)或`SCRAPPED`(报废)，在检验员准备做 IPQC/OQC 选择所用设备输入时，下拉框会对其进行自动防呆拦截，不可选用。\r\n\r\n## 4. 数据模型 (Data Model)\r\n**类型节点实体 (`GaugeType`)**:\r\n- `id`, `parentId`, `typeName`: 维护无限极树的基础。\r\n- `precision`: 缺省精度\r\n- `isMsaRequired`: 强制MSA分析标记\r\n\r\n**量检具台账明细 (`GaugeLedger`)**:\r\n- `gaugeNo`: 设备唯一资产编号\r\n- `gaugeName`, `model`, `manufacturer`: 基本名牌参数\r\n- `accuracy`, `resolution`, `measureRange`: 测定边界能力\r\n- `calibrationCycle`: 周期(比如 12个月)\r\n- `lastCalDate`: 上次强检时间\r\n- `nextCalDate`: 证书失效/下次强检时间(触发报警核心字段)\r\n- `status`: 生命周期（`IN_USE`, `CALIBRATING`, `SEALED`, `SCRAPPED`）\r\n- `custodian`, `location`: 物理存放与保管责任追踪。\r\n\r\n## 5. 约束与规则\r\n- **强校准阻断**：当 `nextCalDate` 已过期，其对应的台账状态建议必须进入锁定态，不得在生产检验流程的下拉列表中再被选中作为“测定依据”，否则极易导致产品错漏判的质量事故。\r\n- **关联删除限制**：如果要删除左侧树节点类型时，系统必须防呆确保其下面未挂靠任何存量（哪怕是报废的）台账。\r\n";function J(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}var _=J();function Cn(t){_=t}var P={exec:()=>null};function T(t,n=""){let e=typeof t=="string"?t:t.source,a={replace:(r,s)=>{let o=typeof s=="string"?s:s.source;return o=o.replace(y.caret,"$1"),e=e.replace(r,o),a},getRegex:()=>new RegExp(e,n)};return a}var fe=(()=>{try{return!!new RegExp("(?<=1)(?<!1)")}catch{return!1}})(),y={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] +\S/,listReplaceTask:/^\[[ xX]\] +/,listTaskCheckbox:/\[[ xX]\]/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:t=>new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:t=>new RegExp(`^ {0,${Math.min(3,t-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:t=>new RegExp(`^ {0,${Math.min(3,t-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:t=>new RegExp(`^ {0,${Math.min(3,t-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:t=>new RegExp(`^ {0,${Math.min(3,t-1)}}#`),htmlBeginRegex:t=>new RegExp(`^ {0,${Math.min(3,t-1)}}<(?:[a-z].*>|!--)`,"i"),blockquoteBeginRegex:t=>new RegExp(`^ {0,${Math.min(3,t-1)}}>`)},he=/^(?:[ \t]*(?:\n|$))+/,Le=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,Pe=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,F=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,be=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,Z=/ {0,3}(?:[*+-]|\d{1,9}[.)])/,Rn=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,Sn=T(Rn).replace(/bull/g,Z).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/\|table/g,"").getRegex(),_e=T(Rn).replace(/bull/g,Z).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/table/g,/ {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(),$=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,Ne=/^[^\n]+/,nn=/(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/,Me=T(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",nn).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),Oe=T(/^(bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,Z).getRegex(),q="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",en=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,ke=T("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",en).replace("tag",q).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),yn=T($).replace("hr",F).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q).getRegex(),we=T(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",yn).getRegex(),tn={blockquote:we,code:Le,def:Me,fences:Pe,heading:be,hr:F,html:ke,lheading:Sn,list:Oe,newline:he,paragraph:yn,table:P,text:Ne},un=T("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",F).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q).getRegex(),Ue={...tn,lheading:_e,table:un,paragraph:T($).replace("hr",F).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",un).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",q).getRegex()},Be={...tn,html:T(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",en).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:P,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:T($).replace("hr",F).replace("heading",` *#{1,6} *[^
]`).replace("lheading",Sn).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},Fe=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,Qe=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,In=/^( {2,}|\\)\n(?!\s*$)/,xe=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,z=/[\p{P}\p{S}]/u,rn=/[\s\p{P}\p{S}]/u,En=/[^\s\p{P}\p{S}]/u,Ve=T(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,rn).getRegex(),vn=/(?!~)[\p{P}\p{S}]/u,Ge=/(?!~)[\s\p{P}\p{S}]/u,He=/(?:[^\s\p{P}\p{S}]|~)/u,Dn=/(?![*_])[\p{P}\p{S}]/u,qe=/(?![*_])[\s\p{P}\p{S}]/u,ze=/(?:[^\s\p{P}\p{S}]|[*_])/u,Ye=T(/link|precode-code|html/,"g").replace("link",/\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-",fe?"(?<!`)()":"(^^|[^`])").replace("code",/(?<b>`+)[^`]+\k<b>(?!`)/).replace("html",/<(?! )[^<>]*?>/).getRegex(),fn=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,We=T(fn,"u").replace(/punct/g,z).getRegex(),je=T(fn,"u").replace(/punct/g,vn).getRegex(),hn="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",Xe=T(hn,"gu").replace(/notPunctSpace/g,En).replace(/punctSpace/g,rn).replace(/punct/g,z).getRegex(),Ke=T(hn,"gu").replace(/notPunctSpace/g,He).replace(/punctSpace/g,Ge).replace(/punct/g,vn).getRegex(),Je=T("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,En).replace(/punctSpace/g,rn).replace(/punct/g,z).getRegex(),Ze=T(/^~~?(?:((?!~)punct)|[^\s~])/,"u").replace(/punct/g,Dn).getRegex(),$e="^[^~]+(?=[^~])|(?!~)punct(~~?)(?=[\\s]|$)|notPunctSpace(~~?)(?!~)(?=punctSpace|$)|(?!~)punctSpace(~~?)(?=notPunctSpace)|[\\s](~~?)(?!~)(?=punct)|(?!~)punct(~~?)(?!~)(?=punct)|notPunctSpace(~~?)(?=notPunctSpace)",nt=T($e,"gu").replace(/notPunctSpace/g,ze).replace(/punctSpace/g,qe).replace(/punct/g,Dn).getRegex(),et=T(/\\(punct)/,"gu").replace(/punct/g,z).getRegex(),tt=T(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),rt=T(en).replace("(?:-->|$)","-->").getRegex(),at=T("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",rt).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),V=/(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/,it=T(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label",V).replace("href",/<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),Ln=T(/^!?\[(label)\]\[(ref)\]/).replace("label",V).replace("ref",nn).getRegex(),Pn=T(/^!?\[(ref)\](?:\[\])?/).replace("ref",nn).getRegex(),st=T("reflink|nolink(?!\\()","g").replace("reflink",Ln).replace("nolink",Pn).getRegex(),dn=/[hH][tT][tT][pP][sS]?|[fF][tT][pP]/,an={_backpedal:P,anyPunctuation:et,autolink:tt,blockSkip:Ye,br:In,code:Qe,del:P,delLDelim:P,delRDelim:P,emStrongLDelim:We,emStrongRDelimAst:Xe,emStrongRDelimUnd:Je,escape:Fe,link:it,nolink:Pn,punctuation:Ve,reflink:Ln,reflinkSearch:st,tag:at,text:xe,url:P},ot={...an,link:T(/^!?\[(label)\]\((.*?)\)/).replace("label",V).getRegex(),reflink:T(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",V).getRegex()},j={...an,emStrongRDelimAst:Ke,emStrongLDelim:je,delLDelim:Ze,delRDelim:nt,url:T(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol",dn).replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,text:T(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol",dn).getRegex()},lt={...j,br:T(In).replace("{2,}","*").getRegex(),text:T(j.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},Q={normal:tn,gfm:Ue,pedantic:Be},w={normal:an,gfm:j,breaks:lt,pedantic:ot},ct={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},mn=t=>ct[t];function D(t,n){if(n){if(y.escapeTest.test(t))return t.replace(y.escapeReplace,mn)}else if(y.escapeTestNoEncode.test(t))return t.replace(y.escapeReplaceNoEncode,mn);return t}function gn(t){try{t=encodeURI(t).replace(y.percentDecode,"%")}catch{return null}return t}function Tn(t,n){var s;let e=t.replace(y.findPipe,(o,i,c)=>{let l=!1,u=i;for(;--u>=0&&c[u]==="\\";)l=!l;return l?"|":" |"}),a=e.split(y.splitPipe),r=0;if(a[0].trim()||a.shift(),a.length>0&&!((s=a.at(-1))!=null&&s.trim())&&a.pop(),n)if(a.length>n)a.splice(n);else for(;a.length<n;)a.push("");for(;r<a.length;r++)a[r]=a[r].trim().replace(y.slashPipe,"|");return a}function U(t,n,e){let a=t.length;if(a===0)return"";let r=0;for(;r<a&&t.charAt(a-r-1)===n;)r++;return t.slice(0,a-r)}function pt(t,n){if(t.indexOf(n[1])===-1)return-1;let e=0;for(let a=0;a<t.length;a++)if(t[a]==="\\")a++;else if(t[a]===n[0])e++;else if(t[a]===n[1]&&(e--,e<0))return a;return e>0?-2:-1}function ut(t,n=0){let e=n,a="";for(let r of t)if(r==="	"){let s=4-e%4;a+=" ".repeat(s),e+=s}else a+=r,e++;return a}function An(t,n,e,a,r){let s=n.href,o=n.title||null,i=t[1].replace(r.other.outputLinkReplace,"$1");a.state.inLink=!0;let c={type:t[0].charAt(0)==="!"?"image":"link",raw:e,href:s,title:o,text:i,tokens:a.inlineTokens(i)};return a.state.inLink=!1,c}function dt(t,n,e){let a=t.match(e.other.indentCodeCompensation);if(a===null)return n;let r=a[1];return n.split(`
`).map(s=>{let o=s.match(e.other.beginningSpace);if(o===null)return s;let[i]=o;return i.length>=r.length?s.slice(r.length):s}).join(`
`)}var G=class{constructor(t){R(this,"options");R(this,"rules");R(this,"lexer");this.options=t||_}space(t){let n=this.rules.block.newline.exec(t);if(n&&n[0].length>0)return{type:"space",raw:n[0]}}code(t){let n=this.rules.block.code.exec(t);if(n){let e=n[0].replace(this.rules.other.codeRemoveIndent,"");return{type:"code",raw:n[0],codeBlockStyle:"indented",text:this.options.pedantic?e:U(e,`
`)}}}fences(t){let n=this.rules.block.fences.exec(t);if(n){let e=n[0],a=dt(e,n[3]||"",this.rules);return{type:"code",raw:e,lang:n[2]?n[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):n[2],text:a}}}heading(t){let n=this.rules.block.heading.exec(t);if(n){let e=n[2].trim();if(this.rules.other.endingHash.test(e)){let a=U(e,"#");(this.options.pedantic||!a||this.rules.other.endingSpaceChar.test(a))&&(e=a.trim())}return{type:"heading",raw:n[0],depth:n[1].length,text:e,tokens:this.lexer.inline(e)}}}hr(t){let n=this.rules.block.hr.exec(t);if(n)return{type:"hr",raw:U(n[0],`
`)}}blockquote(t){let n=this.rules.block.blockquote.exec(t);if(n){let e=U(n[0],`
`).split(`
`),a="",r="",s=[];for(;e.length>0;){let o=!1,i=[],c;for(c=0;c<e.length;c++)if(this.rules.other.blockquoteStart.test(e[c]))i.push(e[c]),o=!0;else if(!o)i.push(e[c]);else break;e=e.slice(c);let l=i.join(`
`),u=l.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");a=a?`${a}
${l}`:l,r=r?`${r}
${u}`:u;let m=this.lexer.state.top;if(this.lexer.state.top=!0,this.lexer.blockTokens(u,s,!0),this.lexer.state.top=m,e.length===0)break;let d=s.at(-1);if((d==null?void 0:d.type)==="code")break;if((d==null?void 0:d.type)==="blockquote"){let p=d,C=p.raw+`
`+e.join(`
`),g=this.blockquote(C);s[s.length-1]=g,a=a.substring(0,a.length-p.raw.length)+g.raw,r=r.substring(0,r.length-p.text.length)+g.text;break}else if((d==null?void 0:d.type)==="list"){let p=d,C=p.raw+`
`+e.join(`
`),g=this.list(C);s[s.length-1]=g,a=a.substring(0,a.length-d.raw.length)+g.raw,r=r.substring(0,r.length-p.raw.length)+g.raw,e=C.substring(s.at(-1).raw.length).split(`
`);continue}}return{type:"blockquote",raw:a,tokens:s,text:r}}}list(t){var e,a;let n=this.rules.block.list.exec(t);if(n){let r=n[1].trim(),s=r.length>1,o={type:"list",raw:"",ordered:s,start:s?+r.slice(0,-1):"",loose:!1,items:[]};r=s?`\\d{1,9}\\${r.slice(-1)}`:`\\${r}`,this.options.pedantic&&(r=s?r:"[*+-]");let i=this.rules.other.listItemRegex(r),c=!1;for(;t;){let u=!1,m="",d="";if(!(n=i.exec(t))||this.rules.block.hr.test(t))break;m=n[0],t=t.substring(m.length);let p=ut(n[2].split(`
`,1)[0],n[1].length),C=t.split(`
`,1)[0],g=!p.trim(),S=0;if(this.options.pedantic?(S=2,d=p.trimStart()):g?S=n[1].length+1:(S=p.search(this.rules.other.nonSpaceChar),S=S>4?1:S,d=p.slice(S),S+=n[1].length),g&&this.rules.other.blankLine.test(C)&&(m+=C+`
`,t=t.substring(C.length+1),u=!0),!u){let v=this.rules.other.nextBulletRegex(S),N=this.rules.other.hrRegex(S),h=this.rules.other.fencesBeginRegex(S),f=this.rules.other.headingBeginRegex(S),Y=this.rules.other.htmlBeginRegex(S),bn=this.rules.other.blockquoteBeginRegex(S);for(;t;){let W=t.split(`
`,1)[0],O;if(C=W,this.options.pedantic?(C=C.replace(this.rules.other.listReplaceNesting,"  "),O=C):O=C.replace(this.rules.other.tabCharGlobal,"    "),h.test(C)||f.test(C)||Y.test(C)||bn.test(C)||v.test(C)||N.test(C))break;if(O.search(this.rules.other.nonSpaceChar)>=S||!C.trim())d+=`
`+O.slice(S);else{if(g||p.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||h.test(p)||f.test(p)||N.test(p))break;d+=`
`+C}g=!C.trim(),m+=W+`
`,t=t.substring(W.length+1),p=O.slice(S)}}o.loose||(c?o.loose=!0:this.rules.other.doubleBlankLine.test(m)&&(c=!0)),o.items.push({type:"list_item",raw:m,task:!!this.options.gfm&&this.rules.other.listIsTask.test(d),loose:!1,text:d,tokens:[]}),o.raw+=m}let l=o.items.at(-1);if(l)l.raw=l.raw.trimEnd(),l.text=l.text.trimEnd();else return;o.raw=o.raw.trimEnd();for(let u of o.items){if(this.lexer.state.top=!1,u.tokens=this.lexer.blockTokens(u.text,[]),u.task){if(u.text=u.text.replace(this.rules.other.listReplaceTask,""),((e=u.tokens[0])==null?void 0:e.type)==="text"||((a=u.tokens[0])==null?void 0:a.type)==="paragraph"){u.tokens[0].raw=u.tokens[0].raw.replace(this.rules.other.listReplaceTask,""),u.tokens[0].text=u.tokens[0].text.replace(this.rules.other.listReplaceTask,"");for(let d=this.lexer.inlineQueue.length-1;d>=0;d--)if(this.rules.other.listIsTask.test(this.lexer.inlineQueue[d].src)){this.lexer.inlineQueue[d].src=this.lexer.inlineQueue[d].src.replace(this.rules.other.listReplaceTask,"");break}}let m=this.rules.other.listTaskCheckbox.exec(u.raw);if(m){let d={type:"checkbox",raw:m[0]+" ",checked:m[0]!=="[ ]"};u.checked=d.checked,o.loose?u.tokens[0]&&["paragraph","text"].includes(u.tokens[0].type)&&"tokens"in u.tokens[0]&&u.tokens[0].tokens?(u.tokens[0].raw=d.raw+u.tokens[0].raw,u.tokens[0].text=d.raw+u.tokens[0].text,u.tokens[0].tokens.unshift(d)):u.tokens.unshift({type:"paragraph",raw:d.raw,text:d.raw,tokens:[d]}):u.tokens.unshift(d)}}if(!o.loose){let m=u.tokens.filter(p=>p.type==="space"),d=m.length>0&&m.some(p=>this.rules.other.anyLine.test(p.raw));o.loose=d}}if(o.loose)for(let u of o.items){u.loose=!0;for(let m of u.tokens)m.type==="text"&&(m.type="paragraph")}return o}}html(t){let n=this.rules.block.html.exec(t);if(n)return{type:"html",block:!0,raw:n[0],pre:n[1]==="pre"||n[1]==="script"||n[1]==="style",text:n[0]}}def(t){let n=this.rules.block.def.exec(t);if(n){let e=n[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),a=n[2]?n[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",r=n[3]?n[3].substring(1,n[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):n[3];return{type:"def",tag:e,raw:n[0],href:a,title:r}}}table(t){var o;let n=this.rules.block.table.exec(t);if(!n||!this.rules.other.tableDelimiter.test(n[2]))return;let e=Tn(n[1]),a=n[2].replace(this.rules.other.tableAlignChars,"").split("|"),r=(o=n[3])!=null&&o.trim()?n[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],s={type:"table",raw:n[0],header:[],align:[],rows:[]};if(e.length===a.length){for(let i of a)this.rules.other.tableAlignRight.test(i)?s.align.push("right"):this.rules.other.tableAlignCenter.test(i)?s.align.push("center"):this.rules.other.tableAlignLeft.test(i)?s.align.push("left"):s.align.push(null);for(let i=0;i<e.length;i++)s.header.push({text:e[i],tokens:this.lexer.inline(e[i]),header:!0,align:s.align[i]});for(let i of r)s.rows.push(Tn(i,s.header.length).map((c,l)=>({text:c,tokens:this.lexer.inline(c),header:!1,align:s.align[l]})));return s}}lheading(t){let n=this.rules.block.lheading.exec(t);if(n)return{type:"heading",raw:n[0],depth:n[2].charAt(0)==="="?1:2,text:n[1],tokens:this.lexer.inline(n[1])}}paragraph(t){let n=this.rules.block.paragraph.exec(t);if(n){let e=n[1].charAt(n[1].length-1)===`
`?n[1].slice(0,-1):n[1];return{type:"paragraph",raw:n[0],text:e,tokens:this.lexer.inline(e)}}}text(t){let n=this.rules.block.text.exec(t);if(n)return{type:"text",raw:n[0],text:n[0],tokens:this.lexer.inline(n[0])}}escape(t){let n=this.rules.inline.escape.exec(t);if(n)return{type:"escape",raw:n[0],text:n[1]}}tag(t){let n=this.rules.inline.tag.exec(t);if(n)return!this.lexer.state.inLink&&this.rules.other.startATag.test(n[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&this.rules.other.endATag.test(n[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(n[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(n[0])&&(this.lexer.state.inRawBlock=!1),{type:"html",raw:n[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:n[0]}}link(t){let n=this.rules.inline.link.exec(t);if(n){let e=n[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(e)){if(!this.rules.other.endAngleBracket.test(e))return;let s=U(e.slice(0,-1),"\\");if((e.length-s.length)%2===0)return}else{let s=pt(n[2],"()");if(s===-2)return;if(s>-1){let o=(n[0].indexOf("!")===0?5:4)+n[1].length+s;n[2]=n[2].substring(0,s),n[0]=n[0].substring(0,o).trim(),n[3]=""}}let a=n[2],r="";if(this.options.pedantic){let s=this.rules.other.pedanticHrefTitle.exec(a);s&&(a=s[1],r=s[3])}else r=n[3]?n[3].slice(1,-1):"";return a=a.trim(),this.rules.other.startAngleBracket.test(a)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(e)?a=a.slice(1):a=a.slice(1,-1)),An(n,{href:a&&a.replace(this.rules.inline.anyPunctuation,"$1"),title:r&&r.replace(this.rules.inline.anyPunctuation,"$1")},n[0],this.lexer,this.rules)}}reflink(t,n){let e;if((e=this.rules.inline.reflink.exec(t))||(e=this.rules.inline.nolink.exec(t))){let a=(e[2]||e[1]).replace(this.rules.other.multipleSpaceGlobal," "),r=n[a.toLowerCase()];if(!r){let s=e[0].charAt(0);return{type:"text",raw:s,text:s}}return An(e,r,e[0],this.lexer,this.rules)}}emStrong(t,n,e=""){let a=this.rules.inline.emStrongLDelim.exec(t);if(!(!a||a[3]&&e.match(this.rules.other.unicodeAlphaNumeric))&&(!(a[1]||a[2])||!e||this.rules.inline.punctuation.exec(e))){let r=[...a[0]].length-1,s,o,i=r,c=0,l=a[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(l.lastIndex=0,n=n.slice(-1*t.length+r);(a=l.exec(n))!=null;){if(s=a[1]||a[2]||a[3]||a[4]||a[5]||a[6],!s)continue;if(o=[...s].length,a[3]||a[4]){i+=o;continue}else if((a[5]||a[6])&&r%3&&!((r+o)%3)){c+=o;continue}if(i-=o,i>0)continue;o=Math.min(o,o+i+c);let u=[...a[0]][0].length,m=t.slice(0,r+a.index+u+o);if(Math.min(r,o)%2){let p=m.slice(1,-1);return{type:"em",raw:m,text:p,tokens:this.lexer.inlineTokens(p)}}let d=m.slice(2,-2);return{type:"strong",raw:m,text:d,tokens:this.lexer.inlineTokens(d)}}}}codespan(t){let n=this.rules.inline.code.exec(t);if(n){let e=n[2].replace(this.rules.other.newLineCharGlobal," "),a=this.rules.other.nonSpaceChar.test(e),r=this.rules.other.startingSpaceChar.test(e)&&this.rules.other.endingSpaceChar.test(e);return a&&r&&(e=e.substring(1,e.length-1)),{type:"codespan",raw:n[0],text:e}}}br(t){let n=this.rules.inline.br.exec(t);if(n)return{type:"br",raw:n[0]}}del(t,n,e=""){let a=this.rules.inline.delLDelim.exec(t);if(a&&(!a[1]||!e||this.rules.inline.punctuation.exec(e))){let r=[...a[0]].length-1,s,o,i=r,c=this.rules.inline.delRDelim;for(c.lastIndex=0,n=n.slice(-1*t.length+r);(a=c.exec(n))!=null;){if(s=a[1]||a[2]||a[3]||a[4]||a[5]||a[6],!s||(o=[...s].length,o!==r))continue;if(a[3]||a[4]){i+=o;continue}if(i-=o,i>0)continue;o=Math.min(o,o+i);let l=[...a[0]][0].length,u=t.slice(0,r+a.index+l+o),m=u.slice(r,-r);return{type:"del",raw:u,text:m,tokens:this.lexer.inlineTokens(m)}}}}autolink(t){let n=this.rules.inline.autolink.exec(t);if(n){let e,a;return n[2]==="@"?(e=n[1],a="mailto:"+e):(e=n[1],a=e),{type:"link",raw:n[0],text:e,href:a,tokens:[{type:"text",raw:e,text:e}]}}}url(t){var e;let n;if(n=this.rules.inline.url.exec(t)){let a,r;if(n[2]==="@")a=n[0],r="mailto:"+a;else{let s;do s=n[0],n[0]=((e=this.rules.inline._backpedal.exec(n[0]))==null?void 0:e[0])??"";while(s!==n[0]);a=n[0],n[1]==="www."?r="http://"+n[0]:r=n[0]}return{type:"link",raw:n[0],text:a,href:r,tokens:[{type:"text",raw:a,text:a}]}}}inlineText(t){let n=this.rules.inline.text.exec(t);if(n){let e=this.lexer.state.inRawBlock;return{type:"text",raw:n[0],text:n[0],escaped:e}}}},I=class X{constructor(n){R(this,"tokens");R(this,"options");R(this,"state");R(this,"inlineQueue");R(this,"tokenizer");this.tokens=[],this.tokens.links=Object.create(null),this.options=n||_,this.options.tokenizer=this.options.tokenizer||new G,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};let e={other:y,block:Q.normal,inline:w.normal};this.options.pedantic?(e.block=Q.pedantic,e.inline=w.pedantic):this.options.gfm&&(e.block=Q.gfm,this.options.breaks?e.inline=w.breaks:e.inline=w.gfm),this.tokenizer.rules=e}static get rules(){return{block:Q,inline:w}}static lex(n,e){return new X(e).lex(n)}static lexInline(n,e){return new X(e).inlineTokens(n)}lex(n){n=n.replace(y.carriageReturn,`
`),this.blockTokens(n,this.tokens);for(let e=0;e<this.inlineQueue.length;e++){let a=this.inlineQueue[e];this.inlineTokens(a.src,a.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(n,e=[],a=!1){var r,s,o;for(this.options.pedantic&&(n=n.replace(y.tabCharGlobal,"    ").replace(y.spaceLine,""));n;){let i;if((s=(r=this.options.extensions)==null?void 0:r.block)!=null&&s.some(l=>(i=l.call({lexer:this},n,e))?(n=n.substring(i.raw.length),e.push(i),!0):!1))continue;if(i=this.tokenizer.space(n)){n=n.substring(i.raw.length);let l=e.at(-1);i.raw.length===1&&l!==void 0?l.raw+=`
`:e.push(i);continue}if(i=this.tokenizer.code(n)){n=n.substring(i.raw.length);let l=e.at(-1);(l==null?void 0:l.type)==="paragraph"||(l==null?void 0:l.type)==="text"?(l.raw+=(l.raw.endsWith(`
`)?"":`
`)+i.raw,l.text+=`
`+i.text,this.inlineQueue.at(-1).src=l.text):e.push(i);continue}if(i=this.tokenizer.fences(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.heading(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.hr(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.blockquote(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.list(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.html(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.def(n)){n=n.substring(i.raw.length);let l=e.at(-1);(l==null?void 0:l.type)==="paragraph"||(l==null?void 0:l.type)==="text"?(l.raw+=(l.raw.endsWith(`
`)?"":`
`)+i.raw,l.text+=`
`+i.raw,this.inlineQueue.at(-1).src=l.text):this.tokens.links[i.tag]||(this.tokens.links[i.tag]={href:i.href,title:i.title},e.push(i));continue}if(i=this.tokenizer.table(n)){n=n.substring(i.raw.length),e.push(i);continue}if(i=this.tokenizer.lheading(n)){n=n.substring(i.raw.length),e.push(i);continue}let c=n;if((o=this.options.extensions)!=null&&o.startBlock){let l=1/0,u=n.slice(1),m;this.options.extensions.startBlock.forEach(d=>{m=d.call({lexer:this},u),typeof m=="number"&&m>=0&&(l=Math.min(l,m))}),l<1/0&&l>=0&&(c=n.substring(0,l+1))}if(this.state.top&&(i=this.tokenizer.paragraph(c))){let l=e.at(-1);a&&(l==null?void 0:l.type)==="paragraph"?(l.raw+=(l.raw.endsWith(`
`)?"":`
`)+i.raw,l.text+=`
`+i.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=l.text):e.push(i),a=c.length!==n.length,n=n.substring(i.raw.length);continue}if(i=this.tokenizer.text(n)){n=n.substring(i.raw.length);let l=e.at(-1);(l==null?void 0:l.type)==="text"?(l.raw+=(l.raw.endsWith(`
`)?"":`
`)+i.raw,l.text+=`
`+i.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=l.text):e.push(i);continue}if(n){let l="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent){console.error(l);break}else throw new Error(l)}}return this.state.top=!0,e}inline(n,e=[]){return this.inlineQueue.push({src:n,tokens:e}),e}inlineTokens(n,e=[]){var c,l,u,m,d;let a=n,r=null;if(this.tokens.links){let p=Object.keys(this.tokens.links);if(p.length>0)for(;(r=this.tokenizer.rules.inline.reflinkSearch.exec(a))!=null;)p.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(a=a.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(r=this.tokenizer.rules.inline.anyPunctuation.exec(a))!=null;)a=a.slice(0,r.index)+"++"+a.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);let s;for(;(r=this.tokenizer.rules.inline.blockSkip.exec(a))!=null;)s=r[2]?r[2].length:0,a=a.slice(0,r.index+s)+"["+"a".repeat(r[0].length-s-2)+"]"+a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);a=((l=(c=this.options.hooks)==null?void 0:c.emStrongMask)==null?void 0:l.call({lexer:this},a))??a;let o=!1,i="";for(;n;){o||(i=""),o=!1;let p;if((m=(u=this.options.extensions)==null?void 0:u.inline)!=null&&m.some(g=>(p=g.call({lexer:this},n,e))?(n=n.substring(p.raw.length),e.push(p),!0):!1))continue;if(p=this.tokenizer.escape(n)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.tag(n)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.link(n)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.reflink(n,this.tokens.links)){n=n.substring(p.raw.length);let g=e.at(-1);p.type==="text"&&(g==null?void 0:g.type)==="text"?(g.raw+=p.raw,g.text+=p.text):e.push(p);continue}if(p=this.tokenizer.emStrong(n,a,i)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.codespan(n)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.br(n)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.del(n,a,i)){n=n.substring(p.raw.length),e.push(p);continue}if(p=this.tokenizer.autolink(n)){n=n.substring(p.raw.length),e.push(p);continue}if(!this.state.inLink&&(p=this.tokenizer.url(n))){n=n.substring(p.raw.length),e.push(p);continue}let C=n;if((d=this.options.extensions)!=null&&d.startInline){let g=1/0,S=n.slice(1),v;this.options.extensions.startInline.forEach(N=>{v=N.call({lexer:this},S),typeof v=="number"&&v>=0&&(g=Math.min(g,v))}),g<1/0&&g>=0&&(C=n.substring(0,g+1))}if(p=this.tokenizer.inlineText(C)){n=n.substring(p.raw.length),p.raw.slice(-1)!=="_"&&(i=p.raw.slice(-1)),o=!0;let g=e.at(-1);(g==null?void 0:g.type)==="text"?(g.raw+=p.raw,g.text+=p.text):e.push(p);continue}if(n){let g="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent){console.error(g);break}else throw new Error(g)}}return e}},H=class{constructor(t){R(this,"options");R(this,"parser");this.options=t||_}space(t){return""}code({text:t,lang:n,escaped:e}){var s;let a=(s=(n||"").match(y.notSpaceStart))==null?void 0:s[0],r=t.replace(y.endingNewline,"")+`
`;return a?'<pre><code class="language-'+D(a)+'">'+(e?r:D(r,!0))+`</code></pre>
`:"<pre><code>"+(e?r:D(r,!0))+`</code></pre>
`}blockquote({tokens:t}){return`<blockquote>
${this.parser.parse(t)}</blockquote>
`}html({text:t}){return t}def(t){return""}heading({tokens:t,depth:n}){return`<h${n}>${this.parser.parseInline(t)}</h${n}>
`}hr(t){return`<hr>
`}list(t){let n=t.ordered,e=t.start,a="";for(let o=0;o<t.items.length;o++){let i=t.items[o];a+=this.listitem(i)}let r=n?"ol":"ul",s=n&&e!==1?' start="'+e+'"':"";return"<"+r+s+`>
`+a+"</"+r+`>
`}listitem(t){return`<li>${this.parser.parse(t.tokens)}</li>
`}checkbox({checked:t}){return"<input "+(t?'checked="" ':"")+'disabled="" type="checkbox"> '}paragraph({tokens:t}){return`<p>${this.parser.parseInline(t)}</p>
`}table(t){let n="",e="";for(let r=0;r<t.header.length;r++)e+=this.tablecell(t.header[r]);n+=this.tablerow({text:e});let a="";for(let r=0;r<t.rows.length;r++){let s=t.rows[r];e="";for(let o=0;o<s.length;o++)e+=this.tablecell(s[o]);a+=this.tablerow({text:e})}return a&&(a=`<tbody>${a}</tbody>`),`<table>
<thead>
`+n+`</thead>
`+a+`</table>
`}tablerow({text:t}){return`<tr>
${t}</tr>
`}tablecell(t){let n=this.parser.parseInline(t.tokens),e=t.header?"th":"td";return(t.align?`<${e} align="${t.align}">`:`<${e}>`)+n+`</${e}>
`}strong({tokens:t}){return`<strong>${this.parser.parseInline(t)}</strong>`}em({tokens:t}){return`<em>${this.parser.parseInline(t)}</em>`}codespan({text:t}){return`<code>${D(t,!0)}</code>`}br(t){return"<br>"}del({tokens:t}){return`<del>${this.parser.parseInline(t)}</del>`}link({href:t,title:n,tokens:e}){let a=this.parser.parseInline(e),r=gn(t);if(r===null)return a;t=r;let s='<a href="'+t+'"';return n&&(s+=' title="'+D(n)+'"'),s+=">"+a+"</a>",s}image({href:t,title:n,text:e,tokens:a}){a&&(e=this.parser.parseInline(a,this.parser.textRenderer));let r=gn(t);if(r===null)return D(e);t=r;let s=`<img src="${t}" alt="${D(e)}"`;return n&&(s+=` title="${D(n)}"`),s+=">",s}text(t){return"tokens"in t&&t.tokens?this.parser.parseInline(t.tokens):"escaped"in t&&t.escaped?t.text:D(t.text)}},sn=class{strong({text:t}){return t}em({text:t}){return t}codespan({text:t}){return t}del({text:t}){return t}html({text:t}){return t}text({text:t}){return t}link({text:t}){return""+t}image({text:t}){return""+t}br(){return""}checkbox({raw:t}){return t}},E=class K{constructor(n){R(this,"options");R(this,"renderer");R(this,"textRenderer");this.options=n||_,this.options.renderer=this.options.renderer||new H,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new sn}static parse(n,e){return new K(e).parse(n)}static parseInline(n,e){return new K(e).parseInline(n)}parse(n){var a,r;let e="";for(let s=0;s<n.length;s++){let o=n[s];if((r=(a=this.options.extensions)==null?void 0:a.renderers)!=null&&r[o.type]){let c=o,l=this.options.extensions.renderers[c.type].call({parser:this},c);if(l!==!1||!["space","hr","heading","code","table","blockquote","list","html","def","paragraph","text"].includes(c.type)){e+=l||"";continue}}let i=o;switch(i.type){case"space":{e+=this.renderer.space(i);break}case"hr":{e+=this.renderer.hr(i);break}case"heading":{e+=this.renderer.heading(i);break}case"code":{e+=this.renderer.code(i);break}case"table":{e+=this.renderer.table(i);break}case"blockquote":{e+=this.renderer.blockquote(i);break}case"list":{e+=this.renderer.list(i);break}case"checkbox":{e+=this.renderer.checkbox(i);break}case"html":{e+=this.renderer.html(i);break}case"def":{e+=this.renderer.def(i);break}case"paragraph":{e+=this.renderer.paragraph(i);break}case"text":{e+=this.renderer.text(i);break}default:{let c='Token with "'+i.type+'" type was not found.';if(this.options.silent)return console.error(c),"";throw new Error(c)}}}return e}parseInline(n,e=this.renderer){var r,s;let a="";for(let o=0;o<n.length;o++){let i=n[o];if((s=(r=this.options.extensions)==null?void 0:r.renderers)!=null&&s[i.type]){let l=this.options.extensions.renderers[i.type].call({parser:this},i);if(l!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type)){a+=l||"";continue}}let c=i;switch(c.type){case"escape":{a+=e.text(c);break}case"html":{a+=e.html(c);break}case"link":{a+=e.link(c);break}case"image":{a+=e.image(c);break}case"checkbox":{a+=e.checkbox(c);break}case"strong":{a+=e.strong(c);break}case"em":{a+=e.em(c);break}case"codespan":{a+=e.codespan(c);break}case"br":{a+=e.br(c);break}case"del":{a+=e.del(c);break}case"text":{a+=e.text(c);break}default:{let l='Token with "'+c.type+'" type was not found.';if(this.options.silent)return console.error(l),"";throw new Error(l)}}}return a}},x,B=(x=class{constructor(t){R(this,"options");R(this,"block");this.options=t||_}preprocess(t){return t}postprocess(t){return t}processAllTokens(t){return t}emStrongMask(t){return t}provideLexer(){return this.block?I.lex:I.lexInline}provideParser(){return this.block?E.parse:E.parseInline}},R(x,"passThroughHooks",new Set(["preprocess","postprocess","processAllTokens","emStrongMask"])),R(x,"passThroughHooksRespectAsync",new Set(["preprocess","postprocess","processAllTokens"])),x),mt=class{constructor(...t){R(this,"defaults",J());R(this,"options",this.setOptions);R(this,"parse",this.parseMarkdown(!0));R(this,"parseInline",this.parseMarkdown(!1));R(this,"Parser",E);R(this,"Renderer",H);R(this,"TextRenderer",sn);R(this,"Lexer",I);R(this,"Tokenizer",G);R(this,"Hooks",B);this.use(...t)}walkTokens(t,n){var a,r;let e=[];for(let s of t)switch(e=e.concat(n.call(this,s)),s.type){case"table":{let o=s;for(let i of o.header)e=e.concat(this.walkTokens(i.tokens,n));for(let i of o.rows)for(let c of i)e=e.concat(this.walkTokens(c.tokens,n));break}case"list":{let o=s;e=e.concat(this.walkTokens(o.items,n));break}default:{let o=s;(r=(a=this.defaults.extensions)==null?void 0:a.childTokens)!=null&&r[o.type]?this.defaults.extensions.childTokens[o.type].forEach(i=>{let c=o[i].flat(1/0);e=e.concat(this.walkTokens(c,n))}):o.tokens&&(e=e.concat(this.walkTokens(o.tokens,n)))}}return e}use(...t){let n=this.defaults.extensions||{renderers:{},childTokens:{}};return t.forEach(e=>{let a={...e};if(a.async=this.defaults.async||a.async||!1,e.extensions&&(e.extensions.forEach(r=>{if(!r.name)throw new Error("extension name required");if("renderer"in r){let s=n.renderers[r.name];s?n.renderers[r.name]=function(...o){let i=r.renderer.apply(this,o);return i===!1&&(i=s.apply(this,o)),i}:n.renderers[r.name]=r.renderer}if("tokenizer"in r){if(!r.level||r.level!=="block"&&r.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");let s=n[r.level];s?s.unshift(r.tokenizer):n[r.level]=[r.tokenizer],r.start&&(r.level==="block"?n.startBlock?n.startBlock.push(r.start):n.startBlock=[r.start]:r.level==="inline"&&(n.startInline?n.startInline.push(r.start):n.startInline=[r.start]))}"childTokens"in r&&r.childTokens&&(n.childTokens[r.name]=r.childTokens)}),a.extensions=n),e.renderer){let r=this.defaults.renderer||new H(this.defaults);for(let s in e.renderer){if(!(s in r))throw new Error(`renderer '${s}' does not exist`);if(["options","parser"].includes(s))continue;let o=s,i=e.renderer[o],c=r[o];r[o]=(...l)=>{let u=i.apply(r,l);return u===!1&&(u=c.apply(r,l)),u||""}}a.renderer=r}if(e.tokenizer){let r=this.defaults.tokenizer||new G(this.defaults);for(let s in e.tokenizer){if(!(s in r))throw new Error(`tokenizer '${s}' does not exist`);if(["options","rules","lexer"].includes(s))continue;let o=s,i=e.tokenizer[o],c=r[o];r[o]=(...l)=>{let u=i.apply(r,l);return u===!1&&(u=c.apply(r,l)),u}}a.tokenizer=r}if(e.hooks){let r=this.defaults.hooks||new B;for(let s in e.hooks){if(!(s in r))throw new Error(`hook '${s}' does not exist`);if(["options","block"].includes(s))continue;let o=s,i=e.hooks[o],c=r[o];B.passThroughHooks.has(s)?r[o]=l=>{if(this.defaults.async&&B.passThroughHooksRespectAsync.has(s))return(async()=>{let m=await i.call(r,l);return c.call(r,m)})();let u=i.call(r,l);return c.call(r,u)}:r[o]=(...l)=>{if(this.defaults.async)return(async()=>{let m=await i.apply(r,l);return m===!1&&(m=await c.apply(r,l)),m})();let u=i.apply(r,l);return u===!1&&(u=c.apply(r,l)),u}}a.hooks=r}if(e.walkTokens){let r=this.defaults.walkTokens,s=e.walkTokens;a.walkTokens=function(o){let i=[];return i.push(s.call(this,o)),r&&(i=i.concat(r.call(this,o))),i}}this.defaults={...this.defaults,...a}}),this}setOptions(t){return this.defaults={...this.defaults,...t},this}lexer(t,n){return I.lex(t,n??this.defaults)}parser(t,n){return E.parse(t,n??this.defaults)}parseMarkdown(t){return(n,e)=>{let a={...e},r={...this.defaults,...a},s=this.onError(!!r.silent,!!r.async);if(this.defaults.async===!0&&a.async===!1)return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return s(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return s(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));if(r.hooks&&(r.hooks.options=r,r.hooks.block=t),r.async)return(async()=>{let o=r.hooks?await r.hooks.preprocess(n):n,i=await(r.hooks?await r.hooks.provideLexer():t?I.lex:I.lexInline)(o,r),c=r.hooks?await r.hooks.processAllTokens(i):i;r.walkTokens&&await Promise.all(this.walkTokens(c,r.walkTokens));let l=await(r.hooks?await r.hooks.provideParser():t?E.parse:E.parseInline)(c,r);return r.hooks?await r.hooks.postprocess(l):l})().catch(s);try{r.hooks&&(n=r.hooks.preprocess(n));let o=(r.hooks?r.hooks.provideLexer():t?I.lex:I.lexInline)(n,r);r.hooks&&(o=r.hooks.processAllTokens(o)),r.walkTokens&&this.walkTokens(o,r.walkTokens);let i=(r.hooks?r.hooks.provideParser():t?E.parse:E.parseInline)(o,r);return r.hooks&&(i=r.hooks.postprocess(i)),i}catch(o){return s(o)}}}onError(t,n){return e=>{if(e.message+=`
Please report this to https://github.com/markedjs/marked.`,t){let a="<p>An error occurred:</p><pre>"+D(e.message+"",!0)+"</pre>";return n?Promise.resolve(a):a}if(n)return Promise.reject(e);throw e}}},b=new mt;function A(t,n){return b.parse(t,n)}A.options=A.setOptions=function(t){return b.setOptions(t),A.defaults=b.defaults,Cn(A.defaults),A};A.getDefaults=J;A.defaults=_;A.use=function(...t){return b.use(...t),A.defaults=b.defaults,Cn(A.defaults),A};A.walkTokens=function(t,n){return b.walkTokens(t,n)};A.parseInline=b.parseInline;A.Parser=E;A.parser=E.parse;A.Renderer=H;A.TextRenderer=sn;A.Lexer=I;A.lexer=I.lex;A.Tokenizer=G;A.Hooks=B;A.parse=A;A.options;A.setOptions;A.use;A.walkTokens;A.parseInline;E.parse;I.lex;const gt={class:"prd-container"},Tt={class:"prd-sidebar"},At={key:1,style:{padding:"24px","text-align":"center",color:"#999"}},Ct={class:"prd-content"},Rt={class:"doc-title"},St=["innerHTML"],yt={key:1,class:"text-body"},It={key:1,class:"empty-state"},Et=Mn({__name:"UpdateLog",setup(t){const n=Object.assign({"/PRD/QMS-BRD/初始需求/00-文档索引总览.md":Fn,"/PRD/QMS-BRD/初始需求/01-项目概述与背景分析.md":Qn,"/PRD/QMS-BRD/初始需求/02-项目目标与成功标准.md":xn,"/PRD/QMS-BRD/初始需求/03-项目范围与边界定义.md":Vn,"/PRD/QMS-BRD/初始需求/04-系统架构与技术方案.md":Gn,"/PRD/QMS-BRD/初始需求/05-核心功能模块(1-5章).md":Hn,"/PRD/QMS-BRD/初始需求/06-客诉8D管理模块.md":qn,"/PRD/QMS-BRD/初始需求/07-IQC检验体系模块.md":zn,"/PRD/QMS-BRD/初始需求/08-MSA-SPC-知识库模块.md":Yn,"/PRD/QMS-BRD/初始需求/09-供应商质量管理模块.md":Wn,"/PRD/QMS-BRD/初始需求/10-文档控制到培训管理.md":jn,"/PRD/QMS-BRD/初始需求/11-项目监控与持续改进.md":Xn,"/PRD/QMS-BRD/需求规范/舜富QMS系统API接口设计规范.md":Kn,"/PRD/QMS-BRD/需求规范/舜富QMS系统供应商管理模块详细实现规范.md":Jn,"/PRD/QMS-BRD/需求规范/舜富QMS系统培训管理模块详细实现规范.md":Zn,"/PRD/QMS-BRD/需求规范/舜富QMS系统审核管理模块详细实现规范.md":$n,"/PRD/QMS-BRD/需求规范/舜富QMS系统报表分析与决策支持模块详细实现规范.md":ne,"/PRD/QMS-BRD/需求规范/舜富QMS系统数据库设计规范.md":ee,"/PRD/QMS-BRD/需求规范/舜富QMS系统核心模块详细实现规范.md":te,"/PRD/QMS-BRD/需求规范/舜富QMS系统知识库管理模块详细实现规范.md":re,"/PRD/QMS-BRD/需求规范/舜富QMS系统质量检验模块详细实现规范.md":ae,"/PRD/QMS系统菜单重构方案.md":ie,"/PRD/基础数据/供应商档案_详细设计说明书.md":se,"/PRD/基础数据/储存地点_详细设计说明书.md":oe,"/PRD/基础数据/客供关系映射_详细设计说明书.md":le,"/PRD/基础数据/客户档案_详细设计说明书.md":ce,"/PRD/基础数据/客户特殊要求_详细设计说明书.md":pe,"/PRD/基础数据/工艺路线_详细设计说明书.md":ue,"/PRD/基础数据/物料产品档案_详细设计说明书.md":de,"/PRD/基础数据/物料分类_详细设计说明书.md":me,"/PRD/基础数据/生产班组_详细设计说明书.md":ge,"/PRD/基础数据/计量单位_详细设计说明书.md":Te,"/PRD/基础数据与质量主数据_需求文档.md":Ae,"/PRD/质量主数据/不良现象与缺陷库_详细设计说明书.md":Ce,"/PRD/质量主数据/抽样方案管理_详细设计说明书.md":Re,"/PRD/质量主数据/检验方法管理_详细设计说明书.md":Se,"/PRD/质量主数据/检验模板管理_详细设计说明书.md":ye,"/PRD/质量主数据/检验计划模型设计方案.md":Ie,"/PRD/质量主数据/检验项目管理_详细设计说明书.md":Ee,"/PRD/质量主数据/质量检验计划与方案_详细设计说明书.md":ve,"/PRD/质量主数据/量检具台账_详细设计说明书.md":De}),e=on([]),a=on(null),r=c=>{const l=[];for(const[u,m]of Object.entries(c)){const d=u.match(/\/PRD\/(.+)$/);if(!d)continue;const C=d[1].split("/");let g=l,S="";C.forEach((v,N)=>{S+=(S?"/":"")+v;const h=N===C.length-1;let f=g.find(Y=>Y.title===v);f||(f={title:v,key:S,isLeaf:h,selectable:h},h?f.content=m:f.children=[],g.push(f)),h||(g=f.children)})}return l};On(()=>{e.value=r(n)});const s=(c,l)=>{const u=l.node.dataRef;u&&u.isLeaf&&(a.value=u)},o=ln(()=>a.value?a.value.title.toLowerCase().endsWith(".md"):!1),i=ln(()=>{var c;return!o.value||!((c=a.value)!=null&&c.content)?"":A.parse(a.value.content)});return(c,l)=>{const u=cn("a-tree"),m=cn("a-empty");return L(),M("div",gt,[k("div",Tt,[l[0]||(l[0]=k("div",{class:"sidebar-header"},[k("h3",null,"需求文档 (PRD)")],-1)),e.value.length>0?(L(),kn(u,{key:0,"tree-data":e.value,"default-expand-all":!0,onSelect:s,blockNode:""},null,8,["tree-data"])):(L(),M("div",At," 未找到文档 "))]),k("div",Ct,[a.value?(L(),M(wn,{key:0},[k("h2",Rt,pn(a.value.title),1),o.value?(L(),M("div",{key:0,class:"markdown-body",innerHTML:i.value},null,8,St)):(L(),M("pre",yt,pn(a.value.content),1))],64)):(L(),M("div",It,[Un(m,{description:"请在左侧选择要查看的文档"})]))])])}}}),ht=Bn(Et,[["__scopeId","data-v-8e34b5d5"]]);export{ht as default};
